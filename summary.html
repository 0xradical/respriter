<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Summary of Alura</title>
</head>
<style>
  body {
    color:            gray;
    font-size:        10pt;
    font-family:      Monospace;
    background-color: black;
  }

  pre a       { text-decoration: none; }
  pre a:hover { text-decoration: underline; }

  pre a.keep   { color: white; }
  pre a.add    { color: green; }
  pre a.remove { color: red; }
</style>
<script>
  function getData(path) {
    return new Promise((resolve, reject) => {
      const rawData = new XMLHttpRequest()
      rawData.overrideMimeType('application/json')
      rawData.open('GET', path, true)
      rawData.onreadystatechange = () => {
        if (rawData.readyState === 4 && rawData.status == '200') {
          resolve( JSON.parse(rawData.responseText) )
        }
      }
      rawData.send(null)
    })
  }

  function afterContentLoaded() {
    Promise.all([
      getData('./tmp/json_5/structure_tokens.json'),
      getData('./tmp/json_5/flat_tokens.json'),
      getData('./tmp/json_5/summary.json')
    ]).then( (data) => afterDataLoaded.apply(null, data) )
  }

  // TODO: Remove data
  var data
  function afterDataLoaded(structure_tokens, flat_tokens, summary) {
    data = { structure_tokens, flat_tokens, summary }
    renderStructureDiff(data)
  }

  function padding(level) {
    let padding = ''
    for (let i = 0; i < level; i++) {
      padding += '  '
    }
    return padding
  }

  function htmlEntities(str) {
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
  }

  function tokenizedLink(index, step, content) {
    return `<a href="#" title="Index: ${index}" class="${step}">${content}</a>`
  }

  function replacementLink(index, step, content, occurrences) {
    return `<a href="#" title="#${occurrences} @${index}" class="${step}" data-index="${index}">${content}</a>`
  }

  function HTMLBuilder () {
    let html                 = ''
    let level                = 0
    let elementOpen          = false
    let singletonElementOpen = false

    return {
      html: () => html,
      level: () => level,
      printToken,
      closeElement,
      canReceiveAttributes,
      printReplacementToken,
      printSummary,
      printAttributesSummary,
      replacementTreeHasOnlyAttibutes
    }

    function printAttributesSummary(index, summary) {
      if (Object.keys(summary.tree.children).length == 0) {
        printAttributesByTree(index, summary.tree)
      } else {
        html += ' ' + replacementLink(index, 'add', 'REPLACEMENT_ATTRIBUTES', Object.keys(summary.tree.children).length)
      }
    }

    function printSummary(index, summary) {
      if (Object.keys(summary.tree.children).length == 0) {
        printAttributesByTree(index, summary.tree)
      } else {
        html += padding(level) + replacementLink(index, 'add', 'REPLACEMENT ELEMENTS', Object.keys(summary.tree.children).length) + "\n"
      }
    }

    function printAttributesByTree(index, tree) {
      html += `<a href="#" title="#${tree.elements.length} @${index}" class="add" data-index="${index}">`
      for (let type of tree.type) {
        if ( canReceiveAttributes() && !/^Attribute/.test(type) ) {
          closeElement()
        }
        printReplacementToken(type)
      }
      html += '</a>'
    }

    function replacementTreeHasOnlyAttibutes (tree) {
      if ( tree.type ) {
        for (let type of tree.type) {
          if ( !/^Attribute/.test(type) ) {
            return false
          }
        }
      }
      for (let key in tree.children) {
        if ( tree.children.hasOwnProperty(key) && !replacementTreeHasOnlyAttibutes(tree.children[key]) ) {
          return false
        }
      }
      return true
    }

    function closeElement () {
      if (elementOpen) {
        html += ">\n"
        elementOpen = false
      } else {
        html += "/>\n"
        singletonElementOpen = false
      }
    }

    function canReceiveAttributes () {
      return elementOpen || singletonElementOpen
    }

    function printToken(index, step, type, params) {
      switch(type) {
      case 'Document':
      case 'DTD':
        break
      case 'ElementSingleton':
        html += `${ padding(level) }${ htmlEntities('<') }${ tokenizedLink(index, step, params[0]) }`
        singletonElementOpen = true
        break
      case 'Element':
        html += `${ padding(level) }${ htmlEntities('<') }${ tokenizedLink(index, step, params[0]) }`
        level += 1
        elementOpen = true
        break
      case 'Attribute':
        html += ` ${ tokenizedLink(index, step, `${ params[0] }="${ params[1] }"`) }`
        break
      case 'AttributeName':
        html += ` ${ tokenizedLink(index, step, `${ params[0] }=`) }`
        break
      case 'AttributeValue':
        html += `${ tokenizedLink(index, step, `"${ params[0] }"`) }`
        break
      case 'ElementClose':
        level -= 1
        html += `${ padding(level) }${ htmlEntities('</') }${ tokenizedLink(index, step, params[0]) }${ htmlEntities('>') }\n`
        break
      case 'Comment':
        html += `${ htmlEntities('<!--') }${ tokenizedLink(index, step, htmlEntities(params[1])) }${ htmlEntities('-->') }\n`
        break
      case 'CDATA':
        html += tokenizedLink(index, step, htmlEntities(params[1])) + "\n"
        break
      case 'Text':
        if (params[1] != '') {
          html += tokenizedLink(index, step, htmlEntities(`${ padding(level) }${ params[1] }\n`))
        }
      }
    }

    function printReplacementToken(type) {
      let content

      switch(type) {
      case 'Document':
      case 'DTD':
        break
      case 'Attribute':
        alert('WTF?!')
        break
      case 'AttributeValue':
        html += '"REPLACEMENT VALUE"'
        break
      case 'Comment':
        html += padding(level) + htmlEntities('<!-- REPLACEMENT COMMENT -->') + "\n"
        break
      case 'CDATA':
        html += padding(level) + "REPLACEMENT CDATA\n"
        break
      case 'Text':
        html += padding(level) + "REPLACEMENT TEXT\n"
        break
      case 'ElementOpenClose':
        break
      default:
        switch(true) {
        case /^ElementSingleton\(([^\)]+)\)/.test(type) :
          content = type.match(/^ElementSingleton\(([^\)]+)\)/)[1]
          html += `${ padding(level) }${ htmlEntities('<') }${ content }`
          singletonElementOpen = true
          break
        case /^Element\(([^\)]+)\)/.test(type) :
          content = type.match(/^Element\(([^\)]+)\)/)[1]
          html += `${ padding(level) }${ htmlEntities('<') }${ content }`
          level += 1
          elementOpen = true
          break
        case /^AttributeName\(([^\)]+)\)/.test(type) :
          content = type.match(/^AttributeName\(([^\)]+)\)/)[1]
          html += ` ${ content }=`
          break
        case /^ElementClose\(([^\)]+)\)/.test(type) :
          content = type.match(/^ElementClose\(([^\)]+)\)/)[1]
          level -= 1
          html += `${ padding(level) }${ htmlEntities('</') }${ content }${ htmlEntities('>') }\n`
          break
        default:
          alert('WTF?!')
        }
      }
    }
  }

  function renderStructureDiff(data) {
    const builder = HTMLBuilder()
    // TODO: Remove it
    data.builder = builder

    for (let structureToken of data.structure_tokens ) {
      const {
        index: index,
        step:  step,
        token: [type, ...params]
      } = structureToken
      const summary = data.summary[index]
      const onlyAttributesReplacements = summary && builder.replacementTreeHasOnlyAttibutes(summary.tree)

      if ( summary && onlyAttributesReplacements ) {
        builder.printAttributesSummary(index, summary)
      }

      if ( builder.canReceiveAttributes() && type != 'Attribute' && type != 'AttributeName' && type != 'AttributeValue' ) {
        builder.closeElement()
      }

      if ( summary && !onlyAttributesReplacements ) {
        builder.printSummary(index, summary)
        if ( Object.keys(summary.tree.children).length == 0 && summary.tree.type[summary.tree.type.length - 1] == 'AttributeValue') {
          if ( builder.canReceiveAttributes() && type != 'Attribute' && type != 'AttributeName' && type != 'AttributeValue' ) {
            builder.closeElement()
          }
        }
      }

      builder.printToken(index, step, type, params)
    }

    document.getElementById('structure_diff').innerHTML = builder.html()
   }

  document.addEventListener('DOMContentLoaded', afterContentLoaded)
</script>
<body>
  <h1>Alura Diff</h1>
  <pre id="structure_diff"></pre>
</body>
</html>

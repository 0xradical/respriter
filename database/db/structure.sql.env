BEGIN;

CREATE SCHEMA IF NOT EXISTS api;
CREATE SCHEMA IF NOT EXISTS app;
CREATE SCHEMA IF NOT EXISTS jwt;
CREATE SCHEMA IF NOT EXISTS triggers;
CREATE SCHEMA IF NOT EXISTS settings;

CREATE EXTENSION IF NOT EXISTS citext      WITH SCHEMA public;
CREATE EXTENSION IF NOT EXISTS plpgsql     WITH SCHEMA pg_catalog;
CREATE EXTENSION IF NOT EXISTS pgcrypto    WITH SCHEMA public;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;

CREATE TYPE app.category AS ENUM (
  'arts_and_design',
  'business',
  'marketing',
  'computer_science',
  'data_science',
  'language_and_communication',
  'life_sciences',
  'math_and_logic',
  'personal_development',
  'physical_science_and_engineering',
  'social_science',
  'health_and_fitness',
  'social_sciences'
);

CREATE TYPE app.iso639_code AS ENUM (
  'ar-EG',
  'ar-JO',
  'ar-LB',
  'ar-SY',
  'de-DE',
  'en-AU',
  'en-BZ',
  'en-CA',
  'en-GB',
  'en-IN',
  'en-NZ',
  'en-US',
  'en-ZA',
  'es-AR',
  'es-BO',
  'es-CL',
  'es-CO',
  'es-EC',
  'es-ES',
  'es-GT',
  'es-MX',
  'es-PE',
  'es-VE',
  'fr-BE',
  'fr-CH',
  'fr-FR',
  'it-IT',
  'jp-JP',
  'nl-BE',
  'nl-NL',
  'pl-PL',
  'pt-BR',
  'pt-PT',
  'sv-SV',
  'zh-CN',
  'zh-CMN',
  'zh-HANS',
  'zh-HANT',
  'zh-TW',
  'af',
  'am',
  'ar',
  'az',
  'be',
  'bg',
  'bn',
  'bo',
  'bs',
  'ca',
  'co',
  'cs',
  'cy',
  'da',
  'de',
  'el',
  'en',
  'eo',
  'es',
  'et',
  'eu',
  'fa',
  'fi',
  'fil',
  'fr',
  'fy',
  'ga',
  'gd',
  'gl',
  'gu',
  'ha',
  'he',
  'hi',
  'hr',
  'ht',
  'hu',
  'hy',
  'id',
  'ig',
  'is',
  'it',
  'iw',
  'ja',
  'jp',
  'ka',
  'kk',
  'km',
  'kn',
  'ko',
  'ku',
  'ky',
  'lb',
  'lo',
  'lt',
  'lv',
  'mg',
  'mi',
  'mk',
  'ml',
  'mn',
  'mr',
  'ms',
  'mt',
  'my',
  'nb',
  'ne',
  'nl',
  'no',
  'pa',
  'pl',
  'ps',
  'pt',
  'ro',
  'ru',
  'rw',
  'sd',
  'si',
  'sk',
  'sl',
  'sn',
  'so',
  'sq',
  'sr',
  'st',
  'sv',
  'sw',
  'ta',
  'te',
  'tg',
  'th',
  'tl',
  'tr',
  'tt',
  'uk',
  'ur',
  'uz',
  'vi',
  'xh',
  'yi',
  'yo',
  'zh',
  'zu'
);

CREATE TYPE app.level AS ENUM (
  'beginner',
  'intermediate',
  'advanced'
);

CREATE TYPE app.pace AS ENUM (
  'self_paced',
  'instructor_paced',
  'live_class'
);

CREATE TYPE app.payment_source AS ENUM (
  'impact_radius',
  'awin',
  'rakuten',
  'share_a_sale',
  'commission_junction',
  'zanox'
);

CREATE TYPE app.payment_status AS ENUM (
  'open',
  'locked',
  'paid'
);

CREATE TYPE app.post_status AS ENUM (
  'void',
  'draft',
  'published',
  'disabled'
);

CREATE TYPE app.source AS ENUM (
  'api',
  'import',
  'admin'
);

CREATE TABLE api.admin_accounts (
  id                     bigserial    PRIMARY KEY,
  email                  varchar      DEFAULT ''::varchar NOT NULL,
  encrypted_password     varchar      DEFAULT ''::varchar NOT NULL,
  reset_password_token   varchar,
  reset_password_sent_at timestamptz,
  remember_created_at    timestamptz,
  sign_in_count          integer      DEFAULT 0           NOT NULL,
  current_sign_in_at     timestamptz,
  last_sign_in_at        timestamptz,
  current_sign_in_ip     inet,
  last_sign_in_ip        inet,
  confirmation_token     varchar,
  confirmed_at           timestamptz,
  confirmation_sent_at   timestamptz,
  unconfirmed_email      varchar,
  failed_attempts        integer      DEFAULT 0           NOT NULL,
  unlock_token           varchar,
  locked_at              timestamptz,
  created_at             timestamptz  DEFAULT NOW()       NOT NULL,
  updated_at             timestamptz  DEFAULT NOW()       NOT NULL,
  preferences            jsonb        DEFAULT '{}'::jsonb
);

CREATE TABLE api.admin_profiles (
  id                bigserial   PRIMARY KEY,
  name              varchar,
  bio               text,
  preferences       jsonb,
  admin_account_id  bigint      REFERENCES api.admin_accounts(id) ON DELETE CASCADE,
  created_at        timestamptz DEFAULT NOW() NOT NULL,
  updated_at        timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE api.providers (
  id                   bigserial    PRIMARY KEY,
  name                 public.citext,
  description          text,
  slug                 varchar,
  afn_url_template     varchar,
  published            boolean      DEFAULT false,
  published_at         timestamptz,
  created_at           timestamptz  DEFAULT NOW() NOT NULL,
  updated_at           timestamptz  DEFAULT NOW() NOT NULL,
  encoded_deep_linking boolean      DEFAULT false
);

CREATE TABLE api.courses (
  id                uuid          DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  global_sequence   integer,
  name              varchar,
  description       text,
  slug              varchar,
  url               varchar,
  url_md5           varchar,
  duration_in_hours numeric,
  price             numeric,
  rating            numeric,
  relevance         integer       DEFAULT 0,
  region            varchar,
  audio             text[]        DEFAULT '{}'::text[],
  subtitles         text[]        DEFAULT '{}'::text[],
  published         boolean       DEFAULT true,
  stale             boolean       DEFAULT false,
  category          app.category,
  provider_id       bigint        REFERENCES api.providers(id),
  created_at        timestamptz   DEFAULT NOW() NOT NULL,
  updated_at        timestamptz   DEFAULT NOW() NOT NULL,
  dataset_sequence  integer,
  resource_sequence integer,
  tags              text[]        DEFAULT '{}'::text[],
  video             jsonb,
  source            app.source    DEFAULT 'api'::app.source,
  pace              app.pace,
  certificate       jsonb         DEFAULT '"{}"'::jsonb,
  pricing_models    jsonb         DEFAULT '"[]"'::jsonb,
  offered_by        jsonb         DEFAULT '"[]"'::jsonb,
  syllabus          text,
  effort            integer,
  enrollments_count integer       DEFAULT 0,
  free_content      boolean       DEFAULT false,
  paid_content      boolean       DEFAULT true,
  level             app.level[]   DEFAULT '{}'::app.level[],
  __provider_name__ varchar,
  __source_schema__ jsonb,
  instructors       jsonb         DEFAULT '[]'::jsonb,
  curated_tags      varchar[]     DEFAULT '{}'::varchar[],
  refinement_tags   varchar[]
);

CREATE TABLE api.user_accounts (
  id                     bigserial    PRIMARY KEY,
  email                  varchar      DEFAULT ''::varchar NOT NULL,
  encrypted_password     varchar      DEFAULT ''::varchar NOT NULL,
  reset_password_token   varchar,
  reset_password_sent_at timestamptz,
  remember_created_at    timestamptz,
  sign_in_count          integer      DEFAULT 0           NOT NULL,
  current_sign_in_at     timestamptz,
  last_sign_in_at        timestamptz,
  current_sign_in_ip     inet,
  last_sign_in_ip        inet,
  tracking_data          json         DEFAULT '{}'::json  NOT NULL,
  confirmation_token     varchar,
  confirmed_at           timestamptz,
  confirmation_sent_at   timestamptz,
  unconfirmed_email      varchar,
  failed_attempts        integer      DEFAULT 0           NOT NULL,
  unlock_token           varchar,
  locked_at              timestamptz,
  destroyed_at           timestamptz,
  created_at             timestamptz  DEFAULT NOW()       NOT NULL,
  updated_at             timestamptz  DEFAULT NOW()       NOT NULL
);

CREATE TABLE api.tracked_searches (
  id            uuid        DEFAULT public.uuid_generate_v1() PRIMARY KEY,
  version       varchar,
  action        varchar,
  request       jsonb,
  results       jsonb,
  tracked_data  jsonb,
  created_at    timestamptz DEFAULT NOW() NOT NULL,
  updated_at    timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE api.enrollments (
  id                uuid        DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  user_account_id   bigint      REFERENCES api.user_accounts(id),
  course_id         uuid        REFERENCES api.courses(id),
  tracked_url       varchar,
  description       text,
  user_rating       numeric,
  tracked_search_id uuid        REFERENCES api.tracked_searches(id),
  tracking_data     jsonb       DEFAULT '{}'::jsonb,
  tracking_cookies  jsonb       DEFAULT '{}'::jsonb,
  created_at        timestamptz DEFAULT NOW() NOT NULL,
  updated_at        timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE api.favorites (
  id              bigserial   PRIMARY KEY,
  user_account_id bigint      REFERENCES api.user_accounts(id),
  course_id       uuid        REFERENCES api.courses(id),
  created_at      timestamptz DEFAULT NOW() NOT NULL,
  updated_at      timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE api.images (
  id             bigserial   PRIMARY KEY,
  caption        varchar,
  file           varchar,
  pos            integer     DEFAULT 0,
  imageable_type varchar,
  imageable_id   integer,
  created_at     timestamptz DEFAULT NOW() NOT NULL,
  updated_at     timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE api.landing_pages (
  id            bigserial   PRIMARY KEY,
  slug          public.citext,
  template      varchar,
  meta_html     text,
  html          jsonb       DEFAULT '{}'::jsonb,
  body_html     text,
  created_at    timestamptz DEFAULT NOW() NOT NULL,
  updated_at    timestamptz DEFAULT NOW() NOT NULL,
  data          jsonb       DEFAULT '{}'::jsonb,
  erb_template  text,
  layout        varchar
);

CREATE TABLE api.oauth_accounts (
  id              bigserial   PRIMARY KEY,
  provider        varchar,
  uid             varchar,
  raw_data        jsonb       DEFAULT '{}'::jsonb NOT NULL,
  user_account_id bigint      REFERENCES api.user_accounts(id) ON DELETE CASCADE,
  created_at      timestamptz DEFAULT NOW() NOT NULL,
  updated_at      timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE api.posts (
  id                  bigserial       PRIMARY KEY,
  slug                varchar,
  title               varchar,
  body                text,
  tags                varchar[]       DEFAULT '{}'::varchar[],
  meta                jsonb           DEFAULT '"{\"title\": \"\", \"description\": \"\"}"'::jsonb,
  locale              app.iso639_code DEFAULT 'en'::app.iso639_code,
  status              app.post_status DEFAULT 'draft'::app.post_status,
  content_fingerprint varchar,
  published_at        timestamptz,
  content_changed_at  timestamptz,
  admin_account_id    bigint          REFERENCES api.admin_accounts(id),
  created_at          timestamptz     DEFAULT NOW() NOT NULL,
  updated_at          timestamptz     DEFAULT NOW() NOT NULL,
  original_post_id    bigint          REFERENCES api.posts(id),
  use_cover_image     boolean         DEFAULT false
);

CREATE TABLE api.profiles (
  id              bigserial PRIMARY KEY,
  name            varchar,
  date_of_birth   date,
  avatar          varchar,
  user_account_id bigint    REFERENCES api.user_accounts(id) ON DELETE CASCADE,
  interests       text[]    DEFAULT '{}'::text[],
  preferences     jsonb     DEFAULT '{}'::jsonb
);

CREATE TABLE api.tracked_actions (
  id               uuid                DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  enrollment_id    uuid                REFERENCES api.enrollments(id),
  status           app.payment_status,
  source           app.payment_source,
  created_at       timestamptz         DEFAULT NOW() NOT NULL,
  updated_at       timestamptz         DEFAULT NOW() NOT NULL,
  sale_amount      numeric,
  earnings_amount  numeric,
  payload          jsonb,
  compound_ext_id  varchar,
  ext_click_date   timestamptz,
  ext_id           varchar,
  ext_sku_id       varchar,
  ext_product_name varchar
);

CREATE TABLE api.contacts (
  id         bigserial   PRIMARY KEY,
  name       varchar,
  email      varchar,
  subject    varchar,
  message    text,
  created_at timestamptz DEFAULT NOW() NOT NULL,
  updated_at timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE IF NOT EXISTS public.ar_internal_metadata (
  key        varchar     PRIMARY KEY,
  value      varchar,
  created_at timestamptz DEFAULT NOW() NOT NULL,
  updated_at timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE IF NOT EXISTS public.schema_migrations (
  version varchar PRIMARY KEY
);

CREATE TABLE settings.secrets (
  key   varchar PRIMARY KEY,
  value varchar
);

CREATE OR REPLACE FUNCTION api.admin_login(
  email    varchar,
  password varchar
) RETURNS text
AS $$
DECLARE
  _role    varchar;
  admin_id bigint;
  result   text;
BEGIN
  SELECT current_user INTO _role;

  SET ROLE "authenticator";

  SELECT
    id
  FROM api.admin_accounts
  WHERE
    api.admin_accounts.email              = admin_login.email AND
    api.admin_accounts.encrypted_password = public.crypt(admin_login.password, api.admin_accounts.encrypted_password)
  INTO admin_id;

  EXECUTE ('SET ROLE ' || _role);

  IF admin_id IS NULL THEN
    RAISE invalid_password USING message = 'invalid email or password';
  END IF;

  SELECT
    jwt.sign(
      row_to_json(r), settings.get('app.jwt_secret')
    ) AS token
  FROM (
    SELECT
      'admin'                                AS role,
      admin_id::varchar                      AS sub,
      extract(EPOCH FROM now())::int + 60*60 AS exp
  ) r
  INTO result;

  RETURN result;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION api.user_login(
  email    varchar,
  password varchar
) RETURNS text
AS $$
DECLARE
  _role   varchar;
  user_id bigint;
  result  text;
BEGIN
  SELECT current_user INTO _role;

  SET ROLE "authenticator";

  SELECT
    id
  FROM api.user_accounts
  WHERE
    api.user_accounts.email              = user_login.email AND
    api.user_accounts.encrypted_password = public.crypt(user_login.password, api.user_accounts.encrypted_password)
  INTO user_id;

  EXECUTE ('SET ROLE ' || _role);

  IF user_id IS NULL THEN
    RAISE invalid_password USING message = 'invalid user or password';
  END IF;

  SELECT
    jwt.sign(
      row_to_json(r), settings.get('app.jwt_secret')
    ) AS token
  FROM (
    SELECT
      'user'                                 AS role,
      user_id::varchar                       AS sub,
      extract(EPOCH FROM now())::int + 60*60 AS exp
  ) r
  INTO result;

  RETURN result;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION app.normalize_languages(languages text[]) RETURNS text[] AS $$
DECLARE
  upcased_languages text[];
BEGIN
  WITH

  subtitles AS (
    SELECT DISTINCT unnest(languages) AS subtitle
  ),

  subtitle_arrays AS (
    SELECT regexp_split_to_array(subtitle, '-') AS subtitle_array
    FROM subtitles
  )

  SELECT DISTINCT
    ARRAY_AGG(
      CASE WHEN array_length(subtitle_array, 1) = 2
      THEN subtitle_array[1] || '-' || upper(subtitle_array[2])
      ELSE subtitle_array[1]
      END
    )
  FROM subtitle_arrays
  INTO upcased_languages;

  RETURN upcased_languages;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION jwt.url_encode(data bytea) RETURNS text
AS $$
  SELECT translate(encode(data, 'base64'), E'+/=\n', '-_');
$$ LANGUAGE sql;

CREATE FUNCTION jwt.algorithm_sign(
  signables text,
  secret    text,
  algorithm text
) RETURNS text
AS $$
  WITH
    alg AS ( SELECT
      CASE
      WHEN algorithm = 'HS256' THEN 'sha256'
      WHEN algorithm = 'HS384' THEN 'sha384'
      WHEN algorithm = 'HS512' THEN 'sha512'
      ELSE ''
      END
    )  -- hmac throws error
  SELECT jwt.url_encode(public.hmac(signables, secret, (select * FROM alg)));
$$ LANGUAGE sql;

CREATE FUNCTION jwt.sign(
  payload json,
  secret text,
  algorithm text DEFAULT 'HS256'
) RETURNS text
AS $$
  WITH
    header AS (
      SELECT jwt.url_encode(convert_to('{"alg":"' || algorithm || '","typ":"JWT"}', 'utf8'))
    ),
    payload AS (
      SELECT jwt.url_encode(convert_to(payload::text, 'utf8'))
    ),
    signables AS (
      SELECT (SELECT * FROM header) || '.' || (SELECT * FROM payload)
    )

  SELECT
    (SELECT * FROM signables) ||
    '.' ||
    jwt.algorithm_sign(
      (SELECT * FROM signables),
      secret,
      algorithm
    );
$$ LANGUAGE sql;

CREATE FUNCTION jwt.url_decode(data text) RETURNS bytea
AS $$
WITH
  t   AS ( SELECT translate(data, '-_', '+/') ),
  rem AS ( SELECT length((SELECT * FROM t)) % 4) -- compute padding size
  SELECT decode(
    (SELECT * FROM t) ||
    CASE WHEN (SELECT * FROM rem) > 0
      THEN repeat('=', (4 - (SELECT * FROM rem)))
      ELSE ''
    END,
    'base64'
  );
$$ LANGUAGE sql;

CREATE FUNCTION jwt.verify(
  token     text,
  secret    text,
  algorithm text DEFAULT 'HS256'
) RETURNS table(header json, payload json, valid boolean)
AS $$
  SELECT
    convert_from(jwt.url_decode(r[1]), 'utf8')::json AS header,
    convert_from(jwt.url_decode(r[2]), 'utf8')::json AS payload,
    r[3] = jwt.algorithm_sign(r[1] || '.' || r[2], secret, algorithm) AS valid
  FROM regexp_split_to_array(token, '\.') r;
$$ LANGUAGE sql;

CREATE FUNCTION settings.get(varchar)
RETURNS varchar
AS $$
  SELECT value
  FROM settings.secrets
  WHERE key = $1
$$ SECURITY DEFINER STABLE LANGUAGE sql;

CREATE FUNCTION settings.set(varchar, varchar)
RETURNS VOID
AS $$
  INSERT INTO settings.secrets (key, value)
  VALUES ($1, $2)
  ON CONFLICT (key) DO UPDATE
  SET value = $2;
$$ SECURITY DEFINER LANGUAGE sql;

CREATE FUNCTION triggers.course_normalize_languages() RETURNS trigger AS $$
BEGIN
  NEW.audio     = app.normalize_languages(NEW.audio);
  NEW.subtitles = app.normalize_languages(NEW.subtitles);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.encrypt_password() RETURNS trigger
AS $$
BEGIN
  IF NEW.encrypted_password ~* '^\$\d\w\$\d{2}\$[^$]{53}$' THEN
    RETURN NEW;
  END IF;

  IF tg_op = 'INSERT' OR NEW.encrypted_password <> OLD.encrypted_password THEN
    NEW.encrypted_password = crypt(NEW.encrypted_password, gen_salt('bf', 11));
  END IF;

  RETURN NEW;
end
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.gen_compound_ext_id() RETURNS trigger AS $$
BEGIN
  NEW.compound_ext_id = concat(NEW.source,'_',NEW.ext_id);
  return NEW;
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.insert_or_add_to_provider() RETURNS trigger AS $$
DECLARE
  _provider        api.providers%ROWTYPE;
  _new_provider_id int;
BEGIN
  SELECT * FROM api.providers INTO _provider where providers.name = NEW.__provider_name__;
  IF (NOT FOUND) THEN
    INSERT INTO api.providers (name, published, created_at, updated_at) VALUES (NEW.__provider_name__, false, NOW(), NOW()) RETURNING id INTO _new_provider_id;
    NEW.published = false;
    NEW.provider_id = _new_provider_id;
  ELSE
    NEW.provider_id = _provider.id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.md5_url() RETURNS trigger AS $$
BEGIN
  NEW.url_md5=md5(NEW.url);
  return NEW;
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.sort_prices() RETURNS trigger AS $$
DECLARE
  price                 jsonb;
  prices                jsonb[];
  results               jsonb[];
  single_course_prices  jsonb[];
  subscription_prices   jsonb[];
BEGIN
  FOR price IN SELECT * FROM jsonb_array_elements((NEW.__source_schema__ -> 'content' ->> 'prices')::jsonb)
  LOOP
    IF (price ->> 'type' = 'single_course') THEN
      single_course_prices := array_append(single_course_prices,price);
    ELSIF (price ->> 'type' = 'subscription') THEN
      IF (price -> 'subscription_period' ->> 'unit' = 'months') THEN
        subscription_prices := array_prepend(price,subscription_prices);
      ELSIF (price -> 'subscription_period' ->> 'unit' = 'years') THEN
        subscription_prices := array_append(subscription_prices,price);
      END IF;
    END IF;
  END LOOP;
  results := (single_course_prices || subscription_prices);
  IF array_length(results,1) > 0 THEN
    NEW.pricing_models = to_jsonb(results);
  END IF;
  NEW.__source_schema__ = NULL;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.track_updated_at() RETURNS trigger
AS $$
BEGIN
  IF NEW.updated_at = OLD.updated_at THEN
    NEW.updated_at := NOW();
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER encrypt_password
  BEFORE INSERT OR UPDATE
  ON api.admin_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.encrypt_password();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.admin_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.admin_profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER set_global_id
  BEFORE INSERT
  ON api.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.md5_url();

CREATE TRIGGER course_normalize_languages
  BEFORE INSERT OR UPDATE
  ON api.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.course_normalize_languages();

CREATE TRIGGER sort_prices
  BEFORE INSERT OR UPDATE
  ON api.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.sort_prices();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.enrollments
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.favorites
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.images
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.landing_pages
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.oauth_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.posts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.providers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER set_compound_ext_id
  BEFORE INSERT
  ON api.tracked_actions
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.gen_compound_ext_id();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.tracked_actions
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.tracked_searches
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER encrypt_password
  BEFORE INSERT OR UPDATE
  ON api.user_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.encrypt_password();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.user_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON api.contacts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON public.ar_internal_metadata
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE UNIQUE INDEX index_admin_accounts_on_confirmation_token
ON api.admin_accounts
USING btree (confirmation_token);

CREATE UNIQUE INDEX index_admin_accounts_on_email
ON api.admin_accounts
USING btree (email);

CREATE UNIQUE INDEX index_admin_accounts_on_reset_password_token
ON api.admin_accounts
USING btree (reset_password_token);

CREATE UNIQUE INDEX index_admin_accounts_on_unlock_token
ON api.admin_accounts
USING btree (unlock_token);

CREATE INDEX index_admin_profiles_on_admin_account_id
ON api.admin_profiles
USING btree (admin_account_id);

CREATE INDEX index_courses_on_curated_tags
ON api.courses
USING gin (curated_tags);

CREATE INDEX index_courses_on_dataset_sequence
ON api.courses
USING btree (dataset_sequence);

CREATE INDEX index_courses_on_global_sequence
ON api.courses
USING btree (global_sequence);

CREATE INDEX index_courses_on_provider_id
ON api.courses
USING btree (provider_id);

CREATE UNIQUE INDEX index_courses_on_slug
ON api.courses
USING btree (slug);

CREATE INDEX index_courses_on_tags
ON api.courses
USING gin (tags);

CREATE UNIQUE INDEX index_courses_on_url_md5
ON api.courses
USING btree (url_md5);

CREATE INDEX index_enrollments_on_course_id
ON api.enrollments
USING btree (course_id);

CREATE INDEX index_enrollments_on_tracked_search_id
ON api.enrollments
USING btree (tracked_search_id);

CREATE INDEX index_enrollments_on_tracking_data
ON api.enrollments
USING gin (tracking_data);

CREATE INDEX index_enrollments_on_user_account_id
ON api.enrollments
USING btree (user_account_id);

CREATE INDEX index_favorites_on_course_id
ON api.favorites
USING btree (course_id);

CREATE INDEX index_favorites_on_user_account_id
ON api.favorites
USING btree (user_account_id);

CREATE INDEX index_images_on_imageable_type_and_imageable_id
ON api.images
USING btree (imageable_type, imageable_id);

CREATE UNIQUE INDEX index_landing_pages_on_slug
ON api.landing_pages
USING btree (slug);

CREATE INDEX index_oauth_accounts_on_user_account_id
ON api.oauth_accounts
USING btree (user_account_id);

CREATE INDEX index_posts_on_admin_account_id
ON api.posts
USING btree (admin_account_id);

CREATE INDEX index_posts_on_original_post_id
ON api.posts
USING btree (original_post_id);

CREATE UNIQUE INDEX index_posts_on_slug
ON api.posts
USING btree (slug);

CREATE INDEX index_posts_on_tags
ON api.posts
USING gin (tags);

CREATE INDEX index_profiles_on_user_account_id
ON api.profiles
USING btree (user_account_id);

CREATE UNIQUE INDEX index_providers_on_name
ON api.providers
USING btree (name);

CREATE UNIQUE INDEX index_providers_on_slug
ON api.providers
USING btree (slug);

CREATE UNIQUE INDEX index_tracked_actions_on_compound_ext_id
ON api.tracked_actions
USING btree (compound_ext_id);

CREATE INDEX index_tracked_actions_on_enrollment_id
ON api.tracked_actions
USING btree (enrollment_id);

CREATE INDEX index_tracked_actions_on_payload
ON api.tracked_actions
USING gin (payload);

CREATE INDEX index_tracked_actions_on_status
ON api.tracked_actions
USING btree (status);

CREATE INDEX index_tracked_searches_on_action
ON api.tracked_searches
USING btree (action);

CREATE UNIQUE INDEX index_user_accounts_on_confirmation_token
ON api.user_accounts
USING btree (confirmation_token);

CREATE UNIQUE INDEX index_user_accounts_on_email
ON api.user_accounts
USING btree (email);

CREATE UNIQUE INDEX index_user_accounts_on_reset_password_token
ON api.user_accounts
USING btree (reset_password_token);

CREATE UNIQUE INDEX index_user_accounts_on_unlock_token
ON api.user_accounts
USING btree (unlock_token);

CREATE VIEW api.earnings AS
  SELECT
    tracked_actions.id,
    tracked_actions.sale_amount,
    tracked_actions.earnings_amount,
    tracked_actions.ext_click_date,
    tracked_actions.ext_sku_id,
    tracked_actions.ext_product_name,
    tracked_actions.ext_id,
    tracked_actions.source                             AS affiliate_network,
    providers.name                                     AS provider_name,
    courses.name                                       AS course_name,
    courses.url                                        AS course_url,
    (enrollments.tracking_data->>'country')::text      AS country,
    (enrollments.tracking_data->>'query_string')::text AS qs,
    (enrollments.tracking_data->>'referer')::text      AS referer,
    (enrollments.tracking_data->>'utm_source')::text   AS utm_source,
    (enrollments.tracking_data->>'utm_campaign')::text AS utm_campaign,
    (enrollments.tracking_data->>'utm_medium')::text   AS utm_medium,
    (enrollments.tracking_data->>'utm_term')::text     AS utm_term,
    tracked_actions.created_at
  FROM api.tracked_actions
    LEFT JOIN api.enrollments ON enrollments.id = tracked_actions.enrollment_id
    LEFT JOIN api.courses     ON courses.id     = enrollments.course_id
    LEFT JOIN api.providers   ON providers.id   = courses.provider_id;

CREATE ROLE "anonymous";

GRANT USAGE ON SCHEMA api      TO "anonymous";
GRANT USAGE ON SCHEMA jwt      TO "anonymous";
GRANT USAGE ON SCHEMA settings TO "anonymous";

CREATE ROLE "user";

GRANT USAGE ON SCHEMA api      TO "user";
GRANT USAGE ON SCHEMA jwt      TO "user";
GRANT USAGE ON SCHEMA settings TO "user";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA api TO "user";

CREATE ROLE "admin";

GRANT USAGE ON SCHEMA api      TO "admin";
GRANT USAGE ON SCHEMA app      TO "admin";
GRANT USAGE ON SCHEMA jwt      TO "admin";
GRANT USAGE ON SCHEMA settings TO "admin";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA api TO "admin";

GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TABLE api.admin_accounts   TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TABLE api.admin_profiles   TO "admin";
GRANT SELECT, INSERT, UPDATE,         REFERENCES ON TABLE api.courses          TO "admin";
GRANT SELECT, INSERT,         DELETE, REFERENCES ON TABLE api.enrollments      TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TABLE api.favorites        TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TABLE api.images           TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TABLE api.landing_pages    TO "admin";
GRANT SELECT,         UPDATE, DELETE, REFERENCES ON TABLE api.oauth_accounts   TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TABLE api.posts            TO "admin";
GRANT SELECT, INSERT, UPDATE,         REFERENCES ON TABLE api.profiles         TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TABLE api.providers        TO "admin";
GRANT SELECT                                     ON TABLE api.tracked_actions  TO "admin";
GRANT SELECT                                     ON TABLE api.tracked_searches TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TABLE api.user_accounts    TO "admin";
GRANT SELECT                                     ON TABLE api.earnings         TO "admin";

CREATE ROLE "authenticator" NOINHERIT login password '$AUTHENTICATOR_PASSWORD';

GRANT "user"      TO "authenticator";
GRANT "admin"     TO "authenticator";
GRANT "anonymous" TO "authenticator";

GRANT USAGE ON SCHEMA api      TO "authenticator";
GRANT USAGE ON SCHEMA jwt      TO "authenticator";
GRANT USAGE ON SCHEMA settings TO "authenticator";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA api TO "authenticator";

GRANT SELECT ON TABLE api.user_accounts, api.admin_accounts TO "authenticator";

INSERT INTO settings.secrets (key, value) VALUES ('app.jwt_secret', '$JWT_SECRET');

INSERT INTO public.schema_migrations(version) VALUES
  ('20180101010101'),
  ('20180101010102'),
  ('20180101010103'),
  ('20180101010104'),
  ('20180101010105'),
  ('20180101010106'),
  ('20180101010107'),
  ('20180101010108'),
  ('20180101010109'),
  ('20181017123839'),
  ('20181018075955'),
  ('20181030111522'),
  ('20181129103819');

COMMIT;

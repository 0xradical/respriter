BEGIN;

CREATE SCHEMA IF NOT EXISTS api;
CREATE SCHEMA IF NOT EXISTS app;
CREATE SCHEMA IF NOT EXISTS jwt;
CREATE SCHEMA IF NOT EXISTS triggers;
CREATE SCHEMA IF NOT EXISTS settings;

CREATE EXTENSION IF NOT EXISTS citext      WITH SCHEMA public;
CREATE EXTENSION IF NOT EXISTS plpgsql     WITH SCHEMA pg_catalog;
CREATE EXTENSION IF NOT EXISTS pgcrypto    WITH SCHEMA public;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;

CREATE TYPE app.category AS ENUM (
  'arts_and_design',
  'business',
  'marketing',
  'computer_science',
  'data_science',
  'language_and_communication',
  'life_sciences',
  'math_and_logic',
  'personal_development',
  'physical_science_and_engineering',
  'social_science',
  'health_and_fitness',
  'social_sciences'
);

CREATE TYPE app.iso639_code AS ENUM (
  'ar-EG',
  'ar-JO',
  'ar-LB',
  'ar-SY',
  'de-DE',
  'en-AU',
  'en-BZ',
  'en-CA',
  'en-GB',
  'en-IN',
  'en-NZ',
  'en-US',
  'en-ZA',
  'es-AR',
  'es-BO',
  'es-CL',
  'es-CO',
  'es-EC',
  'es-ES',
  'es-GT',
  'es-MX',
  'es-PE',
  'es-VE',
  'fr-BE',
  'fr-CH',
  'fr-FR',
  'it-IT',
  'jp-JP',
  'nl-BE',
  'nl-NL',
  'pl-PL',
  'pt-BR',
  'pt-PT',
  'sv-SV',
  'zh-CN',
  'zh-CMN',
  'zh-HANS',
  'zh-HANT',
  'zh-TW',
  'af',
  'am',
  'ar',
  'az',
  'be',
  'bg',
  'bn',
  'bo',
  'bs',
  'ca',
  'co',
  'cs',
  'cy',
  'da',
  'de',
  'el',
  'en',
  'eo',
  'es',
  'et',
  'eu',
  'fa',
  'fi',
  'fil',
  'fr',
  'fy',
  'ga',
  'gd',
  'gl',
  'gu',
  'ha',
  'he',
  'hi',
  'hr',
  'ht',
  'hu',
  'hy',
  'id',
  'ig',
  'is',
  'it',
  'iw',
  'ja',
  'jp',
  'ka',
  'kk',
  'km',
  'kn',
  'ko',
  'ku',
  'ky',
  'lb',
  'lo',
  'lt',
  'lv',
  'mg',
  'mi',
  'mk',
  'ml',
  'mn',
  'mr',
  'ms',
  'mt',
  'my',
  'nb',
  'ne',
  'nl',
  'no',
  'pa',
  'pl',
  'ps',
  'pt',
  'ro',
  'ru',
  'rw',
  'sd',
  'si',
  'sk',
  'sl',
  'sn',
  'so',
  'sq',
  'sr',
  'st',
  'sv',
  'sw',
  'ta',
  'te',
  'tg',
  'th',
  'tl',
  'tr',
  'tt',
  'uk',
  'ur',
  'uz',
  'vi',
  'xh',
  'yi',
  'yo',
  'zh',
  'zu'
);

CREATE TYPE app.level AS ENUM (
  'beginner',
  'intermediate',
  'advanced'
);

CREATE TYPE app.pace AS ENUM (
  'self_paced',
  'instructor_paced',
  'live_class'
);

CREATE TYPE app.payment_source AS ENUM (
  'impact_radius',
  'awin',
  'rakuten',
  'share_a_sale',
  'commission_junction',
  'zanox'
);

CREATE TYPE app.payment_status AS ENUM (
  'open',
  'locked',
  'paid'
);

CREATE TYPE app.post_status AS ENUM (
  'void',
  'draft',
  'published',
  'disabled'
);

CREATE TYPE app.source AS ENUM (
  'api',
  'import',
  'admin'
);

CREATE TABLE app.admin_accounts (
  id                     bigserial    PRIMARY KEY,
  email                  varchar      DEFAULT ''::varchar NOT NULL,
  encrypted_password     varchar      DEFAULT ''::varchar NOT NULL,
  reset_password_token   varchar,
  reset_password_sent_at timestamptz,
  remember_created_at    timestamptz,
  sign_in_count          integer      DEFAULT 0           NOT NULL,
  current_sign_in_at     timestamptz,
  last_sign_in_at        timestamptz,
  current_sign_in_ip     inet,
  last_sign_in_ip        inet,
  confirmation_token     varchar,
  confirmed_at           timestamptz,
  confirmation_sent_at   timestamptz,
  unconfirmed_email      varchar,
  failed_attempts        integer      DEFAULT 0           NOT NULL,
  unlock_token           varchar,
  locked_at              timestamptz,
  created_at             timestamptz  DEFAULT NOW()       NOT NULL,
  updated_at             timestamptz  DEFAULT NOW()       NOT NULL,
  preferences            jsonb        DEFAULT '{}'::jsonb
);

CREATE TABLE app.admin_profiles (
  id                bigserial   PRIMARY KEY,
  name              varchar,
  bio               text,
  preferences       jsonb,
  admin_account_id  bigint      REFERENCES app.admin_accounts(id) ON DELETE CASCADE,
  created_at        timestamptz DEFAULT NOW() NOT NULL,
  updated_at        timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.user_accounts (
  id                     bigserial    PRIMARY KEY,
  email                  varchar      DEFAULT ''::varchar NOT NULL,
  encrypted_password     varchar      DEFAULT ''::varchar NOT NULL,
  reset_password_token   varchar,
  reset_password_sent_at timestamptz,
  remember_created_at    timestamptz,
  sign_in_count          integer      DEFAULT 0           NOT NULL,
  current_sign_in_at     timestamptz,
  last_sign_in_at        timestamptz,
  current_sign_in_ip     inet,
  last_sign_in_ip        inet,
  tracking_data          json         DEFAULT '{}'::json  NOT NULL,
  confirmation_token     varchar,
  confirmed_at           timestamptz,
  confirmation_sent_at   timestamptz,
  unconfirmed_email      varchar,
  failed_attempts        integer      DEFAULT 0           NOT NULL,
  unlock_token           varchar,
  locked_at              timestamptz,
  destroyed_at           timestamptz,
  created_at             timestamptz  DEFAULT NOW()       NOT NULL,
  updated_at             timestamptz  DEFAULT NOW()       NOT NULL
);

CREATE TABLE app.certificates (
  id              bigserial   PRIMARY KEY,
  user_account_id bigint      REFERENCES app.user_accounts(id),
  file            varchar     CONSTRAINT valid_file_format CHECK ( lower(file) ~ '.(gif|jpg|jpeg|png|pdf)$' ),
  created_at      timestamptz DEFAULT NOW() NOT NULL,
  updated_at      timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.contacts (
  id         bigserial   PRIMARY KEY,
  name       varchar,
  email      varchar,
  subject    varchar,
  message    text,
  created_at timestamptz DEFAULT NOW() NOT NULL,
  updated_at timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.providers (
  id                   bigserial    PRIMARY KEY,
  name                 public.citext,
  description          text,
  slug                 varchar,
  afn_url_template     varchar,
  published            boolean      DEFAULT false,
  published_at         timestamptz,
  created_at           timestamptz  DEFAULT NOW() NOT NULL,
  updated_at           timestamptz  DEFAULT NOW() NOT NULL,
  encoded_deep_linking boolean      DEFAULT false
);

CREATE TABLE app.courses (
  id                uuid          DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  global_sequence   integer,
  name              varchar,
  description       text,
  slug              varchar,
  url               varchar,
  url_md5           varchar,
  duration_in_hours numeric,
  price             numeric,
  rating            numeric,
  relevance         integer       DEFAULT 0,
  region            varchar,
  audio             text[]        DEFAULT '{}'::text[],
  subtitles         text[]        DEFAULT '{}'::text[],
  published         boolean       DEFAULT true,
  stale             boolean       DEFAULT false,
  category          app.category,
  provider_id       bigint        REFERENCES app.providers(id),
  created_at        timestamptz   DEFAULT NOW() NOT NULL,
  updated_at        timestamptz   DEFAULT NOW() NOT NULL,
  dataset_sequence  integer,
  resource_sequence integer,
  tags              text[]        DEFAULT '{}'::text[],
  video             jsonb,
  source            app.source    DEFAULT 'api'::app.source,
  pace              app.pace,
  certificate       jsonb         DEFAULT '"{}"'::jsonb,
  pricing_models    jsonb         DEFAULT '"[]"'::jsonb,
  offered_by        jsonb         DEFAULT '"[]"'::jsonb,
  syllabus          text,
  effort            integer,
  enrollments_count integer       DEFAULT 0,
  free_content      boolean       DEFAULT false,
  paid_content      boolean       DEFAULT true,
  level             app.level[]   DEFAULT '{}'::app.level[],
  __provider_name__ varchar,
  __source_schema__ jsonb,
  instructors       jsonb         DEFAULT '[]'::jsonb,
  curated_tags      varchar[]     DEFAULT '{}'::varchar[],
  refinement_tags   varchar[]
);

CREATE TABLE app.tracked_searches (
  id            uuid        DEFAULT public.uuid_generate_v1() PRIMARY KEY,
  version       varchar,
  action        varchar,
  request       jsonb,
  results       jsonb,
  tracked_data  jsonb,
  created_at    timestamptz DEFAULT NOW() NOT NULL,
  updated_at    timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.enrollments (
  id                uuid        DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  user_account_id   bigint      REFERENCES app.user_accounts(id),
  course_id         uuid        REFERENCES app.courses(id),
  tracked_url       varchar,
  description       text,
  user_rating       numeric,
  tracked_search_id uuid        REFERENCES app.tracked_searches(id),
  tracking_data     jsonb       DEFAULT '{}'::jsonb,
  tracking_cookies  jsonb       DEFAULT '{}'::jsonb,
  created_at        timestamptz DEFAULT NOW() NOT NULL,
  updated_at        timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.favorites (
  id              bigserial   PRIMARY KEY,
  user_account_id bigint      REFERENCES app.user_accounts(id),
  course_id       uuid        REFERENCES app.courses(id),
  created_at      timestamptz DEFAULT NOW() NOT NULL,
  updated_at      timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.images (
  id             bigserial   PRIMARY KEY,
  caption        varchar,
  file           varchar,
  pos            integer     DEFAULT 0,
  imageable_type varchar,
  imageable_id   integer,
  created_at     timestamptz DEFAULT NOW() NOT NULL,
  updated_at     timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.landing_pages (
  id            bigserial   PRIMARY KEY,
  slug          public.citext,
  template      varchar,
  meta_html     text,
  html          jsonb       DEFAULT '{}'::jsonb,
  body_html     text,
  created_at    timestamptz DEFAULT NOW() NOT NULL,
  updated_at    timestamptz DEFAULT NOW() NOT NULL,
  data          jsonb       DEFAULT '{}'::jsonb,
  erb_template  text,
  layout        varchar
);

CREATE TABLE app.oauth_accounts (
  id              bigserial   PRIMARY KEY,
  provider        varchar,
  uid             varchar,
  raw_data        jsonb       DEFAULT '{}'::jsonb NOT NULL,
  user_account_id bigint      REFERENCES app.user_accounts(id) ON DELETE CASCADE,
  created_at      timestamptz DEFAULT NOW() NOT NULL,
  updated_at      timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.posts (
  id                  bigserial       PRIMARY KEY,
  slug                varchar,
  title               varchar,
  body                text,
  tags                varchar[]       DEFAULT '{}'::varchar[],
  meta                jsonb           DEFAULT '"{\"title\": \"\", \"description\": \"\"}"'::jsonb,
  locale              app.iso639_code DEFAULT 'en'::app.iso639_code,
  status              app.post_status DEFAULT 'draft'::app.post_status,
  content_fingerprint varchar,
  published_at        timestamptz,
  content_changed_at  timestamptz,
  admin_account_id    bigint          REFERENCES app.admin_accounts(id),
  created_at          timestamptz     DEFAULT NOW() NOT NULL,
  updated_at          timestamptz     DEFAULT NOW() NOT NULL,
  original_post_id    bigint          REFERENCES app.posts(id),
  use_cover_image     boolean         DEFAULT false
);

CREATE TABLE app.profiles (
  id              bigserial PRIMARY KEY,
  name            varchar,
  username        varchar,
  date_of_birth   date,
  avatar          varchar,
  user_account_id bigint    REFERENCES app.user_accounts(id) ON DELETE CASCADE,
  interests       text[]    DEFAULT '{}'::text[],
  preferences     jsonb     DEFAULT '{}'::jsonb
);

CREATE TABLE app.tracked_actions (
  id               uuid                DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  enrollment_id    uuid                REFERENCES app.enrollments(id),
  status           app.payment_status,
  source           app.payment_source,
  created_at       timestamptz         DEFAULT NOW() NOT NULL,
  updated_at       timestamptz         DEFAULT NOW() NOT NULL,
  sale_amount      numeric,
  earnings_amount  numeric,
  payload          jsonb,
  compound_ext_id  varchar,
  ext_click_date   timestamptz,
  ext_id           varchar,
  ext_sku_id       varchar,
  ext_product_name varchar
);

CREATE TABLE app.promo_accounts (
  id              bigserial PRIMARY KEY,
  user_account_id bigint    REFERENCES app.user_accounts(id) ON DELETE CASCADE CONSTRAINT cntr_promo_accounts_user_account_id UNIQUE,
  data            jsonb     DEFAULT '{}'::jsonb,
  created_at      timestamptz  DEFAULT NOW()       NOT NULL,
  updated_at      timestamptz  DEFAULT NOW()       NOT NULL
);

CREATE TABLE IF NOT EXISTS public.ar_internal_metadata (
  key        varchar     PRIMARY KEY,
  value      varchar,
  created_at timestamptz DEFAULT NOW() NOT NULL,
  updated_at timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE IF NOT EXISTS public.schema_migrations (
  version varchar PRIMARY KEY
);

CREATE TABLE settings.secrets (
  key   varchar PRIMARY KEY,
  value varchar
);

CREATE OR REPLACE FUNCTION api.admin_login(
  email    varchar,
  password varchar
) RETURNS text
AS $$
DECLARE
  admin_id bigint;
  result   text;
BEGIN
  SELECT
    id
  FROM app.admin_accounts
  WHERE
    app.admin_accounts.email              = admin_login.email AND
    app.admin_accounts.encrypted_password = public.crypt(admin_login.password, app.admin_accounts.encrypted_password)
  INTO admin_id;

  IF admin_id IS NULL THEN
    RAISE invalid_password USING message = 'invalid email or password';
  END IF;

  SELECT
    jwt.sign(
      row_to_json(r), settings.get('app.jwt_secret')
    ) AS token
  FROM (
    SELECT
      'admin'                                AS role,
      admin_id::varchar                      AS sub,
      extract(EPOCH FROM now())::int + 60*60 AS exp
  ) r
  INTO result;

  RETURN result;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION api.user_login(
  email    varchar,
  password varchar
) RETURNS text
AS $$
DECLARE
  user_id bigint;
  result  text;
BEGIN
  SELECT
    id
  FROM app.user_accounts
  WHERE
    app.user_accounts.email              = user_login.email AND
    app.user_accounts.encrypted_password = public.crypt(user_login.password, app.user_accounts.encrypted_password)
  INTO user_id;

  IF user_id IS NULL THEN
    RAISE invalid_password USING message = 'invalid user or password';
  END IF;

  SELECT
    jwt.sign(
      row_to_json(r), settings.get('app.jwt_secret')
    ) AS token
  FROM (
    SELECT
      'user'                                 AS role,
      user_id::varchar                       AS sub,
      extract(EPOCH FROM now())::int + 60*60 AS exp
  ) r
  INTO result;

  RETURN result;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE FUNCTION app.normalize_languages(languages text[]) RETURNS text[] AS $$
DECLARE
  upcased_languages text[];
BEGIN
  WITH

  subtitles AS (
    SELECT DISTINCT unnest(languages) AS subtitle
  ),

  subtitle_arrays AS (
    SELECT regexp_split_to_array(subtitle, '-') AS subtitle_array
    FROM subtitles
  )

  SELECT DISTINCT
    ARRAY_AGG(
      CASE WHEN array_length(subtitle_array, 1) = 2
      THEN subtitle_array[1] || '-' || upper(subtitle_array[2])
      ELSE subtitle_array[1]
      END
    )
  FROM subtitle_arrays
  INTO upcased_languages;

  RETURN upcased_languages;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_certificate_s3_fetch(
  id         bigint,
  filename   varchar,
  expires_in int
) RETURNS text AS $$
BEGIN
  RETURN app.sign_s3_fetch(
    '$CERTIFICATE_AWS_REGION',
    '$CERTIFICATE_AWS_HOST',
    '$CERTIFICATE_AWS_BUCKET',
    '$CERTIFICATE_AWS_FOLDER',
    id::varchar || '-' || filename,
    '$CERTIFICATE_AWS_ACCESS_KEY_ID',
    '$CERTIFICATE_AWS_SECRET_ACCESS_KEY',
    expires_in,
    '$CERTIFICATE_AWS_IS_HTTPS'::boolean
  );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_certificate_s3_upload(
  id         bigint,
  filename   varchar,
  expires_in int
) RETURNS text AS $$
BEGIN
  RETURN app.sign_s3_upload(
    '$CERTIFICATE_AWS_REGION',
    '$CERTIFICATE_AWS_HOST',
    '$CERTIFICATE_AWS_BUCKET',
    '$CERTIFICATE_AWS_FOLDER',
    id::varchar || '-' || filename,
    '$CERTIFICATE_AWS_ACCESS_KEY_ID',
    '$CERTIFICATE_AWS_SECRET_ACCESS_KEY',
    expires_in,
    '$CERTIFICATE_AWS_IS_PUBLIC'::boolean,
    '$CERTIFICATE_AWS_IS_HTTPS'::boolean
  );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_s3_fetch(
  region            varchar,
  host              varchar,
  bucket            varchar,
  folder            varchar,
  filename          varchar,
  access_key_id     varchar,
  secret_access_key varchar,
  expires_in        int,
  is_https          boolean
) RETURNS text AS $$
DECLARE
  canonical_request_digest text;
  string_to_sign           text;
  content_type             varchar;
  time_string              varchar;
  date_string              varchar;
  key                      bytea;
  query_string             varchar;
  signature                varchar;
  fullpath                 varchar;
  time_now                 timestamptz;
BEGIN
  time_now    = timezone('utc', NOW());
  time_string = to_char(time_now, 'YYYYMMDD"T"HH24MISSZ');
  date_string = to_char(time_now, 'YYYYMMDD');

  query_string = 'X-Amz-Algorithm=AWS4-HMAC-SHA256'
              || '&X-Amz-Credential=' || access_key_id || '%2F' || date_string || '%2F' || region || '%2Fs3%2Faws4_request'
              || '&X-Amz-Date='    || time_string
              || '&X-Amz-Expires=' || expires_in::varchar
              || '&X-Amz-SignedHeaders=host';

  canonical_request_digest = E'GET\n/'
                          || bucket || folder || '/' || filename || E'\n'
                          || query_string
                          || E'\nhost:' || host
                          || E'\n\nhost\n'
                          || 'UNSIGNED-PAYLOAD';

  string_to_sign = E'AWS4-HMAC-SHA256\n'
                || time_string || E'\n'
                || date_string || '/' || region || E'/s3/aws4_request\n'
                || encode(digest(canonical_request_digest, 'sha256'), 'hex');

  key = hmac(date_string,           'AWS4' || secret_access_key, 'sha256');
  key = hmac(region::bytea,         key,                         'sha256');
  key = hmac('s3'::bytea,           key,                         'sha256');
  key = hmac('aws4_request'::bytea, key,                         'sha256');

  signature = encode(hmac(string_to_sign::bytea, key, 'sha256'), 'hex');
  fullpath  = host || '/' || bucket || folder || '/' || filename || '?' || query_string || '&X-Amz-Signature=' || signature;

  IF is_https THEN
    RETURN 'https://' || fullpath;
  ELSE
    RETURN 'http://' || fullpath;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_s3_upload(
  region            varchar,
  host              varchar,
  bucket            varchar,
  folder            varchar,
  filename          varchar,
  access_key_id     varchar,
  secret_access_key varchar,
  expires_in        int,
  is_public         boolean,
  is_https          boolean
) RETURNS text AS $$
DECLARE
  canonical_request_digest text;
  string_to_sign           text;
  acl                      varchar;
  content_type             varchar;
  time_string              varchar;
  date_string              varchar;
  key                      bytea;
  query_string             varchar;
  signature                varchar;
  fullpath                 varchar;
  time_now                 timestamptz;
BEGIN
  time_now    = timezone('utc', NOW());
  time_string = to_char(time_now, 'YYYYMMDD"T"HH24MISSZ');
  date_string = to_char(time_now, 'YYYYMMDD');

  query_string = 'X-Amz-Algorithm=AWS4-HMAC-SHA256'
              || '&X-Amz-Credential=' || access_key_id || '%2F' || date_string || '%2F' || region || '%2Fs3%2Faws4_request'
              || '&X-Amz-Date='    || time_string
              || '&X-Amz-Expires=' || expires_in::varchar
              || '&X-Amz-SignedHeaders=content-type%3Bhost%3Bx-amz-acl';

  CASE
  WHEN lower(filename) ~ '.(jpg|jpeg)$' THEN
    content_type = 'image/jpeg';
  WHEN lower(filename) ~ '.gif$' THEN
    content_type = 'image/gif';
  WHEN lower(filename) ~ '.png$' THEN
    content_type = 'image/png';
  WHEN lower(filename) ~ '.pdf$' THEN
    content_type = 'application/pdf';
  ELSE
    content_type = 'application/octet-stream';
  END CASE;

  IF is_public THEN
    acl = 'public-read';
  ELSE
    acl = 'private';
  END IF;

  canonical_request_digest = E'PUT\n/'
                          || bucket || folder || '/' || filename || E'\n'
                          || query_string
                          || E'\ncontent-type:' || content_type
                          || E'\nhost:' || host
                          || E'\nx-amz-acl:' || acl
                          || E'\n\ncontent-type;host;x-amz-acl\n'
                          || 'UNSIGNED-PAYLOAD';

  string_to_sign = E'AWS4-HMAC-SHA256\n'
                || time_string || E'\n'
                || date_string || '/' || region || E'/s3/aws4_request\n'
                || encode(digest(canonical_request_digest, 'sha256'), 'hex');

  key = hmac(date_string,           'AWS4' || secret_access_key, 'sha256');
  key = hmac(region::bytea,         key,                         'sha256');
  key = hmac('s3'::bytea,           key,                         'sha256');
  key = hmac('aws4_request'::bytea, key,                         'sha256');

  signature = encode(hmac(string_to_sign::bytea, key, 'sha256'), 'hex');
  fullpath  = host || '/' || bucket || folder || '/' || filename || '?' || query_string || '&X-Amz-Signature=' || signature;

  IF is_https THEN
    RETURN 'https://' || fullpath;
  ELSE
    RETURN 'http://' || fullpath;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION jwt.url_encode(data bytea) RETURNS text
AS $$
  SELECT translate(encode(data, 'base64'), E'+/=\n', '-_');
$$ LANGUAGE sql;

CREATE FUNCTION jwt.algorithm_sign(
  signables text,
  secret    text,
  algorithm text
) RETURNS text
AS $$
  WITH
    alg AS ( SELECT
      CASE
      WHEN algorithm = 'HS256' THEN 'sha256'
      WHEN algorithm = 'HS384' THEN 'sha384'
      WHEN algorithm = 'HS512' THEN 'sha512'
      ELSE ''
      END
    )  -- hmac throws error
  SELECT jwt.url_encode(public.hmac(signables, secret, (select * FROM alg)));
$$ LANGUAGE sql;

CREATE FUNCTION jwt.sign(
  payload json,
  secret text,
  algorithm text DEFAULT 'HS256'
) RETURNS text
AS $$
  WITH
    header AS (
      SELECT jwt.url_encode(convert_to('{"alg":"' || algorithm || '","typ":"JWT"}', 'utf8'))
    ),
    payload AS (
      SELECT jwt.url_encode(convert_to(payload::text, 'utf8'))
    ),
    signables AS (
      SELECT (SELECT * FROM header) || '.' || (SELECT * FROM payload)
    )

  SELECT
    (SELECT * FROM signables) ||
    '.' ||
    jwt.algorithm_sign(
      (SELECT * FROM signables),
      secret,
      algorithm
    );
$$ LANGUAGE sql;

CREATE FUNCTION jwt.url_decode(data text) RETURNS bytea
AS $$
WITH
  t   AS ( SELECT translate(data, '-_', '+/') ),
  rem AS ( SELECT length((SELECT * FROM t)) % 4) -- compute padding size
  SELECT decode(
    (SELECT * FROM t) ||
    CASE WHEN (SELECT * FROM rem) > 0
      THEN repeat('=', (4 - (SELECT * FROM rem)))
      ELSE ''
    END,
    'base64'
  );
$$ LANGUAGE sql;

CREATE FUNCTION jwt.verify(
  token     text,
  secret    text,
  algorithm text DEFAULT 'HS256'
) RETURNS table(header json, payload json, valid boolean)
AS $$
  SELECT
    convert_from(jwt.url_decode(r[1]), 'utf8')::json AS header,
    convert_from(jwt.url_decode(r[2]), 'utf8')::json AS payload,
    r[3] = jwt.algorithm_sign(r[1] || '.' || r[2], secret, algorithm) AS valid
  FROM regexp_split_to_array(token, '\.') r;
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION public.if_admin(value anyelement) RETURNS anyelement AS $$
BEGIN
  IF current_user = 'admin' THEN
    RETURN value;
  ELSE
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.if_user_by_id(id bigint, value anyelement) RETURNS anyelement AS $$
BEGIN
  IF current_user = 'user' AND current_setting('request.jwt.claim.sub', true)::bigint = id THEN
    RETURN value;
  ELSE
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION settings.get(varchar)
RETURNS varchar
AS $$
  SELECT value
  FROM settings.secrets
  WHERE key = $1
$$ SECURITY DEFINER STABLE LANGUAGE sql;

CREATE FUNCTION settings.set(varchar, varchar)
RETURNS VOID
AS $$
  INSERT INTO settings.secrets (key, value)
  VALUES ($1, $2)
  ON CONFLICT (key) DO UPDATE
  SET value = $2;
$$ SECURITY DEFINER LANGUAGE sql;

CREATE FUNCTION triggers.course_normalize_languages() RETURNS trigger AS $$
BEGIN
  NEW.audio     = app.normalize_languages(NEW.audio);
  NEW.subtitles = app.normalize_languages(NEW.subtitles);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION triggers.create_profile_for_user_account() RETURNS trigger
AS $$
BEGIN
  INSERT INTO app.profiles (user_account_id) VALUES (NEW.id);
  RETURN NEW;
END
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE FUNCTION triggers.encrypt_password() RETURNS trigger
AS $$
BEGIN
  IF NEW.encrypted_password ~* '^\$\d\w\$\d{2}\$[^$]{53}$' THEN
    RETURN NEW;
  END IF;

  IF tg_op = 'INSERT' OR NEW.encrypted_password <> OLD.encrypted_password THEN
    NEW.encrypted_password = crypt(NEW.encrypted_password, gen_salt('bf', 11));
  END IF;

  RETURN NEW;
end
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.gen_compound_ext_id() RETURNS trigger AS $$
BEGIN
  NEW.compound_ext_id = concat(NEW.source,'_',NEW.ext_id);
  return NEW;
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.insert_or_add_to_provider() RETURNS trigger AS $$
DECLARE
  _provider        app.providers%ROWTYPE;
  _new_provider_id int;
BEGIN
  SELECT * FROM app.providers INTO _provider where providers.name = NEW.__provider_name__;
  IF (NOT FOUND) THEN
    INSERT INTO app.providers (name, published, created_at, updated_at) VALUES (NEW.__provider_name__, false, NOW(), NOW()) RETURNING id INTO _new_provider_id;
    NEW.published = false;
    NEW.provider_id = _new_provider_id;
  ELSE
    NEW.provider_id = _provider.id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.md5_url() RETURNS trigger AS $$
BEGIN
  NEW.url_md5=md5(NEW.url);
  return NEW;
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.sort_prices() RETURNS trigger AS $$
DECLARE
  price                 jsonb;
  prices                jsonb[];
  results               jsonb[];
  single_course_prices  jsonb[];
  subscription_prices   jsonb[];
BEGIN
  FOR price IN SELECT * FROM jsonb_array_elements((NEW.__source_schema__ -> 'content' ->> 'prices')::jsonb)
  LOOP
    IF (price ->> 'type' = 'single_course') THEN
      single_course_prices := array_append(single_course_prices,price);
    ELSIF (price ->> 'type' = 'subscription') THEN
      IF (price -> 'subscription_period' ->> 'unit' = 'months') THEN
        subscription_prices := array_prepend(price,subscription_prices);
      ELSIF (price -> 'subscription_period' ->> 'unit' = 'years') THEN
        subscription_prices := array_append(subscription_prices,price);
      END IF;
    END IF;
  END LOOP;
  results := (single_course_prices || subscription_prices);
  IF array_length(results,1) > 0 THEN
    NEW.pricing_models = to_jsonb(results);
  END IF;
  NEW.__source_schema__ = NULL;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.track_updated_at() RETURNS trigger
AS $$
BEGIN
  IF NEW.updated_at IS NULL THEN
    NEW.updated_at := OLD.updated_at;
  ELSE
    IF NEW.updated_at = OLD.updated_at THEN
      NEW.updated_at := NOW();
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER encrypt_password
  BEFORE INSERT OR UPDATE
  ON app.admin_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.encrypt_password();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.admin_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.admin_profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.certificates
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.contacts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER set_global_id
  BEFORE INSERT
  ON app.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.md5_url();

CREATE TRIGGER course_normalize_languages
  BEFORE INSERT OR UPDATE
  ON app.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.course_normalize_languages();

CREATE TRIGGER sort_prices
  BEFORE INSERT OR UPDATE
  ON app.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.sort_prices();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.enrollments
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.favorites
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.images
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.landing_pages
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.oauth_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.posts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.providers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER set_compound_ext_id
  BEFORE INSERT
  ON app.tracked_actions
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.gen_compound_ext_id();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.tracked_actions
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.tracked_searches
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER encrypt_password
  BEFORE INSERT OR UPDATE
  ON app.user_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.encrypt_password();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.user_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER create_profile_for_user_account
  AFTER INSERT
  ON app.user_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.create_profile_for_user_account();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.promo_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON public.ar_internal_metadata
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE UNIQUE INDEX index_admin_accounts_on_confirmation_token
ON app.admin_accounts
USING btree (confirmation_token);

CREATE UNIQUE INDEX index_admin_accounts_on_email
ON app.admin_accounts
USING btree (email);

CREATE UNIQUE INDEX index_admin_accounts_on_reset_password_token
ON app.admin_accounts
USING btree (reset_password_token);

CREATE UNIQUE INDEX index_admin_accounts_on_unlock_token
ON app.admin_accounts
USING btree (unlock_token);

CREATE INDEX index_admin_profiles_on_admin_account_id
ON app.admin_profiles
USING btree (admin_account_id);

CREATE INDEX index_courses_on_curated_tags
ON app.courses
USING gin (curated_tags);

CREATE INDEX index_courses_on_dataset_sequence
ON app.courses
USING btree (dataset_sequence);

CREATE INDEX index_courses_on_global_sequence
ON app.courses
USING btree (global_sequence);

CREATE INDEX index_courses_on_provider_id
ON app.courses
USING btree (provider_id);

CREATE UNIQUE INDEX index_courses_on_slug
ON app.courses
USING btree (slug);

CREATE INDEX index_courses_on_tags
ON app.courses
USING gin (tags);

CREATE UNIQUE INDEX index_courses_on_url_md5
ON app.courses
USING btree (url_md5);

CREATE INDEX index_enrollments_on_course_id
ON app.enrollments
USING btree (course_id);

CREATE INDEX index_enrollments_on_tracked_search_id
ON app.enrollments
USING btree (tracked_search_id);

CREATE INDEX index_enrollments_on_tracking_data
ON app.enrollments
USING gin (tracking_data);

CREATE INDEX index_enrollments_on_user_account_id
ON app.enrollments
USING btree (user_account_id);

CREATE INDEX index_favorites_on_course_id
ON app.favorites
USING btree (course_id);

CREATE INDEX index_favorites_on_user_account_id
ON app.favorites
USING btree (user_account_id);

CREATE INDEX index_images_on_imageable_type_and_imageable_id
ON app.images
USING btree (imageable_type, imageable_id);

CREATE UNIQUE INDEX index_landing_pages_on_slug
ON app.landing_pages
USING btree (slug);

CREATE INDEX index_oauth_accounts_on_user_account_id
ON app.oauth_accounts
USING btree (user_account_id);

CREATE INDEX index_posts_on_admin_account_id
ON app.posts
USING btree (admin_account_id);

CREATE INDEX index_posts_on_original_post_id
ON app.posts
USING btree (original_post_id);

CREATE UNIQUE INDEX index_posts_on_slug
ON app.posts
USING btree (slug);

CREATE INDEX index_posts_on_tags
ON app.posts
USING gin (tags);

CREATE INDEX index_profiles_on_user_account_id
ON app.profiles
USING btree (user_account_id);

CREATE UNIQUE INDEX index_providers_on_name
ON app.providers
USING btree (name);

CREATE UNIQUE INDEX index_providers_on_slug
ON app.providers
USING btree (slug);

CREATE UNIQUE INDEX index_tracked_actions_on_compound_ext_id
ON app.tracked_actions
USING btree (compound_ext_id);

CREATE INDEX index_tracked_actions_on_enrollment_id
ON app.tracked_actions
USING btree (enrollment_id);

CREATE INDEX index_tracked_actions_on_payload
ON app.tracked_actions
USING gin (payload);

CREATE INDEX index_tracked_actions_on_status
ON app.tracked_actions
USING btree (status);

CREATE INDEX index_tracked_searches_on_action
ON app.tracked_searches
USING btree (action);

CREATE UNIQUE INDEX index_user_accounts_on_confirmation_token
ON app.user_accounts
USING btree (confirmation_token);

CREATE UNIQUE INDEX index_user_accounts_on_email
ON app.user_accounts
USING btree (email);

CREATE UNIQUE INDEX index_user_accounts_on_reset_password_token
ON app.user_accounts
USING btree (reset_password_token);

CREATE UNIQUE INDEX index_user_accounts_on_unlock_token
ON app.user_accounts
USING btree (unlock_token);

CREATE UNIQUE INDEX index_profiles_on_username
ON app.profiles
USING btree (username);

CREATE UNIQUE INDEX index_promo_accounts_on_user_account_id
ON app.promo_accounts
USING btree (user_account_id);

CREATE OR REPLACE VIEW api.admin_accounts AS
  SELECT
    id,
    email,
    NULL::varchar AS password,
    reset_password_token,
    reset_password_sent_at,
    remember_created_at,
    sign_in_count,
    current_sign_in_at,
    last_sign_in_at,
    current_sign_in_ip,
    last_sign_in_ip,
    confirmation_token,
    confirmed_at,
    confirmation_sent_at,
    unconfirmed_email,
    failed_attempts,
    unlock_token,
    locked_at,
    created_at,
    updated_at,
    preferences
  FROM app.admin_accounts;

CREATE OR REPLACE FUNCTION triggers.api_admin_accounts_view_instead() RETURNS trigger AS $$
BEGIN
  IF (TG_OP = 'UPDATE') THEN
    UPDATE app.admin_accounts
    SET
      email              = NEW.email,
      encrypted_password = crypt(NEW.password, gen_salt('bf', 11))
    WHERE
      id = OLD.id;
  ELSIF (TG_OP = 'INSERT') THEN
    INSERT INTO app.admin_accounts (
      email,
      encrypted_password
    ) VALUES (
      NEW.email,
      crypt(NEW.password, gen_salt('bf', 11))
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_admin_accounts_view_instead
  INSTEAD OF INSERT OR UPDATE
  ON api.admin_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_admin_accounts_view_instead();

CREATE OR REPLACE VIEW api.certificates AS
  SELECT
    id,
    user_account_id,
    file,
    created_at,
    updated_at,
    app.sign_certificate_s3_fetch(id, file, 3600) AS fetch_url,
    app.sign_certificate_s3_upload(id, file, 3600) AS upload_url
  FROM app.certificates
  WHERE
    current_user = 'admin' OR (
      current_user = 'user' AND
      current_setting('request.jwt.claim.sub', true)::bigint = user_account_id
    );

CREATE OR REPLACE FUNCTION triggers.api_certificates_view_instead() RETURNS trigger AS $$
DECLARE
  certificate record;
BEGIN
  IF (TG_OP = 'INSERT') THEN
    IF if_admin(TRUE) OR if_user_by_id(NEW.user_account_id, TRUE) THEN
      INSERT INTO app.certificates (
        user_account_id,
        file
      ) VALUES (
        NEW.user_account_id,
        NEW.file
      ) RETURNING * INTO certificate;
    ELSE
      RAISE EXCEPTION 'Unauthorized Request';
    END IF;
  ELSIF (TG_OP = 'UPDATE') THEN
    IF if_admin(TRUE) OR ( if_user_by_id(OLD.user_account_id, TRUE) AND if_user_by_id(NEW.user_account_id, TRUE) ) THEN
      UPDATE app.certificates
      SET
        user_account_id = NEW.user_account_id,
        file            = NEW.file
      WHERE
        id = OLD.id
      RETURNING * INTO certificate;
    ELSE
      RAISE EXCEPTION 'Unauthorized Request';
    END IF;
  END IF;

  NEW.id         = certificate.id;
  NEW.created_at = certificate.created_at;
  NEW.updated_at = certificate.updated_at;
  NEW.fetch_url  = app.sign_certificate_s3_fetch(NEW.id, NEW.file, 3600);
  NEW.upload_url = app.sign_certificate_s3_upload(NEW.id, NEW.file, 3600);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_certificates_view_instead
  INSTEAD OF INSERT OR UPDATE
  ON api.certificates
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_certificates_view_instead();

CREATE VIEW api.earnings AS
  SELECT
    tracked_actions.id,
    tracked_actions.sale_amount,
    tracked_actions.earnings_amount,
    tracked_actions.ext_click_date,
    tracked_actions.ext_sku_id,
    tracked_actions.ext_product_name,
    tracked_actions.ext_id,
    tracked_actions.source                             AS affiliate_network,
    providers.name                                     AS provider_name,
    courses.name                                       AS course_name,
    courses.url                                        AS course_url,
    (enrollments.tracking_data->>'country')::text      AS country,
    (enrollments.tracking_data->>'query_string')::text AS qs,
    (enrollments.tracking_data->>'referer')::text      AS referer,
    (enrollments.tracking_data->>'utm_source')::text   AS utm_source,
    (enrollments.tracking_data->>'utm_campaign')::text AS utm_campaign,
    (enrollments.tracking_data->>'utm_medium')::text   AS utm_medium,
    (enrollments.tracking_data->>'utm_term')::text     AS utm_term,
    tracked_actions.created_at
  FROM app.tracked_actions
    LEFT JOIN app.enrollments ON enrollments.id = tracked_actions.enrollment_id
    LEFT JOIN app.courses     ON courses.id     = enrollments.course_id
    LEFT JOIN app.providers   ON providers.id   = courses.provider_id;

CREATE OR REPLACE VIEW api.profiles AS
  SELECT
    id,
    name,
    username,
    avatar,
    COALESCE( if_admin(date_of_birth),   if_user_by_id(user_account_id, date_of_birth)   ) AS date_of_birth,
    COALESCE( if_admin(user_account_id), if_user_by_id(user_account_id, user_account_id) ) AS user_account_id,
    COALESCE( if_admin(interests),       if_user_by_id(user_account_id, interests)       ) AS interests,
    COALESCE( if_admin(preferences),     if_user_by_id(user_account_id, preferences)     ) AS preferences
  FROM app.profiles;

CREATE OR REPLACE FUNCTION triggers.api_profiles_view_instead() RETURNS trigger AS $$
BEGIN
  IF NEW.user_account_id != OLD.user_account_id THEN
    RAISE invalid_authorization_specification USING message = 'could not change user_account_id';
  END IF;

  IF if_admin(TRUE) IS NULL AND if_user_by_id(NEW.user_account_id, TRUE) IS NULL THEN
    RAISE EXCEPTION 'Unauthorized Access';
  END IF;

  UPDATE app.profiles
  SET
    name          = NEW.name,
    date_of_birth = NEW.date_of_birth,
    avatar        = NEW.avatar,
    interests     = NEW.interests,
    preferences   = NEW.preferences,
    username      = NEW.username
  WHERE
    id = OLD.id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_profiles_view_instead
  INSTEAD OF UPDATE
  ON api.profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_profiles_view_instead();

CREATE OR REPLACE VIEW api.user_accounts AS
  SELECT
    id,
    email,
    NULL::varchar                                                                           AS password,
    COALESCE( if_admin(reset_password_token),   if_user_by_id(id, reset_password_token)   ) AS reset_password_token,
    COALESCE( if_admin(reset_password_sent_at), if_user_by_id(id, reset_password_sent_at) ) AS reset_password_sent_at,
    COALESCE( if_admin(remember_created_at),    if_user_by_id(id, remember_created_at)    ) AS remember_created_at,
    COALESCE( if_admin(sign_in_count),          if_user_by_id(id, sign_in_count)          ) AS sign_in_count,
    COALESCE( if_admin(current_sign_in_at),     if_user_by_id(id, current_sign_in_at)     ) AS current_sign_in_at,
    COALESCE( if_admin(last_sign_in_at),        if_user_by_id(id, last_sign_in_at)        ) AS last_sign_in_at,
    COALESCE( if_admin(current_sign_in_ip),     if_user_by_id(id, current_sign_in_ip)     ) AS current_sign_in_ip,
    COALESCE( if_admin(last_sign_in_ip),        if_user_by_id(id, last_sign_in_ip)        ) AS last_sign_in_ip,
    COALESCE( if_admin(tracking_data),          if_user_by_id(id, tracking_data)          ) AS tracking_data,
    COALESCE( if_admin(confirmation_token),     if_user_by_id(id, confirmation_token)     ) AS confirmation_token,
    COALESCE( if_admin(confirmed_at),           if_user_by_id(id, confirmed_at)           ) AS confirmed_at,
    COALESCE( if_admin(confirmation_sent_at),   if_user_by_id(id, confirmation_sent_at)   ) AS confirmation_sent_at,
    COALESCE( if_admin(unconfirmed_email),      if_user_by_id(id, unconfirmed_email)      ) AS unconfirmed_email,
    COALESCE( if_admin(failed_attempts),        if_user_by_id(id, failed_attempts)        ) AS failed_attempts,
    COALESCE( if_admin(unlock_token),           if_user_by_id(id, unlock_token)           ) AS unlock_token,
    COALESCE( if_admin(locked_at),              if_user_by_id(id, locked_at)              ) AS locked_at,
    COALESCE( if_admin(destroyed_at),           if_user_by_id(id, destroyed_at)           ) AS destroyed_at,
    created_at,
    updated_at
  FROM app.user_accounts;

CREATE OR REPLACE FUNCTION triggers.api_user_accounts_view_instead() RETURNS trigger AS $$
BEGIN
  IF if_admin(TRUE) IS NULL AND if_user_by_id(NEW.id, TRUE) IS NULL THEN
    RAISE EXCEPTION 'Unauthorized Access';
  END IF;

  UPDATE app.user_accounts
  SET
    email              = NEW.email,
    encrypted_password = crypt(NEW.password, gen_salt('bf', 11))
  WHERE
    id = OLD.id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_user_accounts_view_instead
  INSTEAD OF UPDATE
  ON api.user_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_user_accounts_view_instead();

CREATE OR REPLACE VIEW api.promo_accounts AS
  SELECT
    id,
    COALESCE( if_admin(user_account_id), if_user_by_id(id, user_account_id) ) AS user_account_id,
    COALESCE( if_admin(data),            if_user_by_id(id, data)            ) AS data,
    created_at,
    updated_at
  FROM app.promo_accounts;

CREATE OR REPLACE FUNCTION triggers.api_promo_accounts_view_instead() RETURNS trigger AS $$
DECLARE
  row app.promo_accounts%ROWTYPE;
BEGIN
  row := NEW;

  IF if_admin(TRUE) IS NULL AND if_user_by_id(NEW.user_account_id, TRUE) IS NULL THEN
    RAISE EXCEPTION 'Unauthorized Access';
  END IF;

  INSERT INTO  app.promo_accounts (user_account_id, data)
  VALUES (NEW.user_account_id, NEW.data)
  ON CONFLICT ON CONSTRAINT cntr_promo_accounts_user_account_id DO
    UPDATE SET data = EXCLUDED.data
    RETURNING id, user_account_id, data, created_at, updated_at INTO row;

  RETURN row;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_promo_accounts_view_instead
  INSTEAD OF INSERT
  ON api.promo_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_promo_accounts_view_create_instead();

CREATE ROLE "anonymous";

GRANT USAGE ON SCHEMA api      TO "anonymous";
GRANT USAGE ON SCHEMA jwt      TO "anonymous";
GRANT USAGE ON SCHEMA settings TO "anonymous";

CREATE ROLE "user";

GRANT USAGE ON SCHEMA api      TO "user";
GRANT USAGE ON SCHEMA app      TO "user";
GRANT USAGE ON SCHEMA jwt      TO "user";
GRANT USAGE ON SCHEMA settings TO "user";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "user";

GRANT SELECT, INSERT, UPDATE, DELETE             ON app.certificates   TO "user";
GRANT SELECT, UPDATE                             ON app.profiles       TO "user";
GRANT SELECT, INSERT, UPDATE,         REFERENCES ON app.promo_accounts TO "user";
GRANT SELECT, UPDATE,                 REFERENCES ON app.user_accounts  TO "user";

GRANT SELECT, INSERT, UPDATE, DELETE ON api.certificates   TO "user";
GRANT SELECT,         UPDATE         ON api.profiles       TO "user";
GRANT SELECT,         UPDATE         ON api.user_accounts  TO "user";
GRANT SELECT, INSERT, UPDATE         ON api.promo_accounts TO "user";

CREATE ROLE "admin";

GRANT USAGE ON SCHEMA api      TO "admin";
GRANT USAGE ON SCHEMA app      TO "admin";
GRANT USAGE ON SCHEMA jwt      TO "admin";
GRANT USAGE ON SCHEMA settings TO "admin";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "admin";

GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.admin_accounts   TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.admin_profiles   TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE             ON app.certificates     TO "admin";
GRANT SELECT, INSERT, UPDATE,         REFERENCES ON app.courses          TO "admin";
GRANT SELECT, INSERT,         DELETE, REFERENCES ON app.enrollments      TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.favorites        TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.images           TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.landing_pages    TO "admin";
GRANT SELECT,         UPDATE, DELETE, REFERENCES ON app.oauth_accounts   TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.posts            TO "admin";
GRANT SELECT, INSERT, UPDATE,         REFERENCES ON app.profiles         TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.providers        TO "admin";
GRANT SELECT                                     ON app.tracked_actions  TO "admin";
GRANT SELECT                                     ON app.tracked_searches TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.user_accounts    TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.promo_accounts   TO "admin";

GRANT SELECT ON api.earnings       TO "admin";

GRANT SELECT, INSERT, UPDATE, DELETE ON api.admin_accounts TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.certificates   TO "admin";
GRANT SELECT,         UPDATE         ON api.profiles       TO "admin";
GRANT SELECT,         UPDATE, DELETE ON api.user_accounts  TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.promo_accounts TO "admin";

CREATE ROLE "authenticator" NOINHERIT login password '$AUTHENTICATOR_PASSWORD';

GRANT "user"      TO "authenticator";
GRANT "admin"     TO "authenticator";
GRANT "anonymous" TO "authenticator";

GRANT USAGE ON SCHEMA api      TO "authenticator";
GRANT USAGE ON SCHEMA jwt      TO "authenticator";
GRANT USAGE ON SCHEMA settings TO "authenticator";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "authenticator";

GRANT SELECT ON app.user_accounts, app.admin_accounts TO "authenticator";

-- Gem lit migrations

INSERT INTO public.schema_migrations(version) VALUES
  ('20180101010101'),
  ('20180101010102'),
  ('20180101010103'),
  ('20180101010104'),
  ('20180101010105'),
  ('20180101010106'),
  ('20180101010107'),
  ('20180101010108'),
  ('20180101010109'),
  ('20181017123839'),
  ('20181018075955'),
  ('20181030111522'),
  ('20181129103819');

INSERT INTO settings.secrets (key, value) VALUES ('app.jwt_secret', '$JWT_SECRET');

COMMIT;

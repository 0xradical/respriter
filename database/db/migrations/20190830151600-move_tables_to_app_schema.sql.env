BEGIN;

GRANT USAGE ON SCHEMA app TO "user";

REVOKE ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA api FROM "user";
REVOKE ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA api FROM "admin";
REVOKE ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA api FROM "authenticator";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "user";
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "admin";
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "authenticator";

ALTER TABLE api.admin_accounts   SET SCHEMA "app";
ALTER TABLE api.admin_profiles   SET SCHEMA "app";
ALTER TABLE api.contacts         SET SCHEMA "app";
ALTER TABLE api.courses          SET SCHEMA "app";
ALTER TABLE api.enrollments      SET SCHEMA "app";
ALTER TABLE api.favorites        SET SCHEMA "app";
ALTER TABLE api.images           SET SCHEMA "app";
ALTER TABLE api.landing_pages    SET SCHEMA "app";
ALTER TABLE api.oauth_accounts   SET SCHEMA "app";
ALTER TABLE api.posts            SET SCHEMA "app";
ALTER TABLE api.profiles         SET SCHEMA "app";
ALTER TABLE api.providers        SET SCHEMA "app";
ALTER TABLE api.tracked_actions  SET SCHEMA "app";
ALTER TABLE api.tracked_searches SET SCHEMA "app";
ALTER TABLE api.user_accounts    SET SCHEMA "app";

CREATE OR REPLACE FUNCTION api.admin_login(
  email    varchar,
  password varchar
) RETURNS text
AS $$
DECLARE
  admin_id bigint;
  result   text;
BEGIN
  SELECT
    id
  FROM app.admin_accounts
  WHERE
    app.admin_accounts.email              = admin_login.email AND
    app.admin_accounts.encrypted_password = public.crypt(admin_login.password, app.admin_accounts.encrypted_password)
  INTO admin_id;

  IF admin_id IS NULL THEN
    RAISE invalid_password USING message = 'invalid email or password';
  END IF;

  SELECT
    jwt.sign(
      row_to_json(r), settings.get('app.jwt_secret')
    ) AS token
  FROM (
    SELECT
      'admin'                                AS role,
      admin_id::varchar                      AS sub,
      extract(EPOCH FROM now())::int + 60*60 AS exp
  ) r
  INTO result;

  RETURN result;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION api.user_login(
  email    varchar,
  password varchar
) RETURNS text
AS $$
DECLARE
  user_id bigint;
  result  text;
BEGIN
  SELECT
    id
  FROM app.user_accounts
  WHERE
    app.user_accounts.email              = user_login.email AND
    app.user_accounts.encrypted_password = public.crypt(user_login.password, app.user_accounts.encrypted_password)
  INTO user_id;

  IF user_id IS NULL THEN
    RAISE invalid_password USING message = 'invalid user or password';
  END IF;

  SELECT
    jwt.sign(
      row_to_json(r), settings.get('app.jwt_secret')
    ) AS token
  FROM (
    SELECT
      'user'                                 AS role,
      user_id::varchar                       AS sub,
      extract(EPOCH FROM now())::int + 60*60 AS exp
  ) r
  INTO result;

  RETURN result;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION triggers.create_profile_for_user_account() RETURNS trigger
AS $$
BEGIN
  INSERT INTO app.profiles (user_account_id) VALUES (NEW.id);
  RETURN NEW;
END
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION triggers.insert_or_add_to_provider() RETURNS trigger AS $$
DECLARE
  _provider        app.providers%ROWTYPE;
  _new_provider_id int;
BEGIN
  SELECT * FROM app.providers INTO _provider where providers.name = NEW.__provider_name__;
  IF (NOT FOUND) THEN
    INSERT INTO app.providers (name, published, created_at, updated_at) VALUES (NEW.__provider_name__, false, NOW(), NOW()) RETURNING id INTO _new_provider_id;
    NEW.published = false;
    NEW.provider_id = _new_provider_id;
  ELSE
    NEW.provider_id = _provider.id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE VIEW api.earnings AS
  SELECT
    tracked_actions.id,
    tracked_actions.sale_amount,
    tracked_actions.earnings_amount,
    tracked_actions.ext_click_date,
    tracked_actions.ext_sku_id,
    tracked_actions.ext_product_name,
    tracked_actions.ext_id,
    tracked_actions.source                             AS affiliate_network,
    providers.name                                     AS provider_name,
    courses.name                                       AS course_name,
    courses.url                                        AS course_url,
    (enrollments.tracking_data->>'country')::text      AS country,
    (enrollments.tracking_data->>'query_string')::text AS qs,
    (enrollments.tracking_data->>'referer')::text      AS referer,
    (enrollments.tracking_data->>'utm_source')::text   AS utm_source,
    (enrollments.tracking_data->>'utm_campaign')::text AS utm_campaign,
    (enrollments.tracking_data->>'utm_medium')::text   AS utm_medium,
    (enrollments.tracking_data->>'utm_term')::text     AS utm_term,
    tracked_actions.created_at
  FROM app.tracked_actions
    LEFT JOIN app.enrollments ON enrollments.id = tracked_actions.enrollment_id
    LEFT JOIN app.courses     ON courses.id     = enrollments.course_id
    LEFT JOIN app.providers   ON providers.id   = courses.provider_id;


COMMIT;

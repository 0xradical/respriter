BEGIN;

CREATE TABLE app.promo_account_certificates (
  id               bigserial PRIMARY KEY,
  promo_account_id bigint REFERENCES app.promo_accounts(id) ON DELETE CASCADE CONSTRAINT cntr_promo_account_certificates_promo_account_id UNIQUE,
  certificate_id   bigint REFERENCES app.certificates(id) ON DELETE CASCADE,
  state            varchar DEFAULT 'initial',
  created_at       timestamptz  DEFAULT NOW() NOT NULL,
  updated_at       timestamptz  DEFAULT NOW() NOT NULL
);

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.promo_account_certificates
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE UNIQUE INDEX index_promo_account_certificates_on_promo_account
ON app.promo_account_certificates
USING btree (promo_account_id);

CREATE OR REPLACE VIEW api.promo_account_certificates AS
  SELECT
    app.promo_account_certificates.id,
    COALESCE( if_admin(promo_account_id), if_user_by_id(app.promo_accounts.user_account_id, promo_account_id) ) AS promo_account_id,
    COALESCE( if_admin(certificate_id),   if_user_by_id(app.promo_accounts.user_account_id, certificate_id)   ) AS certificate_id,
    COALESCE( if_admin(state),            if_user_by_id(app.promo_accounts.user_account_id, state)            ) AS state,
    COALESCE( if_admin(file),             if_user_by_id(app.promo_accounts.user_account_id, file)             ) AS file,
    app.promo_account_certificates.created_at,
    app.promo_account_certificates.updated_at
  FROM app.promo_account_certificates
  INNER JOIN app.promo_accounts ON app.promo_accounts.id = promo_account_certificates.promo_account_id
  INNER JOIN app.certificates ON app.promo_account_certificates.certificate_id = app.certificates.id
  LIMIT 1;

CREATE OR REPLACE FUNCTION triggers.api_promo_accounts_view_instead() RETURNS trigger AS $$
DECLARE
  promo_account app.promo_accounts%ROWTYPE;
  promo_account_certificate app.promo_account_certificates%ROWTYPE;
  promo_account_certificate_id bigint;
  promo_account_certificate_user_id bigint;
BEGIN
  promo_account := NEW;

  SELECT current_setting('request.header.certificateid', true)::bigint INTO promo_account_certificate_id;

  IF promo_account_certificate_id IS NULL THEN
    RAISE EXCEPTION 'Null certificate';
  END IF;

  SELECT app.certificates.user_account_id FROM app.certificates WHERE id = promo_account_certificate_id INTO promo_account_certificate_user_id;

  IF if_admin(TRUE) IS NULL AND if_user_by_id(promo_account_certificate_user_id, TRUE) IS NULL THEN
    RAISE EXCEPTION 'Unauthorized Access';
  END IF;

  IF if_admin(TRUE) IS NULL AND if_user_by_id(NEW.user_account_id, TRUE) IS NULL THEN
    RAISE EXCEPTION 'Unauthorized Access';
  END IF;

  INSERT INTO  app.promo_accounts (user_account_id, price, purchase_date, order_id, paypal_account)
  VALUES (NEW.user_account_id, NEW.price, NEW.purchase_date, NEW.order_id, NEW.paypal_account)
  ON CONFLICT ON CONSTRAINT cntr_promo_accounts_user_account_id DO
    UPDATE SET price = EXCLUDED.price,
              purchase_date = EXCLUDED.purchase_date,
              order_id = EXCLUDED.order_id,
              paypal_account = EXCLUDED.paypal_account
    RETURNING id, user_account_id, price, purchase_date, order_id, paypal_account, created_at, updated_at INTO promo_account;

  INSERT INTO app.promo_account_certificates (promo_account_id, certificate_id, state)
  VALUES (promo_account.id, promo_account_certificate_id, 'pending')
  ON CONFLICT ON CONSTRAINT cntr_promo_account_certificates_promo_account_id DO
    UPDATE SET certificate_id = EXCLUDED.certificate_id
    RETURNING id, promo_account_id, certificate_id, state INTO promo_account_certificate;

  IF promo_account_certificate.state IN ('locked', 'pending') THEN
    RAISE EXCEPTION 'Cannot update on locked promo';
  END IF;

  RETURN promo_account;
END;
$$ LANGUAGE plpgsql;

GRANT SELECT, INSERT, UPDATE, REFERENCES ON app.promo_account_certificates TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.promo_account_certificates TO "admin";
GRANT SELECT ON api.promo_account_certificates TO "admin";
GRANT SELECT ON api.promo_account_certificates TO "user";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "user";

INSERT INTO public.schema_migrations (version) VALUES ('20190923161600');

COMMIT;

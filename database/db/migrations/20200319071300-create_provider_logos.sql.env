BEGIN;

CREATE OR REPLACE FUNCTION app.sign_direct_s3_upload(
  id         uuid,
  filename   varchar,
  folder     varchar,
  expires_in int
) RETURNS text AS $$
BEGIN
  RETURN app.sign_s3_upload(
    '$DIRECT_UPLOAD_AWS_REGION',
    '$DIRECT_UPLOAD_AWS_HOST',
    '$DIRECT_UPLOAD_AWS_BUCKET',
    '$DIRECT_UPLOAD_AWS_ROOT_FOLDER' || '/' || folder,
    id::varchar || '-' || filename,
    '$DIRECT_UPLOAD_AWS_ACCESS_KEY_ID',
    '$DIRECT_UPLOAD_AWS_SECRET_ACCESS_KEY',
    expires_in,
    '$DIRECT_UPLOAD_AWS_IS_PUBLIC'::boolean,
    '$DIRECT_UPLOAD_AWS_IS_HTTPS'::boolean
  );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_direct_s3_fetch(
  id         uuid,
  filename   varchar,
  folder     varchar,
  expires_in int
) RETURNS text AS $$
BEGIN
  RETURN app.sign_s3_fetch(
    '$DIRECT_UPLOAD_AWS_REGION',
    '$DIRECT_UPLOAD_AWS_HOST',
    '$DIRECT_UPLOAD_AWS_BUCKET',
    '$DIRECT_UPLOAD_AWS_ROOT_FOLDER' || '/' || folder,
    id::varchar || '-' || filename,
    '$DIRECT_UPLOAD_AWS_ACCESS_KEY_ID',
    '$DIRECT_UPLOAD_AWS_SECRET_ACCESS_KEY',
    expires_in,
    '$DIRECT_UPLOAD_AWS_IS_HTTPS'::boolean
  );
END;
$$ LANGUAGE plpgsql;

CREATE TABLE app.direct_uploads (
  id              uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  user_account_id bigint      REFERENCES app.user_accounts(id),
  file            varchar     CONSTRAINT valid_file_format CHECK ( LOWER(file) ~ '.(gif|jpg|jpeg|png|pdf|svg)$' ),
  created_at      timestamptz DEFAULT NOW() NOT NULL,
  updated_at      timestamptz DEFAULT NOW() NOT NULL
);

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.direct_uploads
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TABLE app.provider_logos (
  id               uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  direct_upload_id uuid REFERENCES app.direct_uploads(id) NOT NULL,
  provider_id      bigint REFERENCES app.providers(id) NOT NULL
);

CREATE UNIQUE INDEX index_provider_logos_on_direct_upload_id
ON app.provider_logos
USING btree (direct_upload_id);

CREATE UNIQUE INDEX index_provider_logos_on_provider_id
ON app.provider_logos
USING btree (provider_id);

CREATE TYPE app.provider_logo AS (
  id uuid,
  provider_id bigint,
  file varchar,
  user_account_id bigint,
  created_at timestamptz,
  updated_at timestamptz,
  fetch_url text,
  upload_url text,
  file_content_type varchar
);

CREATE OR REPLACE VIEW api.provider_logos AS
  SELECT
    app.provider_logos.id as id,
    app.provider_logos.provider_id as provider_id,
    app.direct_uploads.file as file,
    app.direct_uploads.user_account_id as user_account_id,
    app.direct_uploads.created_at as created_at,
    app.direct_uploads.updated_at as updated_at,
    app.sign_direct_s3_fetch(app.direct_uploads.id, app.direct_uploads.file, 'provider_logos/' || app.provider_logos.provider_id::varchar, 3600)  AS fetch_url,
    app.sign_direct_s3_upload(app.direct_uploads.id, app.direct_uploads.file, 'provider_logos/' || app.provider_logos.provider_id::varchar, 3600) AS upload_url,
    app.content_type_by_extension(app.direct_uploads.file)                              AS file_content_type
  FROM app.provider_logos
  INNER JOIN app.direct_uploads ON app.direct_uploads.id = app.provider_logos.direct_upload_id
  WHERE
    current_user = 'admin' OR (
      current_user = 'user' AND
      current_setting('request.jwt.claim.sub', true)::bigint = app.direct_uploads.user_account_id
    );

CREATE OR REPLACE FUNCTION triggers.api_provider_logos_view_instead() RETURNS trigger AS $$
DECLARE
  current_user_id bigint;
  direct_upload app.direct_uploads;
  provider_logo app.provider_logo;
  filename varchar;
  file_content_type varchar;
  fetch_url text;
  upload_url text;
BEGIN
  current_user_id   := current_setting('request.jwt.claim.sub', true)::bigint;
  filename          := NEW.file;

  IF (TG_OP = 'INSERT') THEN
    INSERT INTO app.direct_uploads (
      id,
      user_account_id,
      file
    ) VALUES (
      NEW.id,
      current_user_id,
      filename
    ) ON CONFLICT (id) DO
      UPDATE set file = filename
      RETURNING * INTO direct_upload;
  ELSIF (TG_OP = 'UPDATE') THEN
    UPDATE app.direct_uploads
    SET
      user_account_id   = current_user_id,
      file              = filename
    WHERE
      id = OLD.id
    RETURNING * INTO direct_upload;
  END IF;

  file_content_type := app.content_type_by_extension(filename);
  fetch_url         := app.sign_direct_s3_fetch(direct_upload.id, filename, 'provider_logos/' || NEW.provider_id::varchar, 3600);
  upload_url        := app.sign_direct_s3_upload(direct_upload.id, filename, 'provider_logos/' || NEW.provider_id::varchar, 3600);

  INSERT INTO app.provider_logos (
    direct_upload_id,
    provider_id
  ) VALUES (
    direct_upload.id,
    NEW.provider_id
  ) ON CONFLICT (provider_id) DO
    UPDATE set direct_upload_id = direct_upload.id;

  SELECT app.provider_logos.id INTO provider_logo FROM app.provider_logos WHERE app.provider_logos.provider_id = NEW.provider_id;
  provider_logo.provider_id := NEW.provider_id;
  provider_logo.file := filename;
  provider_logo.user_account_id := current_user_id;
  provider_logo.created_at := direct_upload.created_at;
  provider_logo.updated_at := direct_upload.updated_at;
  provider_logo.fetch_url := fetch_url;
  provider_logo.upload_url := upload_url;
  provider_logo.file_content_type := file_content_type;

  RETURN provider_logo;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_provider_logos_view_instead
  INSTEAD OF INSERT OR UPDATE
  ON api.provider_logos
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_provider_logos_view_instead();

CREATE OR REPLACE FUNCTION app.content_type_by_extension(
  filename varchar
) RETURNS varchar AS $$
BEGIN
  CASE
  WHEN lower(filename) ~ '.(jpg|jpeg)$' THEN
    RETURN 'image/jpeg';
  WHEN lower(filename) ~ '.gif$' THEN
    RETURN 'image/gif';
  WHEN lower(filename) ~ '.png$' THEN
    RETURN 'image/png';
  WHEN lower(filename) ~ '.svg$' THEN
    RETURN 'image/svg+xml';
  WHEN lower(filename) ~ '.pdf$' THEN
    RETURN 'application/pdf';
  ELSE
    RETURN 'application/octet-stream';
  END CASE;
END;
$$ LANGUAGE plpgsql;

GRANT SELECT, INSERT, UPDATE, DELETE ON app.provider_logos TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.provider_logos TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON app.direct_uploads TO "admin";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "admin";

GRANT SELECT, INSERT, UPDATE, DELETE ON app.provider_logos TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.provider_logos TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE ON app.direct_uploads TO "user";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "user";

INSERT INTO public.schema_migrations (version) VALUES ('20200319071300');

COMMIT;
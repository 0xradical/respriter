BEGIN;

CREATE OR REPLACE FUNCTION OP_sanitize_string(text) RETURNS text as $$
DECLARE
  sanitized text;
BEGIN
  sanitized := $1;

  -- zero width space
  sanitized := REGEXP_REPLACE(sanitized,'\u200B','');
  -- leading / trailing space
  sanitized := TRIM(sanitized);
  -- typoed https
  sanitized := REGEXP_REPLACE(sanitized, '^//[Hh][Tt]{1,2}[pP][Ss]?:/','');
  -- typoed www.
  sanitized := REGEXP_REPLACE(sanitized, '^//www,','//www.');
  -- typoed //youtube,com
  sanitized := REGEXP_REPLACE(sanitized, '^//youtube,com','//youtube.com');
  -- instagram with @
  sanitized := REGEXP_REPLACE(sanitized, '(instagram|medium)\.com/@','instagram.com/');
  -- youtube with extra protocol
  sanitized := REGEXP_REPLACE(sanitized, '^//youtube.com/https?:/{0,2}','//');
  -- trailing encoded space
  sanitized := REGEXP_REPLACE(sanitized, '%20$','');
  -- insufficient leading slash
  sanitized := REGEXP_REPLACE(sanitized, '^/(?!/)','//');

  RETURN sanitized;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION OP_encode_uri(text) RETURNS text as $$
  SELECT string_agg(
    CASE
    WHEN bytes > 1 OR c !~ '[0-9a-zA-Z_.!~*''();,/?:@&=+$#-]+' THEN
      regexp_replace(encode(convert_to(c, 'utf-8')::bytea, 'hex'), '(..)', E'%\\1', 'g')
    ELSE
      c
    END,
    ''
  )
  FROM (
    SELECT c, octet_length(c) bytes
    FROM regexp_split_to_table($1, '') c
  ) q;
$$ LANGUAGE SQL IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION OP_parse_uri(text) RETURNS jsonb as $$
DECLARE
  matches text[];
BEGIN
  matches := REGEXP_MATCHES($1, '^(\w+):(\/\/([A-z\d\-._~]+)(:\d+)?)?(\/(?:[A-z\d\-._~]|%[a-fA-F0-9])*(?:\/(?:[A-z\d\-._~]|%[a-fA-F0-9])*)*|(?:\/(?:[A-z\d\-._~]|%[a-fA-F0-9]|[!$&''()*+,;=:@])+)*)?(\?(?:[A-z\d\-._~]|%[a-fA-F0-9]|[!$&''()*+,;=:@]|[\/\?])*)?(\#(?:[A-z\d\-._~]|%[a-fA-F0-9]|[!$&''()*+,;=:@]|[\/\?])*)?$');

  IF matches IS NOT NULL THEN
    RETURN json_object('{scheme,authority,host,port,path,query,fragment}'::text[], matches)::jsonb;
  ELSE
    RETURN '{}'::jsonb;
  END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION OP_platform_jsonb(jsonb, text, jsonb) RETURNS jsonb as $$
BEGIN
  IF $3->>'host' IS NOT NULL THEN
    RETURN jsonb_set($1, ('{' || $2 || '}')::text[], to_jsonb(CONCAT('//', ($3->>'host')::text, ($3->>'path')::text, ($3->>'query')::text)));
  ELSE
    RETURN $1;
  END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

-- sanitize public_profiles
DO
$$
DECLARE
  r RECORD;
  j JSONB; -- parsed url from public_profiles as json
  k JSONB; -- transformation of public_profiles
  l JSONB; -- normalization of public_profiles (OP_encode_uri)
  _platform VARCHAR;
  _url VARCHAR;
  _original_url VARCHAR;
BEGIN
  FOR r IN SELECT id, public_profiles FROM app.orphaned_profiles WHERE public_profiles <> '{}'
  LOOP
    k := '{}'::jsonb;

    FOR _platform, _original_url, _url IN
      SELECT key, value, OP_sanitize_string(value) FROM jsonb_each_text(r.public_profiles)
    LOOP
      -- don't encode unnecessarily
      IF _url !~ '%' THEN
        SELECT OP_encode_uri(_url) INTO _url;
      END IF;

      SELECT OP_parse_uri(_url) INTO j;

      IF j = '{}'::jsonb THEN
        SELECT OP_parse_uri('https:' || _url) INTO j;
      END IF;

      IF j = '{}'::jsonb THEN
        SELECT OP_parse_uri('https://' || _url) INTO j;
      END IF;

      IF j = '{}'::jsonb THEN
        NULL;
      ELSE
        SELECT OP_platform_jsonb(k, _platform, j) INTO k;
      END IF;
    END LOOP;

    IF k <> r.public_profiles AND k <> '{}'::jsonb THEN
      UPDATE app.orphaned_profiles SET public_profiles = k WHERE id = r.id;
    END IF;
  END LOOP;
END;
$$;

-- claimable_public_profiles -> public_profiles
DO
$$
DECLARE
  r RECORD;
  k JSONB; -- transformation of public_profiles
  _platform VARCHAR;
  _config jsonb;
BEGIN
  FOR r IN SELECT id, public_profiles, claimable_public_profiles FROM app.orphaned_profiles WHERE claimable_public_profiles <> '{}'
  LOOP
    k := r.public_profiles;

    FOR _platform, _config IN
      SELECT key, value FROM jsonb_each_text(r.claimable_public_profiles)
    LOOP
      -- profile_url cannot be blank
      -- profile_url cannot be decoded
      -- profile_url cannot be equal to what's already in
      -- profile_url must start with //
      IF _config->>'profile_url' IS NOT NULL AND
        _config->>'profile_url' <> '' AND
        TRIM('"' FROM jsonb_extract_path(r.public_profiles, _platform)::text) <> OP_encode_uri(_config->>'profile_url') AND
        OP_encode_uri(_config->>'profile_url') ~ '^//' THEN
          k := jsonb_set(k, ('{' || _platform || '}')::text[], to_jsonb(_config->>'profile_url'));
      END IF;
    END LOOP;

    IF k <> r.public_profiles AND k <> '{}'::jsonb THEN
      UPDATE app.orphaned_profiles SET public_profiles = k WHERE id = r.id;
    END IF;
  END LOOP;
END;
$$;

DROP FUNCTION OP_sanitize_string;
DROP FUNCTION OP_encode_uri;
DROP FUNCTION OP_parse_uri;
DROP FUNCTION OP_platform_jsonb;

INSERT INTO public.schema_migrations (version) VALUES ('20200526201913');

COMMIT;

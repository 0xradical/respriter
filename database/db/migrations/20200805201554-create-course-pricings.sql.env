BEGIN;

CREATE TYPE app.iso4217_code AS ENUM (
  'AED','AFN','ALL','AMD','ANG','AOA','ARS','AUD','AWG','AZN','BAM','BBD','BDT','BGN','BHD','BIF','BMD','BND','BOB','BOV','BRL','BSD','BTN','BWP','BYN','BZD','CAD','CDF','CHE','CHF','CHW','CLF','CLP','CNY','COP','COU','CRC','CUC','CUP','CVE','CZK','DJF','DKK','DOP','DZD','EGP','ERN','ETB','EUR','FJD','FKP','GBP','GEL','GHS','GIP','GMD','GNF','GTQ','GYD','HKD','HNL','HRK','HTG','HUF','IDR','ILS','INR','IQD','IRR','ISK','JMD','JOD','JPY','KES','KGS','KHR','KMF','KPW','KRW','KWD','KYD','KZT','LAK','LBP','LKR','LRD','LSL','LYD','MAD','MDL','MGA','MKD','MMK','MNT','MOP','MRU','MUR','MVR','MWK','MXN','MXV','MYR','MZN','NAD','NGN','NIO','NOK','NPR','NZD','OMR','PAB','PEN','PGK','PHP','PKR','PLN','PYG','QAR','RON','RSD','RUB','RWF','SAR','SBD','SCR','SDG','SEK','SGD','SHP','SLL','SOS','SRD','SSP','STN','SVC','SYP','SZL','THB','TJS','TMT','TND','TOP','TRY','TTD','TWD','TZS','UAH','UGX','USD','USN','UYI','UYU','UYW','UZS','VES','VND','VUV','WST','XAF','XAG','XAU','XBA','XBB','XBC','XBD','XCD','XDR','XOF','XPD','XPF','XPT','XSU','XTS','XUA','XXX','YER','ZAR','ZMW','ZWL'
);

CREATE TYPE app.period_unit AS ENUM (
  'minutes', 'hours', 'days', 'weeks', 'months', 'years', 'lessons'
);

CREATE TYPE app.pricing AS ENUM (
  'single_course', 'subscription'
);

CREATE TYPE app.pricing_customer AS ENUM (
  'individual', 'enterprise'
);

CREATE TYPE app.pricing_plan AS ENUM (
  'regular', 'premium'
);

CREATE TABLE app.course_pricings (
  id                         uuid        DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  course_id                  uuid        REFERENCES app.courses(id),
  pricing_type               app.pricing NOT NULL,
  plan_type                  app.pricing_plan NOT NULL,
  customer_type              app.pricing_customer,
  price                      decimal(8,2) NOT NULL,
  total_price                decimal(8,2),
  original_price             decimal(8,2),
  discount                   decimal(8,2),
  currency                   app.iso4217_code NOT NULL,
  payment_period_unit        app.period_unit,
  payment_period_value       integer,
  trial_period_unit          app.period_unit,
  trial_period_value         integer,
  subscription_period_unit   app.period_unit,
  subscription_period_value  integer,
  created_at                 timestamptz DEFAULT NOW() NOT NULL,
  updated_at                 timestamptz DEFAULT NOW() NOT NULL,
  CONSTRAINT                 course_pricing_uniqueness unique(
                              course_id,
                              pricing_type,
                              plan_type,
                              customer_type,
                              currency,
                              payment_period_unit,
                              subscription_period_unit,
                              trial_period_unit
                            )
);

CREATE TABLE app.preview_course_pricings (
  id                         uuid        DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  preview_course_id          uuid        REFERENCES app.preview_courses(id),
  pricing_type               app.pricing NOT NULL,
  plan_type                  app.pricing_plan NOT NULL,
  customer_type              app.pricing_customer,
  price                      decimal(8,2) NOT NULL,
  total_price                decimal(8,2),
  original_price             decimal(8,2),
  discount                   decimal(8,2),
  currency                   app.iso4217_code NOT NULL,
  payment_period_unit        app.period_unit,
  payment_period_value       integer,
  trial_period_unit          app.period_unit,
  trial_period_value         integer,
  subscription_period_unit   app.period_unit,
  subscription_period_value  integer,
  created_at                 timestamptz DEFAULT NOW() NOT NULL,
  updated_at                 timestamptz DEFAULT NOW() NOT NULL,
  CONSTRAINT                 preview_course_pricing_uniqueness unique(
                              preview_course_id,
                              pricing_type,
                              plan_type,
                              customer_type,
                              currency,
                              payment_period_unit,
                              subscription_period_unit,
                              trial_period_unit
                            )
);

CREATE FUNCTION app.insert_into_course_pricings(course_id uuid, pricing jsonb)
RETURNS void AS $$
BEGIN
  INSERT INTO app.course_pricings (
          course_id,
          pricing_type,
          plan_type,
          customer_type,
          price,
          total_price,
          discount,
          currency,
          payment_period_unit,
          payment_period_value,
          trial_period_unit,
          trial_period_value,
          subscription_period_unit,
          subscription_period_value
        ) VALUES (
          course_id,
          (pricing->>'type')::app.pricing,
          (pricing->>'plan_type')::app.pricing_plan,
          (pricing->>'customer_type')::app.pricing_customer,
          (pricing->>'price')::numeric(8,2),
          (pricing->>'total_price')::numeric(8,2),
          (pricing->>'discount')::numeric(8,2),
          (pricing->>'currency')::app.iso4217_code,
          (pricing->'payment_period'->>'unit')::app.period_unit,
          (pricing->'payment_period'->>'value')::integer,
          (pricing->'trial_period'->>'unit')::app.period_unit,
          (pricing->'trial_period'->>'value')::integer,
          (pricing->'subscription_period'->>'unit')::app.period_unit,
          (pricing->'subscription_period'->>'value')::integer
        ) ON CONFLICT ON CONSTRAINT course_pricing_uniqueness
          DO UPDATE SET pricing_type = (pricing->>'type')::app.pricing,
                        plan_type = (pricing->>'plan_type')::app.pricing_plan,
                        customer_type = (pricing->>'customer_type')::app.pricing_customer,
                        price = (pricing->>'price')::numeric(8,2),
                        total_price = (pricing->>'total_price')::numeric(8,2),
                        discount = (pricing->>'discount')::numeric(8,2),
                        currency = (pricing->>'currency')::app.iso4217_code,
                        payment_period_unit = (pricing->'payment_period'->>'unit')::app.period_unit,
                        payment_period_value = (pricing->'payment_period'->>'value')::integer,
                        trial_period_unit = (pricing->'trial_period'->>'unit')::app.period_unit,
                        trial_period_value = (pricing->'trial_period'->>'value')::integer,
                        subscription_period_unit = (pricing->'subscription_period'->>'unit')::app.period_unit,
                        subscription_period_value = (pricing->'subscription_period'->>'value')::integer;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION app.insert_into_preview_course_pricings(preview_course_id uuid, pricing jsonb)
RETURNS void AS $$
BEGIN
  INSERT INTO app.preview_course_pricings (
          preview_course_id,
          pricing_type,
          plan_type,
          customer_type,
          price,
          total_price,
          discount,
          currency,
          payment_period_unit,
          payment_period_value,
          trial_period_unit,
          trial_period_value,
          subscription_period_unit,
          subscription_period_value
        ) VALUES (
          preview_course_id,
          (pricing->>'type')::app.pricing,
          (pricing->>'plan_type')::app.pricing_plan,
          (pricing->>'customer_type')::app.pricing_customer,
          (pricing->>'price')::numeric(8,2),
          (pricing->>'total_price')::numeric(8,2),
          (pricing->>'discount')::numeric(8,2),
          (pricing->>'currency')::app.iso4217_code,
          (pricing->'payment_period'->>'unit')::app.period_unit,
          (pricing->'payment_period'->>'value')::integer,
          (pricing->'trial_period'->>'unit')::app.period_unit,
          (pricing->'trial_period'->>'value')::integer,
          (pricing->'subscription_period'->>'unit')::app.period_unit,
          (pricing->'subscription_period'->>'value')::integer
        ) ON CONFLICT ON CONSTRAINT preview_course_pricing_uniqueness
          DO UPDATE SET pricing_type = (pricing->>'type')::app.pricing,
                        plan_type = (pricing->>'plan_type')::app.pricing_plan,
                        customer_type = (pricing->>'customer_type')::app.pricing_customer,
                        price = (pricing->>'price')::numeric(8,2),
                        total_price = (pricing->>'total_price')::numeric(8,2),
                        discount = (pricing->>'discount')::numeric(8,2),
                        currency = (pricing->>'currency')::app.iso4217_code,
                        payment_period_unit = (pricing->'payment_period'->>'unit')::app.period_unit,
                        payment_period_value = (pricing->'payment_period'->>'value')::integer,
                        trial_period_unit = (pricing->'trial_period'->>'unit')::app.period_unit,
                        trial_period_value = (pricing->'trial_period'->>'value')::integer,
                        subscription_period_unit = (pricing->'subscription_period'->>'unit')::app.period_unit,
                        subscription_period_value = (pricing->'subscription_period'->>'value')::integer;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.course_flatten_pricing_models() RETURNS trigger AS $$
DECLARE
  price jsonb;
BEGIN
  IF (NEW.__source_schema__::jsonb)->'content'->>'prices' IS NOT NULL THEN
    FOR price IN SELECT * FROM jsonb_array_elements((NEW.__source_schema__->'content'->>'prices')::jsonb)
    LOOP
      SELECT app.insert_into_course_pricings(NEW.id, price);
    END LOOP;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.preview_course_flatten_pricing_models() RETURNS trigger AS $$
DECLARE
  price jsonb;
BEGIN
  IF (NEW.__source_schema__::jsonb)->'content'->>'prices' IS NOT NULL THEN
    FOR price IN SELECT * FROM jsonb_array_elements((NEW.__source_schema__->'content'->>'prices')::jsonb)
    LOOP
      SELECT app.insert_into_preview_course_pricings(NEW.id, price);
    END LOOP;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER course_flatten_pricing_models
  BEFORE INSERT OR UPDATE
   ON app.courses
   FOR EACH ROW
      EXECUTE PROCEDURE triggers.course_flatten_pricing_models();

CREATE TRIGGER preview_course_flatten_pricing_models
  BEFORE INSERT OR UPDATE
  ON app.preview_courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.preview_course_flatten_pricing_models();

DROP TRIGGER sort_prices ON app.courses;
DROP TRIGGER sort_prices ON app.preview_courses;
DROP FUNCTION triggers.sort_prices;

CREATE FUNCTION triggers.sort_prices() RETURNS trigger AS $$
DECLARE
  price                 jsonb;
  prices                jsonb[];
  results               jsonb[];
  single_course_prices  jsonb[];
  subscription_prices   jsonb[];
BEGIN
  FOR price IN SELECT * FROM jsonb_array_elements((NEW.__source_schema__ -> 'content' ->> 'prices')::jsonb)
  LOOP
    IF (price ->> 'type' = 'single_course') THEN
      single_course_prices := array_append(single_course_prices,price);
    ELSIF (price ->> 'type' = 'subscription') THEN
      IF (price -> 'subscription_period' ->> 'unit' = 'months') THEN
        subscription_prices := array_prepend(price,subscription_prices);
      ELSIF (price -> 'subscription_period' ->> 'unit' = 'years') THEN
        subscription_prices := array_append(subscription_prices,price);
      END IF;
    END IF;
  END LOOP;
  results := (single_course_prices || subscription_prices);
  IF array_length(results,1) > 0 THEN
    NEW.pricing_models = to_jsonb(results);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sort_prices
  BEFORE INSERT OR UPDATE
  ON app.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.sort_prices();

CREATE TRIGGER sort_prices
  BEFORE INSERT OR UPDATE
  ON app.preview_courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.sort_prices();

CREATE INDEX index_course_pricings_on_course_id
ON app.course_pricings
USING btree (course_id);

CREATE INDEX index_preview_course_pricings_on_preview_course_id
ON app.preview_course_pricings
USING btree (preview_course_id);

INSERT INTO public.schema_migrations (version) VALUES ('20200805201554');

COMMIT;

BEGIN;

CREATE OR REPLACE FUNCTION app.sign_s3_upload(
  region            varchar,
  host              varchar,
  bucket            varchar,
  folder            varchar,
  filename          varchar,
  access_key_id     varchar,
  secret_access_key varchar,
  expires_in        int,
  is_public         boolean,
  is_https          boolean
) RETURNS text AS $$
DECLARE
  canonical_request_digest text;
  string_to_sign           text;
  acl                      varchar;
  content_type             varchar;
  time_string              varchar;
  date_string              varchar;
  key                      bytea;
  query_string             varchar;
  signature                varchar;
  fullpath                 varchar;
  time_now                 timestamptz;
BEGIN
  time_now    = timezone('utc', NOW());
  time_string = to_char(time_now, 'YYYYMMDD"T"HH24MISSZ');
  date_string = to_char(time_now, 'YYYYMMDD');

  query_string = 'X-Amz-Algorithm=AWS4-HMAC-SHA256'
              || '&X-Amz-Credential=' || access_key_id || '%2F' || date_string || '%2F' || region || '%2Fs3%2Faws4_request'
              || '&X-Amz-Date='    || time_string
              || '&X-Amz-Expires=' || expires_in::varchar
              || '&X-Amz-SignedHeaders=content-type%3Bhost%3Bx-amz-acl';

  content_type = app.content_type_by_extension(filename);

  IF is_public THEN
    acl = 'public-read';
  ELSE
    acl = 'private';
  END IF;

  canonical_request_digest = E'PUT\n/'
                          || bucket || folder || '/' || filename || E'\n'
                          || query_string
                          || E'\ncontent-type:' || content_type
                          || E'\nhost:' || host
                          || E'\nx-amz-acl:' || acl
                          || E'\n\ncontent-type;host;x-amz-acl\n'
                          || 'UNSIGNED-PAYLOAD';

  string_to_sign = E'AWS4-HMAC-SHA256\n'
                || time_string || E'\n'
                || date_string || '/' || region || E'/s3/aws4_request\n'
                || encode(digest(canonical_request_digest, 'sha256'), 'hex');

  key = hmac(date_string,           'AWS4' || secret_access_key, 'sha256');
  key = hmac(region::bytea,         key,                         'sha256');
  key = hmac('s3'::bytea,           key,                         'sha256');
  key = hmac('aws4_request'::bytea, key,                         'sha256');

  signature = encode(hmac(string_to_sign::bytea, key, 'sha256'), 'hex');
  fullpath  = host || '/' || bucket || folder || '/' || filename || '?' || query_string || '&X-Amz-Signature=' || signature;

  IF is_https THEN
    RETURN 'https://' || fullpath;
  ELSE
    RETURN 'http://' || fullpath;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_s3_fetch(
  region            varchar,
  host              varchar,
  bucket            varchar,
  folder            varchar,
  filename          varchar,
  access_key_id     varchar,
  secret_access_key varchar,
  expires_in        int,
  is_https          boolean
) RETURNS text AS $$
DECLARE
  canonical_request_digest text;
  string_to_sign           text;
  content_type             varchar;
  time_string              varchar;
  date_string              varchar;
  key                      bytea;
  query_string             varchar;
  signature                varchar;
  fullpath                 varchar;
  time_now                 timestamptz;
BEGIN
  time_now    = timezone('utc', NOW());
  time_string = to_char(time_now, 'YYYYMMDD"T"HH24MISSZ');
  date_string = to_char(time_now, 'YYYYMMDD');

  query_string = 'X-Amz-Algorithm=AWS4-HMAC-SHA256'
              || '&X-Amz-Credential=' || access_key_id || '%2F' || date_string || '%2F' || region || '%2Fs3%2Faws4_request'
              || '&X-Amz-Date='    || time_string
              || '&X-Amz-Expires=' || expires_in::varchar
              || '&X-Amz-SignedHeaders=host';

  canonical_request_digest = E'GET\n/'
                          || bucket || folder || '/' || filename || E'\n'
                          || query_string
                          || E'\nhost:' || host
                          || E'\n\nhost\n'
                          || 'UNSIGNED-PAYLOAD';

  string_to_sign = E'AWS4-HMAC-SHA256\n'
                || time_string || E'\n'
                || date_string || '/' || region || E'/s3/aws4_request\n'
                || encode(digest(canonical_request_digest, 'sha256'), 'hex');

  key = hmac(date_string,           'AWS4' || secret_access_key, 'sha256');
  key = hmac(region::bytea,         key,                         'sha256');
  key = hmac('s3'::bytea,           key,                         'sha256');
  key = hmac('aws4_request'::bytea, key,                         'sha256');

  signature = encode(hmac(string_to_sign::bytea, key, 'sha256'), 'hex');
  fullpath  = host || '/' || bucket || folder || '/' || filename || '?' || query_string || '&X-Amz-Signature=' || signature;

  IF is_https THEN
    RETURN 'https://' || fullpath;
  ELSE
    RETURN 'http://' || fullpath;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_certificate_s3_upload(
  id         bigint,
  filename   varchar,
  expires_in int
) RETURNS text AS $$
BEGIN
  RETURN app.sign_s3_upload(
    '$CERTIFICATE_AWS_REGION',
    '$CERTIFICATE_AWS_HOST',
    '$CERTIFICATE_AWS_BUCKET',
    '$CERTIFICATE_AWS_FOLDER',
    id::varchar || '-' || filename,
    '$CERTIFICATE_AWS_ACCESS_KEY_ID',
    '$CERTIFICATE_AWS_SECRET_ACCESS_KEY',
    expires_in,
    '$CERTIFICATE_AWS_IS_PUBLIC'::boolean,
    '$CERTIFICATE_AWS_IS_HTTPS'::boolean
  );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_certificate_s3_fetch(
  id         bigint,
  filename   varchar,
  expires_in int
) RETURNS text AS $$
BEGIN
  RETURN app.sign_s3_fetch(
    '$CERTIFICATE_AWS_REGION',
    '$CERTIFICATE_AWS_HOST',
    '$CERTIFICATE_AWS_BUCKET',
    '$CERTIFICATE_AWS_FOLDER',
    id::varchar || '-' || filename,
    '$CERTIFICATE_AWS_ACCESS_KEY_ID',
    '$CERTIFICATE_AWS_SECRET_ACCESS_KEY',
    expires_in,
    '$CERTIFICATE_AWS_IS_HTTPS'::boolean
  );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.content_type_by_extension(
  filename varchar
) RETURNS varchar AS $$
BEGIN
  CASE
  WHEN lower(filename) ~ '.(jpg|jpeg)$' THEN
    RETURN 'image/jpeg';
  WHEN lower(filename) ~ '.gif$' THEN
    RETURN 'image/gif';
  WHEN lower(filename) ~ '.png$' THEN
    RETURN 'image/png';
  WHEN lower(filename) ~ '.pdf$' THEN
    RETURN 'application/pdf';
  ELSE
    RETURN 'application/octet-stream';
  END CASE;
END;
$$ LANGUAGE plpgsql;

CREATE TABLE app.certificates (
  id              bigserial   PRIMARY KEY,
  user_account_id bigint      REFERENCES app.user_accounts(id),
  file            varchar     CONSTRAINT valid_file_format CHECK ( lower(file) ~ '.(gif|jpg|jpeg|png|pdf)$' ),
  created_at      timestamptz DEFAULT NOW() NOT NULL,
  updated_at      timestamptz DEFAULT NOW() NOT NULL
);

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.certificates
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE OR REPLACE VIEW api.certificates AS
  SELECT
    id,
    user_account_id,
    file,
    created_at,
    updated_at,
    app.sign_certificate_s3_fetch(id, file, 3600)  AS fetch_url,
    app.sign_certificate_s3_upload(id, file, 3600) AS upload_url,
    app.content_type_by_extension(file)            AS file_content_type
  FROM app.certificates
  WHERE
    current_user = 'admin' OR (
      current_user = 'user' AND
      current_setting('request.jwt.claim.sub', true)::bigint = user_account_id
    );

CREATE OR REPLACE FUNCTION triggers.api_certificates_view_instead() RETURNS trigger AS $$
DECLARE
  certificate record;
BEGIN
  IF (TG_OP = 'INSERT') THEN
    IF if_admin(TRUE) OR if_user_by_id(NEW.user_account_id, TRUE) THEN
      INSERT INTO app.certificates (
        user_account_id,
        file
      ) VALUES (
        NEW.user_account_id,
        NEW.file
      ) RETURNING * INTO certificate;
    ELSE
      RAISE EXCEPTION 'Unauthorized Request';
    END IF;
  ELSIF (TG_OP = 'UPDATE') THEN
    IF if_admin(TRUE) OR ( if_user_by_id(OLD.user_account_id, TRUE) AND if_user_by_id(NEW.user_account_id, TRUE) ) THEN
      UPDATE app.certificates
      SET
        user_account_id = NEW.user_account_id,
        file            = NEW.file
      WHERE
        id = OLD.id
      RETURNING * INTO certificate;
    ELSE
      RAISE EXCEPTION 'Unauthorized Request';
    END IF;
  END IF;

  NEW.id                = certificate.id;
  NEW.created_at        = certificate.created_at;
  NEW.updated_at        = certificate.updated_at;
  NEW.fetch_url         = app.sign_certificate_s3_fetch(NEW.id, NEW.file, 3600);
  NEW.upload_url        = app.sign_certificate_s3_upload(NEW.id, NEW.file, 3600);
  NEW.file_content_type = app.content_type_by_extension(NEW.file);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_certificates_view_instead
  INSTEAD OF INSERT OR UPDATE
  ON api.certificates
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_certificates_view_instead();


GRANT SELECT, INSERT, UPDATE, DELETE ON app.certificates TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.certificates TO "admin";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "admin";

GRANT SELECT, INSERT, UPDATE, DELETE ON app.certificates TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.certificates TO "user";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "user";

INSERT INTO public.schema_migrations (version) VALUES ('20190919170100');

COMMIT;

BEGIN;

CREATE OR REPLACE FUNCTION log_message(error_message text) RETURNS void AS $$
BEGIN
   RAISE NOTICE '%', error_message;
END;
$$ LANGUAGE plpgsql;

---- drop PK constraint on app.providers(id) ----

SELECT log_message('dropping PK constraint on app.providers(id)');
ALTER TABLE app.providers DROP CONSTRAINT providers_pkey CASCADE;
-- DETAIL:
-- drop cascades to constraint courses_provider_id_fkey on table app.courses
-- drop cascades to constraint provider_crawlers_provider_id_fkey on table app.provider_crawlers
-- drop cascades to constraint preview_courses_provider_id_fkey on table app.preview_courses
-- drop cascades to constraint provider_logos_provider_id_fkey on table app.provider_logos

---- drop views before changing types ----
SELECT log_message('dropping views before changing types');

SELECT log_message('dropping views dependent on app.providers');
-- dependent on app.providers
DROP MATERIALIZED VIEW IF EXISTS bi.sales;
DROP MATERIALIZED VIEW IF EXISTS bi.exit_clicks;
DROP VIEW api.providers;
DROP VIEW api.earnings;

SELECT log_message('dropping views dependent on app.courses');
-- dependent on app.courses
DROP VIEW subsets.courses CASCADE;
-- DETAIL:
-- drop cascades to view subsets.enrollments
-- drop cascades to view subsets.tracked_actions
DROP MATERIALIZED VIEW subsets.course_summaries CASCADE;
-- DETAIL:
-- drop cascades to view subsets.course_filters

-- dependent on app.provider_crawlers
SELECT log_message('dropping views dependent on app.provider_crawlers');
DROP VIEW api.provider_crawlers;

-- dependent on app.preview_courses
SELECT log_message('dropping views dependent on app.preview_courses');
DROP VIEW api.preview_courses CASCADE;
-- DETAIL:
-- drop cascades to view api.preview_course_images

-- dependent on app.provider_logos
SELECT log_message('dropping views dependent on app.provider_logos');
DROP VIEW api.provider_logos;

---- change app.providers(id) type ----
SELECT log_message('changing app.providers(id) type');
ALTER TABLE app.providers ALTER COLUMN id DROP NOT NULL;
ALTER TABLE app.providers ALTER COLUMN id SET DEFAULT NULL;
ALTER TABLE app.providers ADD COLUMN old_id BIGINT;
UPDATE app.providers SET old_id = id;
UPDATE app.providers SET id = NULL;
ALTER TABLE app.providers ALTER COLUMN id SET DATA TYPE UUID USING (public.uuid_generate_v4());
ALTER TABLE app.providers ALTER COLUMN id SET DEFAULT uuid_generate_v4();
ALTER TABLE app.providers ADD PRIMARY KEY (id);

CREATE INDEX index_providers_on_old_id
ON app.providers
USING btree (old_id)
WHERE old_id IS NOT NULL;

---- change secondary types ----
SELECT log_message('changing app.provider type');
ALTER TYPE app.provider_logo ALTER ATTRIBUTE provider_id SET DATA TYPE uuid;

---- change constraints on dependent relations ----
SELECT log_message('changing constraints on dependent relations');

-- courses_provider_id_fkey on table app.courses
SELECT log_message('removing courses_provider_id_fkey constraint on table app.courses');
ALTER TABLE app.courses ADD COLUMN old_provider_id BIGINT;
UPDATE app.courses SET old_provider_id = provider_id, provider_id = NULL;
ALTER TABLE app.courses ALTER COLUMN provider_id SET DATA TYPE uuid USING (public.uuid_generate_v4());
SELECT log_message('populating courses.provider_id with new provider_id values');
WITH t AS (
   SELECT app.providers.id AS id, app.providers.old_id AS old_id
   FROM app.providers
)
UPDATE app.courses
SET provider_id = t.id
FROM t
WHERE app.courses.old_provider_id = t.old_id;
UPDATE app.courses SET provider_id = NULL WHERE provider_id NOT IN (SELECT app.providers.id AS id FROM app.providers);
SELECT log_message('adding courses_provider_id_fkey constraint on table app.courses');
ALTER TABLE app.courses ADD FOREIGN KEY (provider_id) REFERENCES app.providers(id);
ALTER TABLE app.courses DROP COLUMN old_provider_id;

-- provider_crawlers_provider_id_fkey on table app.provider_crawlers
SELECT log_message('removing provider_crawlers_provider_id_fkey constraint on table app.provider_crawlers');
ALTER TABLE app.provider_crawlers ADD COLUMN old_provider_id BIGINT;
UPDATE app.provider_crawlers SET old_provider_id = provider_id;
UPDATE app.provider_crawlers SET provider_id = NULL;
ALTER TABLE app.provider_crawlers ALTER COLUMN provider_id SET DATA TYPE uuid USING (public.uuid_generate_v4());
UPDATE app.provider_crawlers SET provider_id = NULL;
SELECT log_message('populating provider_crawlers.provider_id with new provider_id values');
WITH t AS (
   SELECT app.providers.id AS id, app.providers.old_id AS old_id
   FROM app.providers
)
UPDATE app.provider_crawlers
SET provider_id = t.id
FROM t
WHERE app.provider_crawlers.old_provider_id = t.old_id;
SELECT log_message('adding provider_crawlers_provider_id_fkey constraint on table app.provider_crawlers');
ALTER TABLE app.provider_crawlers ADD FOREIGN KEY (provider_id) REFERENCES app.providers(id) ON DELETE CASCADE;
ALTER TABLE app.provider_crawlers DROP COLUMN old_provider_id;

-- preview_courses_provider_id_fkey on table app.preview_courses
SELECT log_message('removing preview_courses_provider_id_fkey constraint on table app.preview_courses');
ALTER TABLE app.preview_courses ADD COLUMN old_provider_id BIGINT;
UPDATE app.preview_courses SET old_provider_id = provider_id;
UPDATE app.preview_courses SET provider_id = NULL;
ALTER TABLE app.preview_courses ALTER COLUMN provider_id SET DATA TYPE uuid USING (public.uuid_generate_v4());
UPDATE app.preview_courses SET provider_id = NULL;
SELECT log_message('populating preview_courses.provider_id with new provider_id values');
WITH t AS (
   SELECT app.providers.id AS id, app.providers.old_id AS old_id
   FROM app.providers
)
UPDATE app.preview_courses
SET provider_id = t.id
FROM t
WHERE app.preview_courses.old_provider_id = t.old_id;
SELECT log_message('adding preview_courses_provider_id_fkey constraint on table app.preview_courses');
ALTER TABLE app.preview_courses ADD FOREIGN KEY (provider_id) REFERENCES app.providers(id);
ALTER TABLE app.preview_courses DROP COLUMN old_provider_id;

-- provider_logos_provider_id_fkey on table app.provider_logos
SELECT log_message('removing provider_logos_provider_id_fkey constraint on table app.provider_logos');
ALTER TABLE app.provider_logos ADD COLUMN old_provider_id BIGINT;
UPDATE app.provider_logos SET old_provider_id = provider_id;
ALTER TABLE app.provider_logos ALTER COLUMN provider_id DROP NOT NULL;
UPDATE app.provider_logos SET provider_id = NULL;
ALTER TABLE app.provider_logos ALTER COLUMN provider_id SET DATA TYPE uuid USING (public.uuid_generate_v4());
UPDATE app.provider_logos SET provider_id = NULL;
SELECT log_message('populating provider_logos.provider_id with new provider_id values');
WITH t AS (
   SELECT app.providers.id AS id, app.providers.old_id AS old_id
   FROM app.providers
)
UPDATE app.provider_logos
SET provider_id = t.id
FROM t
WHERE app.provider_logos.old_provider_id = t.old_id;
SELECT log_message('adding provider_logos_provider_id_fkey constraint on table app.provider_logos');
ALTER TABLE app.provider_logos ADD FOREIGN KEY (provider_id) REFERENCES app.providers(id);
ALTER TABLE app.provider_logos ALTER COLUMN provider_id SET NOT NULL;
ALTER TABLE app.provider_logos DROP COLUMN old_provider_id;

---- recreate triggers, functions, views, etc ----

--- dependent on app.providers ---

-- BEGIN VIEW api.providers --
SELECT log_message('recreating VIEW api.providers');
CREATE OR REPLACE VIEW api.providers AS
  SELECT *
  FROM app.providers AS provider
  WHERE
    (
      current_user = 'user'
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND crawler.provider_id = provider.id
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
      )
    ) OR current_user = 'admin';

CREATE OR REPLACE FUNCTION triggers.api_providers_view_instead_of_update() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
  new_name CITEXT;
  new_name_changed_at TIMESTAMPTZ;
  new_name_dirty BOOLEAN;
BEGIN
  IF NEW.name IS NOT NULL THEN
    IF NEW.name ~ E'[\\s!\"\'#$%&()*+,\-./:;<=>?\[\\\\\\]^_`~]+' THEN
    RAISE EXCEPTION '%', 'error'
        USING DETAIL = 'name is invalid', HINT = 'forbidden characters present';
    END IF;

    IF LENGTH(NEW.name) > 50 THEN
      RAISE EXCEPTION '%', 'error'
        USING DETAIL = 'name is invalid', HINT = 'length is greater than 50';
    END IF;
  END IF;

  IF current_user = 'user' THEN
    IF NEW.name IS NOT NULL AND (OLD.name_changed_at IS NULL OR AGE(OLD.name_changed_at) > '5 days') THEN
      new_name := NEW.name;
      new_name_changed_at := NOW();
      new_name_dirty := false;
    ELSE
      new_name := OLD.name;
      new_name_changed_at := OLD.name_changed_at;
      new_name_dirty := OLD.name_dirty;
    END IF;

    UPDATE app.providers
    SET
      name            = new_name,
      name_dirty      = new_name_dirty,
      name_changed_at = new_name_changed_at,
      description     = NEW.description,
      slug            = COALESCE(OLD.slug, app.slugify(NEW.slug), app.slugify(new_name))
    WHERE
      id = OLD.id
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
          AND crawler.provider_id = app.providers.id
      )
    RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  IF if_admin(TRUE) THEN
    IF NEW.name IS NOT NULL THEN
      new_name := NEW.name;
      new_name_changed_at := NOW();
      new_name_dirty := false;
    ELSE
      new_name := OLD.name;
      new_name_changed_at := OLD.name_changed_at;
      new_name_dirty := OLD.name_dirty;
    END IF;

    UPDATE app.providers
    SET
      name                 = new_name,
      name_dirty           = new_name_dirty,
      name_changed_at      = new_name_changed_at,
      description          = NEW.description,
      slug                 = NEW.slug,
      afn_url_template     = NEW.afn_url_template,
      published            = NEW.published,
      published_at         = NEW.published_at,
      encoded_deep_linking = NEW.encoded_deep_linking
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_providers_view_instead_of_update
  INSTEAD OF UPDATE
  ON api.providers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_providers_view_instead_of_update();

GRANT SELECT, INSERT, UPDATE ON api.providers TO "admin";
GRANT SELECT,         UPDATE ON api.providers TO "user";

-- END VIEW api.providers --

-- BEGIN VIEW api.earnings --
SELECT log_message('recreating VIEW api.earnings');
CREATE VIEW api.earnings AS
  SELECT
    tracked_actions.id,
    tracked_actions.sale_amount,
    tracked_actions.earnings_amount,
    tracked_actions.ext_click_date,
    tracked_actions.ext_sku_id,
    tracked_actions.ext_product_name,
    tracked_actions.ext_id,
    tracked_actions.source                             AS affiliate_network,
    providers.name                                     AS provider_name,
    courses.name                                       AS course_name,
    courses.url                                        AS course_url,
    (enrollments.tracking_data->>'country')::text      AS country,
    (enrollments.tracking_data->>'query_string')::text AS qs,
    (enrollments.tracking_data->>'referer')::text      AS referer,
    (enrollments.tracking_data->>'utm_source')::text   AS utm_source,
    (enrollments.tracking_data->>'utm_campaign')::text AS utm_campaign,
    (enrollments.tracking_data->>'utm_medium')::text   AS utm_medium,
    (enrollments.tracking_data->>'utm_term')::text     AS utm_term,
    tracked_actions.created_at
  FROM app.tracked_actions
    LEFT JOIN app.enrollments ON enrollments.id = tracked_actions.enrollment_id
    LEFT JOIN app.courses     ON courses.id     = enrollments.course_id
    LEFT JOIN app.providers   ON providers.id   = courses.provider_id;

GRANT SELECT ON api.earnings  TO "admin";
-- END VIEW api.earnings --

--- dependent on app.courses ---

-- BEGIN MATERIALIZED VIEW subsets.course_summaries --
SELECT log_message('recreating MATERIALIZED VIEW subsets.course_summaries');
CREATE MATERIALIZED VIEW subsets.course_summaries AS (
  SELECT
    courses.id,
    courses.provider_id,
    courses.category,
    courses.published,
    courses.up_to_date_id,
    courses.updated_at,
    COUNT( DISTINCT enrollments.id )                                                          AS enrollment_count,
    COUNT( DISTINCT enrollments.id ) FILTER ( WHERE enrollments.user_account_id IS NOT NULL ) AS user_accounts_count,
    COUNT( DISTINCT tracked_actions.enrollment_id )                                           AS tracked_actions_count
  FROM app.courses
  LEFT JOIN app.enrollments ON
    enrollments.course_id = courses.id
  LEFT JOIN app.tracked_actions ON
    tracked_actions.enrollment_id = enrollments.id
  GROUP BY 1, 2, 3, 4, 5, 6
);
-- END MATERIALIZED VIEW subsets.course_summaries --

-- BEGIN VIEW subsets.course_filters --
SELECT log_message('recreating VIEW subsets.course_filters');
CREATE OR REPLACE VIEW subsets.course_filters AS (
  SELECT
    id,
    provider_id,
    category,
    published,
    up_to_date_id,
    updated_at,
    CASE WHEN up_to_date_id IS NOT NULL THEN TRUE ELSE FALSE END AS has_up_to_date_id,
    CASE WHEN enrollment_count      > 0 THEN TRUE ELSE FALSE END AS has_enrollment,
    CASE WHEN user_accounts_count   > 0 THEN TRUE ELSE FALSE END AS has_user_account,
    CASE WHEN tracked_actions_count > 0 THEN TRUE ELSE FALSE END AS has_tracked_actiont
  FROM subsets.course_summaries
);
-- END VIEW subsets.course_filters --

-- BEGIN VIEW subsets.courses --
SELECT log_message('recreating VIEW subsets.courses');
CREATE OR REPLACE VIEW subsets.courses AS (
  WITH RECURSIVE selected_courses AS (
    (
      SELECT
        filters.*,
        ROW_NUMBER() OVER (PARTITION BY provider_id, category, published, has_up_to_date_id, has_enrollment, has_user_account, has_tracked_actiont ORDER BY updated_at DESC) AS row
      FROM subsets.course_filters AS filters
     ) UNION (
      SELECT
        filters.*,
        ROW_NUMBER() OVER (PARTITION BY provider_id, category, published, has_up_to_date_id, has_enrollment, has_user_account, has_tracked_actiont ORDER BY updated_at ASC) AS row
      FROM subsets.course_filters AS filters
    ) UNION (
      SELECT
        filters.*,
        selected.row
      FROM subsets.course_filters AS filters
      INNER JOIN selected_courses AS selected ON
        selected.up_to_date_id = filters.id
    )
  )

  SELECT courses.*
  FROM (
    SELECT
      id,
      provider_id,
      category,
      published,
      up_to_date_id,
      updated_at,
      has_up_to_date_id,
      has_enrollment,
      has_user_account,
      has_tracked_actiont,
      MIN(row) AS row
    FROM selected_courses
    GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
  ) AS c
  INNER JOIN app.courses ON
    courses.id = c.id
  WHERE row <= 10
);
-- END VIEW subsets.courses --

-- BEGIN VIEW subsets.enrollments --
SELECT log_message('recreating VIEW subsets.enrollments');
CREATE OR REPLACE VIEW subsets.enrollments AS (
  WITH selected_enrollments AS (
    SELECT
      enrollments.*,
      ROW_NUMBER() OVER (PARTITION BY enrollments.course_id, course_filters.has_tracked_actiont ORDER BY enrollments.updated_at DESC) AS row
    FROM app.enrollments
    INNER JOIN subsets.courses ON
      enrollments.course_id = courses.id
    INNER JOIN subsets.course_filters ON
      course_filters.id = courses.id
  )

  SELECT
    id,
    user_account_id,
    course_id,
    tracked_url,
    description,
    user_rating,
    tracked_search_id,
    tracking_data,
    tracking_cookies,
    created_at,
    updated_at
  FROM selected_enrollments
  WHERE row < 8
);
-- END VIEW subsets.enrollments --

-- BEGIN VIEW subsets.tracked_actions --
SELECT log_message('recreating VIEW subsets.tracked_actions');
CREATE OR REPLACE VIEW subsets.tracked_actions AS (
  SELECT tracked_actions.*
  FROM app.tracked_actions
  INNER JOIN subsets.enrollments ON
    tracked_actions.enrollment_id = enrollments.id
);
-- END VIEW subsets.tracked_actions --

--- dependent on app.provider_crawlers ---

-- BEGIN VIEW api.provider_crawlers --
SELECT log_message('recreating VIEW api.provider_crawlers');
CREATE OR REPLACE VIEW api.provider_crawlers AS
  SELECT *
  FROM app.provider_crawlers
  WHERE
    (
      status != 'deleted' AND if_user_by_ids(user_account_ids, TRUE)
    ) OR current_user = 'admin';

CREATE OR REPLACE FUNCTION triggers.api_provider_crawlers_view_instead_of_insert() RETURNS trigger AS $$
DECLARE
  _provider_id uuid;
  new_record   RECORD;
BEGIN
  IF current_user = 'user' THEN
    INSERT INTO app.providers DEFAULT VALUES RETURNING id INTO _provider_id;

    INSERT INTO app.provider_crawlers (
      provider_id,
      user_account_ids,
      sitemaps
    ) VALUES (
      _provider_id,
      ARRAY[current_setting('request.jwt.claim.sub',true)::bigint],
      '{}'
    ) RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  IF if_admin(TRUE) THEN
    IF NEW.provider_id IS NOT NULL THEN
      _provider_id = NEW.provider_id;
    ELSE
      INSERT INTO app.providers DEFAULT VALUES RETURNING id INTO _provider_id;
    END IF;

    INSERT INTO app.provider_crawlers (
      user_agent_token,
      provider_id,
      published,
      status,
      user_account_ids,
      sitemaps
    ) VALUES (
      COALESCE(NEW.user_agent_token, public.uuid_generate_v4()),
      _provider_id,
      COALESCE(NEW.published, false),
      COALESCE(NEW.status, 'unverified'),
      COALESCE(NEW.user_account_ids, '{}'),
      COALESCE(app.fill_sitemaps(NEW.sitemaps), '{}')
    ) RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_provider_crawlers_view_instead_of_insert
  INSTEAD OF INSERT
  ON api.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_provider_crawlers_view_instead_of_insert();

CREATE OR REPLACE FUNCTION triggers.api_provider_crawlers_view_instead_of_update() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
  sitemap app.sitemap;
  user_id bigint;
  user_role varchar;
BEGIN
  user_id := current_setting('request.jwt.claim.sub', true)::bigint;
  user_role := current_setting('request.jwt.claim.role', true)::varchar;

  IF ARRAY_LENGTH(NEW.sitemaps, 1) > 0 AND NEW.sitemaps[1].id IS NOT NULL AND (
    OLD.sitemaps[1].id IS NULL OR
    OLD.sitemaps[1].id <> NEW.sitemaps[1].id
  ) THEN
    sitemap :=
      ( '(' || NEW.sitemaps[1].id  ||  ','
            || 'unverified'    ||  ','
            || NEW.sitemaps[1].url ||  ','
            || 'unknown'       ||  ')'
      )::app.sitemap;
  END IF;

  IF user_role = 'user' AND user_id = ANY(OLD.user_account_ids) THEN
    IF sitemap.id IS NOT NULL THEN
      UPDATE app.provider_crawlers
      SET
        user_account_ids = NEW.user_account_ids,
        sitemaps         = ARRAY[sitemap]::app.sitemap[]
      WHERE
        id = OLD.id
      RETURNING * INTO new_record;

      INSERT INTO public.que_jobs
        (queue, priority, run_at, job_class, args, data)
        VALUES
        (
          'default',
          100,
          NOW(),
          'Developers::SitemapVerificationJob',
          ('["' || OLD.id || '","' || sitemap.id  || '"]')::jsonb,
          '{}'::jsonb
        );
    ELSE
      UPDATE app.provider_crawlers
      SET
        user_account_ids = NEW.user_account_ids,
        urls             = NEW.urls
      WHERE
        id = OLD.id
      RETURNING * INTO new_record;

      INSERT INTO public.que_jobs
        (queue, priority, run_at, job_class, args, data)
        VALUES
        (
          'default',
          100,
          NOW(),
          'Developers::ProviderCrawlerSetupJob',
          ('["' || OLD.id || '"]')::jsonb,
          '{}'::jsonb
        );
    END IF;

    RETURN new_record;
  END IF;

  IF user_role = 'admin' THEN
    UPDATE app.provider_crawlers
    SET
      user_agent_token = NEW.user_agent_token,
      provider_id      = NEW.provider_id,
      published        = NEW.published,
      status           = NEW.status,
      user_account_ids = NEW.user_account_ids,
      sitemaps         = NEW.sitemaps,
      urls             = NEW.urls
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  RAISE insufficient_privilege;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE TRIGGER api_provider_crawlers_view_instead_of_update
  INSTEAD OF UPDATE
  ON api.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_provider_crawlers_view_instead_of_update();

CREATE OR REPLACE FUNCTION triggers.api_provider_crawlers_view_instead_of_delete() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
BEGIN
  IF if_admin(TRUE) OR if_user_by_ids(OLD.user_account_ids, TRUE) THEN
    UPDATE app.provider_crawlers
    SET status = 'deleted'
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    RETURN OLD;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_provider_crawlers_view_instead_of_delete
  INSTEAD OF DELETE
  ON api.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_provider_crawlers_view_instead_of_delete();

GRANT SELECT, INSERT, UPDATE, DELETE ON api.provider_crawlers     TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.provider_crawlers     TO "user";

-- END VIEW api.provider_crawlers --

--- dependent on app.preview_courses ---

-- BEGIN VIEW api.preview_courses --
SELECT log_message('recreating VIEW api.preview_courses');
CREATE OR REPLACE VIEW api.preview_courses AS
  SELECT course.*
  FROM app.preview_courses AS course
  WHERE
    (
      current_user = 'user'
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND course.provider_crawler_id = crawler.id
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
      )
    ) OR current_user = 'admin';

CREATE OR REPLACE FUNCTION triggers.api_preview_courses_view_instead_of_insert() RETURNS trigger AS $$
DECLARE
  preview_course RECORD;
  provider_crawler_id uuid;
  provider_id uuid;
  current_user_id bigint;
BEGIN
  current_user_id := current_setting('request.jwt.claim.sub', true)::bigint;
  preview_course := NEW;

  preview_course.id := COALESCE(preview_course.id, public.uuid_generate_v4());
  preview_course.status := 'pending';

  SELECT app.provider_crawlers.id,
         app.provider_crawlers.provider_id
    INTO provider_crawler_id, provider_id
    FROM app.provider_crawlers
    WHERE app.provider_crawlers.id = preview_course.provider_crawler_id
      AND current_user_id = ANY(app.provider_crawlers.user_account_ids)
    LIMIT 1;

  IF provider_crawler_id IS NOT NULL AND provider_id IS NOT NULL THEN
    INSERT INTO app.preview_courses (id, status, url, provider_crawler_id, provider_id)
          VALUES (preview_course.id, preview_course.status, preview_course.url, preview_course.provider_crawler_id, provider_id);

    INSERT INTO public.que_jobs
      (queue, priority, run_at, job_class, args, data)
      VALUES
      (
        'default',
        100,
        NOW(),
        'Developers::PreviewCourseProcessorJob',
        ('["' || provider_crawler_id || '","' || preview_course.id   || '"]')::jsonb,
        '{}'::jsonb
      );

    RETURN preview_course;
  ELSE
    RETURN NULL;
  END IF;

  RAISE insufficient_privilege;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE TRIGGER api_preview_courses_view_instead_of_insert
  INSTEAD OF INSERT OR UPDATE
  ON api.preview_courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_preview_courses_view_instead_of_insert();

GRANT SELECT, INSERT,         DELETE ON api.preview_courses       TO "admin";
GRANT SELECT, INSERT,         DELETE ON api.preview_courses       TO "user";
-- END VIEW api.preview_courses --

-- BEGIN VIEW api.preview_course_images --
SELECT log_message('recreating VIEW api.preview_course_images');
CREATE OR REPLACE VIEW api.preview_course_images AS
  SELECT app.preview_course_images.*
  FROM app.preview_course_images
  INNER JOIN api.preview_courses ON api.preview_courses.id = app.preview_course_images.preview_course_id;

GRANT SELECT, INSERT,         DELETE ON api.preview_course_images TO "admin";
GRANT SELECT, INSERT,         DELETE ON api.preview_course_images TO "user";
-- END VIEW api.preview_course_images --

--- dependent on app.provider_logos ---

-- BEGIN VIEW api.provider_logos --
SELECT log_message('recreating VIEW api.provider_logos');
CREATE OR REPLACE VIEW api.provider_logos AS
  SELECT
    app.provider_logos.id as id,
    app.provider_logos.provider_id as provider_id,
    app.direct_uploads.file as file,
    app.direct_uploads.user_account_id as user_account_id,
    app.direct_uploads.created_at as created_at,
    app.direct_uploads.updated_at as updated_at,
    app.sign_direct_s3_fetch(app.direct_uploads.id, app.direct_uploads.file, 'provider_logos/' || app.provider_logos.provider_id::varchar, 3600)  AS fetch_url,
    app.sign_direct_s3_upload(app.direct_uploads.id, app.direct_uploads.file, 'provider_logos/' || app.provider_logos.provider_id::varchar, 3600) AS upload_url,
    app.content_type_by_extension(app.direct_uploads.file)                              AS file_content_type
  FROM app.provider_logos
  INNER JOIN app.direct_uploads ON app.direct_uploads.id = app.provider_logos.direct_upload_id
  WHERE
    current_user = 'admin' OR (
      current_user = 'user' AND
      current_setting('request.jwt.claim.sub', true)::bigint = app.direct_uploads.user_account_id
    );

CREATE OR REPLACE FUNCTION triggers.api_provider_logos_view_instead() RETURNS trigger AS $$
DECLARE
  current_user_id bigint;
  direct_upload app.direct_uploads;
  provider_logo app.provider_logo;
  filename varchar;
  file_content_type varchar;
  fetch_url text;
  upload_url text;
BEGIN
  current_user_id   := current_setting('request.jwt.claim.sub', true)::bigint;
  filename          := NEW.file;

  IF (TG_OP = 'INSERT') THEN
    INSERT INTO app.direct_uploads (
      id,
      user_account_id,
      file
    ) VALUES (
      NEW.id,
      current_user_id,
      filename
    ) ON CONFLICT (id) DO
      UPDATE set file = filename
      RETURNING * INTO direct_upload;
  ELSIF (TG_OP = 'UPDATE') THEN
    UPDATE app.direct_uploads
    SET
      user_account_id   = current_user_id,
      file              = filename
    WHERE
      id = OLD.id
    RETURNING * INTO direct_upload;
  END IF;

  file_content_type := app.content_type_by_extension(filename);
  fetch_url         := app.sign_direct_s3_fetch(direct_upload.id, filename, 'provider_logos/' || NEW.provider_id::varchar, 3600);
  upload_url        := app.sign_direct_s3_upload(direct_upload.id, filename, 'provider_logos/' || NEW.provider_id::varchar, 3600);

  INSERT INTO app.provider_logos (
    direct_upload_id,
    provider_id
  ) VALUES (
    direct_upload.id,
    NEW.provider_id
  ) ON CONFLICT (provider_id) DO
    UPDATE set direct_upload_id = direct_upload.id;

  SELECT app.provider_logos.id INTO provider_logo FROM app.provider_logos WHERE app.provider_logos.provider_id = NEW.provider_id;
  provider_logo.provider_id := NEW.provider_id;
  provider_logo.file := filename;
  provider_logo.user_account_id := current_user_id;
  provider_logo.created_at := direct_upload.created_at;
  provider_logo.updated_at := direct_upload.updated_at;
  provider_logo.fetch_url := fetch_url;
  provider_logo.upload_url := upload_url;
  provider_logo.file_content_type := file_content_type;

  RETURN provider_logo;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_provider_logos_view_instead
  INSTEAD OF INSERT OR UPDATE
  ON api.provider_logos
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_provider_logos_view_instead();

GRANT SELECT, INSERT, UPDATE, DELETE ON api.provider_logos        TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.provider_logos        TO "user";
-- END VIEW api.provider_logos --

INSERT INTO public.schema_migrations (version) VALUES ('20200707144858');

DROP FUNCTION log_message;

COMMIT;

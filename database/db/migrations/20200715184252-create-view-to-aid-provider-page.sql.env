BEGIN;

CREATE INDEX index_courses_on_provider_id_published
ON app.courses
USING btree (provider_id)
WHERE published = true;

DROP MATERIALIZED VIEW app.provider_price_ranges;

CREATE MATERIALIZED VIEW app.provider_pricings AS (
  SELECT provider_id,
         ARRAY_AGG(DISTINCT type) AS membership_types,
         MIN(app.price_in_decimal(price)) AS min_price,
         MAX(app.price_in_decimal(price)) AS max_price,
         MIN(app.price_in_decimal(trial_price)) AS min_trial_price,
         MAX(app.price_in_decimal(trial_price)) AS max_trial_price
    FROM (
      SELECT DISTINCT ON (id)
             provider_id,
             UNNEST(ARRAY_AGG(DISTINCT type)) AS type,
             MIN(CASE WHEN TYPE = 'single_course' THEN price ELSE total_price END) AS price,
             MIN(trial_price) AS trial_price
        FROM (
          SELECT id,
                provider_id,
                jsonb_array_elements(pricing_models)->>'type' AS type,
                jsonb_array_elements(pricing_models)->>'price' AS price,
                jsonb_array_elements(pricing_models)->>'total_price' AS total_price,
                jsonb_array_elements(pricing_models)->'trial_period'->>'value' AS trial_price,
                app.currency_index(jsonb_array_elements(pricing_models)->>'currency'::VARCHAR) AS currency
            FROM app.courses
            WHERE published = 't'
        ) sq
        GROUP BY id, provider_id, currency
    ) sq2 GROUP BY provider_id
);

CREATE MATERIALIZED VIEW app.provider_stats AS (
  WITH top_countries AS (
    SELECT provider_id, (ARRAY_AGG(country))[1:5] AS countries FROM (
      SELECT provider_id, tracking_data->>'country' AS country, count(*) AS count_all
        FROM app.enrollments
        WHERE tracking_data->>'country' IS NOT NULL
        GROUP BY provider_id, country
        ORDER BY count_all DESC
    ) sq
    GROUP BY provider_id
  ),
  areas_of_knowledge AS (
    SELECT DISTINCT ON (provider_id) provider_id, tag, count(*) AS count_all
    FROM (
      SELECT provider_id, UNNEST(curated_tags) AS tag
      FROM app.courses
      WHERE app.courses.published = true
    ) sq
    WHERE tag IN (
      'computer_science',
      'arts_and_design',
      'business',
      'personal_development',
      'data_science',
      'physical_science_and_engineering',
      'marketing',
      'language_and_communication',
      'life_sciences',
      'math_and_logic',
      'social_sciences',
      'health_and_fitness'
    )
    GROUP BY provider_id, tag
    ORDER BY provider_id, count_all DESC
  ),
  indexed_courses AS (
    SELECT provider_id, count(*) AS count_all
    FROM app.courses
    WHERE published = true
    GROUP BY provider_id
  ),
  instructors AS (
    SELECT (SELECT id FROM app.providers WHERE name = teaching_at) AS provider_id, COUNT(*) AS count_all
    FROM (
      SELECT id, UNNEST(teaching_at) AS teaching_at
      FROM app.orphaned_profiles
      WHERE orphaned_profiles.state = 'enabled'
    ) sq
    GROUP BY provider_id
  )
  SELECT app.providers.id AS provider_id,
         top_countries.countries AS top_countries,
         areas_of_knowledge.tag AS areas_of_knowledge,
         indexed_courses.count_all AS indexed_courses,
         instructors.count_all AS instructors
    FROM app.providers
    LEFT JOIN top_countries ON top_countries.provider_id = app.providers.id
    LEFT JOIN areas_of_knowledge ON areas_of_knowledge.provider_id = app.providers.id
    LEFT JOIN indexed_courses ON indexed_courses.provider_id = app.providers.id
    LEFT JOIN instructors ON instructors.provider_id = app.providers.id
    WHERE top_countries IS NOT NULL
       OR areas_of_knowledge IS NOT NULL
       OR indexed_courses IS NOT NULL
       OR instructors IS NOT NULL
);

INSERT INTO public.schema_migrations (version) VALUES ('20200715184252');

COMMIT;

BEGIN;

CREATE OR REPLACE FUNCTION app.fill_sitemaps(
  _sitemaps app.sitemap[]
) RETURNS app.sitemap[] AS $$
  SELECT
    ARRAY_AGG(
      (
        COALESCE(sitemap.id,     public.uuid_generate_v4()),
        COALESCE(sitemap.status, 'unconfirmed'),
        sitemap.url
      )::app.sitemap
    )
  FROM unnest(_sitemaps) AS sitemap
  WHERE
    sitemap.url IS NOT NULL
    AND char_length(sitemap.url) > 0
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION app.merge_sitemaps(
  _old_sitemaps app.sitemap[],
  _new_sitemaps app.sitemap[]
) RETURNS app.sitemap[] AS $$
  SELECT
    ARRAY_AGG(
      COALESCE(old_sitemap, new_sitemap)
    )
  FROM      unnest(_new_sitemaps) AS new_sitemap
  LEFT JOIN unnest(_old_sitemaps) AS old_sitemap ON
    new_sitemap.id = old_sitemap.id
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION app.new_sitemaps(
  _sitemaps app.sitemap[]
) RETURNS app.sitemap[] AS $$
  SELECT
    ARRAY_AGG(
      (
        COALESCE(sitemap.id, public.uuid_generate_v4()),
        'unconfirmed',
        sitemap.url
      )::app.sitemap
    )
  FROM unnest(_sitemaps) AS sitemap
  WHERE
    sitemap.url IS NOT NULL
    AND char_length(sitemap.url) > 0
$$ LANGUAGE sql;

CREATE OR REPLACE VIEW api.crawler_domains AS
  SELECT id,
         provider_crawler_id,
         authority_confirmation_status,
         authority_confirmation_token,
         authority_confirmation_method,
         created_at,
         updated_at,
         domain
  FROM app.crawler_domains AS crawler_domain
  WHERE
    (
      current_user = 'user'
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND crawler_domain.provider_crawler_id = crawler.id
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
      )
    ) OR current_user = 'admin';

CREATE OR REPLACE FUNCTION triggers.api_crawler_domains_view_instead_of_insert() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
BEGIN
  IF current_user = 'user' THEN
    INSERT INTO app.crawler_domains (
      provider_crawler_id,
      domain
    ) VALUES (
      NEW.provider_crawler_id,
      NEW.domain
    ) RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  IF if_admin(TRUE) THEN
    INSERT INTO app.crawler_domains (
      provider_crawler_id,
      authority_confirmation_status,
      domain
    ) VALUES (
      NEW.provider_crawler_id,
      COALESCE(NEW.authority_confirmation_status, 'unconfirmed'),
      NEW.domain
    ) RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_crawler_domains_view_instead_of_insert
  INSTEAD OF INSERT
  ON api.crawler_domains
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_crawler_domains_view_instead_of_insert();

CREATE OR REPLACE FUNCTION triggers.api_crawler_domains_view_instead_of_update() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
  _action varchar;
BEGIN
  SELECT current_setting('request.header.action', true)::varchar INTO _action;

  IF if_admin(TRUE) THEN
    UPDATE app.crawler_domains
    SET
      provider_crawler_id           = NEW.provider_crawler_id,
      authority_confirmation_status = NEW.authority_confirmation_status,
      authority_confirmation_token  = NEW.authority_confirmation_token,
      authority_confirmation_method = NEW.authority_confirmation_method,
      domain                        = NEW.domain
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  IF _action = 'DomainAuthorityVerification' THEN
    INSERT INTO public.que_jobs
      (queue, priority, run_at, job_class, args, data)
      VALUES
      (
        'default',
        100,
        NOW(),
        'Developers::DomainAuthorityVerificationJob',
        ('["' || OLD.id || '"]')::jsonb,
        '{}'::jsonb
      );

    RETURN OLD;
  END IF;

  RAISE insufficient_privilege;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE TRIGGER api_crawler_domains_view_instead_of_update
  INSTEAD OF UPDATE
  ON api.crawler_domains
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_crawler_domains_view_instead_of_update();

CREATE OR REPLACE FUNCTION triggers.api_crawler_domains_view_instead_of_delete() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
BEGIN
  IF if_admin(TRUE) THEN
    UPDATE app.crawler_domains
    SET status = 'deleted'
    WHERE
      id = OLD.id;

    RETURN OLD;
  END IF;

  SELECT *
  FROM api.provider_crawlers AS crawler
  WHERE
    crawler.id = OLD.provider_crawler_id
  INTO new_record;

  IF NOT FOUND THEN
    RAISE insufficient_privilege;
  END IF;

  IF if_user_by_ids(new_record.user_account_ids, TRUE) THEN
    UPDATE app.crawler_domains
    SET status = 'deleted'
    WHERE
      id = OLD.id;

    RETURN OLD;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_crawler_domains_view_instead_of_delete
  INSTEAD OF DELETE
  ON api.crawler_domains
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_crawler_domains_view_instead_of_delete();

CREATE OR REPLACE VIEW api.crawling_events AS
  SELECT *
  FROM app.crawling_events AS event
  WHERE
    (
      current_user = 'user'
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND event.provider_crawler_id = crawler.id
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
      )
    ) OR current_user = 'admin';

CREATE OR REPLACE VIEW api.preview_courses AS
  SELECT course.*
  FROM app.preview_courses AS course
  WHERE
    (
      current_user = 'user'
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND course.provider_crawler_id = crawler.id
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
      )
    ) OR current_user = 'admin';

CREATE OR REPLACE VIEW api.preview_course_images AS
  SELECT app.preview_course_images.*
  FROM app.preview_course_images
  INNER JOIN api.preview_courses ON api.preview_courses.id = app.preview_course_images.preview_course_id;

CREATE OR REPLACE FUNCTION public.if_user_by_ids(ids bigint[], value anyelement) RETURNS anyelement AS $$
BEGIN
  IF current_user = 'user' AND current_setting('request.jwt.claim.sub', true)::bigint = ANY(ids) THEN
    RETURN value;
  ELSE
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION public.if_admin(value anyelement) RETURNS anyelement AS $$
BEGIN
  IF current_user = 'admin' THEN
    RETURN value;
  ELSE
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION public.if_user_by_id(id bigint, value anyelement) RETURNS anyelement AS $$
BEGIN
  IF current_user = 'user' AND current_setting('request.jwt.claim.sub', true)::bigint = id THEN
    RETURN value;
  ELSE
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql STABLE;

GRANT SELECT, INSERT, UPDATE         ON api.crawler_domains       TO "admin";
GRANT SELECT                         ON api.crawling_events       TO "admin";
GRANT SELECT, INSERT,         DELETE ON api.preview_courses       TO "admin";
GRANT SELECT, INSERT,         DELETE ON api.preview_course_images TO "admin";

GRANT SELECT, INSERT, UPDATE         ON api.crawler_domains       TO "user";
GRANT SELECT                         ON api.crawling_events       TO "user";
GRANT SELECT, INSERT,         DELETE ON api.preview_courses       TO "user";
GRANT SELECT, INSERT,         DELETE ON api.preview_course_images TO "user";

INSERT INTO public.schema_migrations (version) VALUES ('20191111180132');

COMMIT;

BEGIN;

CREATE TYPE app.authority_confirmation_method AS ENUM (
  'dns',
  'html'
);

CREATE TYPE app.authority_confirmation_status AS ENUM (
  'unconfirmed',
  'confirming',
  'confirmed',
  'failed',
  'deleted'
);

CREATE TYPE app.crawler_status AS ENUM (
  'unverified', 'pending', 'broken', 'active', 'deleted'
);

CREATE TYPE app.preview_course_status AS ENUM (
  'pending', 'failed', 'succeeded'
);

CREATE TYPE app.sitemap AS (
  id     uuid,
  status varchar,
  url    varchar,
  type   varchar
);

CREATE TABLE app.provider_crawlers (
  id               uuid               DEFAULT    public.uuid_generate_v1() PRIMARY KEY,
  user_agent_token uuid               DEFAULT    public.uuid_generate_v4() NOT NULL,
  provider_id      bigint             REFERENCES app.providers(id)         ON DELETE CASCADE,
  published        boolean            DEFAULT    false                     NOT NULL,
  created_at       timestamptz        DEFAULT    NOW()                     NOT NULL,
  updated_at       timestamptz        DEFAULT    NOW()                     NOT NULL,
  status           app.crawler_status DEFAULT    'unverified'              NOT NULL,
  user_account_ids bigint[]           DEFAULT    '{}'                      NOT NULL,
  sitemaps         app.sitemap[]      DEFAULT    '{}'                      NOT NULL,
  version          varchar,
  settings         jsonb
);

CREATE TABLE app.crawler_domains (
  id                            uuid                              DEFAULT    public.uuid_generate_v1() PRIMARY KEY,
  provider_crawler_id           uuid                              REFERENCES app.provider_crawlers(id) ON DELETE CASCADE NOT NULL ,
  authority_confirmation_status app.authority_confirmation_status DEFAULT    'unconfirmed'                               NOT NULL,
  authority_confirmation_token  uuid                              DEFAULT    public.uuid_generate_v4()                   NOT NULL,
  authority_confirmation_method app.authority_confirmation_method DEFAULT    'dns'                                       NOT NULL,
  created_at                    timestamptz                       DEFAULT    NOW()                                       NOT NULL,
  updated_at                    timestamptz                       DEFAULT    NOW()                                       NOT NULL,
  domain                        varchar                                                                                  NOT NULL,

  CONSTRAINT domain__must_be_a_domain CHECK ( domain ~ '^([a-z0-9\-\_]+\.)+[a-z]+$' )
);

CREATE TABLE app.crawling_events (
  id                  uuid        DEFAULT    public.uuid_generate_v1() PRIMARY KEY,
  provider_crawler_id uuid        REFERENCES app.provider_crawlers(id) ON DELETE CASCADE,
  created_at          timestamptz DEFAULT    NOW()                     NOT NULL,
  updated_at          timestamptz DEFAULT    NOW()                     NOT NULL,
  sequence            bigint,
  type                varchar                                          NOT NULL,
  data                jsonb
);

CREATE TABLE app.preview_courses (
  id                  uuid                      DEFAULT    public.uuid_generate_v1() PRIMARY KEY,
  status              app.preview_course_status DEFAULT    'pending',
  name                varchar,
  description         text,
  slug                varchar,
  url                 varchar       NOT NULL,
  url_md5             varchar,
  duration_in_hours   numeric,
  price               numeric,
  rating              numeric,
  relevance           integer       DEFAULT 0,
  region              varchar,
  audio               text[]        DEFAULT '{}'::text[],
  subtitles           text[]        DEFAULT '{}'::text[],
  published           boolean       DEFAULT true,
  stale               boolean       DEFAULT false,
  category            app.category,
  tags                text[]        DEFAULT '{}'::text[],
  video               jsonb,
  source              app.source    DEFAULT 'api'::app.source,
  pace                app.pace,
  certificate         jsonb         DEFAULT '"{}"'::jsonb,
  pricing_models      jsonb         DEFAULT '"[]"'::jsonb,
  offered_by          jsonb         DEFAULT '"[]"'::jsonb,
  syllabus            text,
  effort              integer,
  enrollments_count   integer       DEFAULT 0,
  free_content        boolean       DEFAULT false,
  paid_content        boolean       DEFAULT true,
  level               app.level[]   DEFAULT '{}'::app.level[],
  __provider_name__   varchar,
  __source_schema__   jsonb,
  __indexed_json__    jsonb,
  instructors         jsonb         DEFAULT '[]'::jsonb,
  curated_tags        varchar[]     DEFAULT '{}'::varchar[],
  refinement_tags     varchar[],
  provider_id         bigint        REFERENCES app.providers(id),
  provider_crawler_id uuid          REFERENCES app.provider_crawlers(id) ON DELETE CASCADE,
  created_at          timestamptz   DEFAULT    NOW()                     NOT NULL,
  updated_at          timestamptz   DEFAULT    NOW()                     NOT NULL,
  expired_at          timestamptz   DEFAULT    NOW() + INTERVAL '20 MINUTES' NOT NULL
);

CREATE TABLE app.preview_course_images (
  id             uuid   DEFAULT    public.uuid_generate_v1() PRIMARY KEY,
  kind           varchar,
  file           varchar,
  preview_course_id uuid REFERENCES app.preview_courses(id),
  created_at     timestamptz DEFAULT NOW() NOT NULL,
  updated_at     timestamptz DEFAULT NOW() NOT NULL
);

CREATE OR REPLACE FUNCTION triggers.validate_sitemaps() RETURNS trigger AS $$
DECLARE
  result boolean;
BEGIN
  IF NEW.sitemaps = OLD.sitemaps THEN
    RETURN NEW;
  END IF;

  result = NOT EXISTS (
    SELECT 1 FROM unnest(NEW.sitemaps) AS sitemap
    WHERE NOT EXISTS (
      SELECT 1 FROM app.crawler_domains
      WHERE
        provider_crawler_id               = NEW.id
        AND sitemap.url ~ ('^https?://([a-z0-9\-\_]+\.)*' || domain || '(:\d+)?/')
    )
  );

  IF result = false THEN
    RAISE EXCEPTION 'Invalid sitemaps' USING HINT = 'All sitemaps must have verified domains';
  END IF;

  RETURN NEW;
END;
$$ SECURITY DEFINER STABLE LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION triggers.validate_user_account_ids() RETURNS trigger AS $$
DECLARE
  result boolean;
BEGIN
  IF NEW.user_account_ids = OLD.user_account_ids THEN
    RETURN NEW;
  END IF;

  result = NOT EXISTS (
    SELECT 1 FROM unnest(NEW.user_account_ids) AS provider_user_account_id
    WHERE NOT EXISTS (
      SELECT 1 FROM app.user_accounts
      WHERE
        provider_user_account_id = app.user_accounts.id
    )
  );

  IF result = false THEN
    RAISE EXCEPTION 'Invalid user_account_ids' USING HINT = 'All user account ids must exists';
  END IF;

  RETURN NEW;
END;
$$ SECURITY DEFINER STABLE LANGUAGE plpgsql;

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE CONSTRAINT TRIGGER validate_user_account_ids
  AFTER INSERT OR UPDATE
  ON app.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.validate_user_account_ids();

CREATE CONSTRAINT TRIGGER validate_sitemaps
  AFTER INSERT OR UPDATE
  ON app.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.validate_sitemaps();

INSERT INTO public.schema_migrations (version) VALUES ('20191107132512');

COMMIT;

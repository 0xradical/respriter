BEGIN;

DROP VIEW api.provider_crawlers;
DROP VIEW api.crawling_events;
DROP VIEW api.preview_course_images;
DROP VIEW api.preview_courses;
DROP VIEW api.providers;
DROP VIEW api.crawler_domains;

ALTER TABLE app.provider_crawlers DROP COLUMN created_at;
ALTER TABLE app.provider_crawlers DROP COLUMN updated_at;
ALTER TABLE app.provider_crawlers DROP COLUMN status;
ALTER TABLE app.provider_crawlers DROP COLUMN user_account_ids;
ALTER TABLE app.provider_crawlers DROP COLUMN sitemaps;
ALTER TABLE app.provider_crawlers DROP COLUMN version;
ALTER TABLE app.provider_crawlers DROP COLUMN settings;

ALTER TABLE app.provider_crawlers ADD COLUMN scheduled        boolean            DEFAULT false        NOT NULL;
ALTER TABLE app.provider_crawlers ADD COLUMN created_at       timestamptz        DEFAULT NOW()        NOT NULL;
ALTER TABLE app.provider_crawlers ADD COLUMN updated_at       timestamptz        DEFAULT NOW()        NOT NULL;
ALTER TABLE app.provider_crawlers ADD COLUMN status           app.crawler_status DEFAULT 'unverified' NOT NULL;
ALTER TABLE app.provider_crawlers ADD COLUMN user_account_ids bigint[]           DEFAULT '{}'         NOT NULL;
ALTER TABLE app.provider_crawlers ADD COLUMN sitemaps         app.sitemap[]      DEFAULT '{}'         NOT NULL;
ALTER TABLE app.provider_crawlers ADD COLUMN version          varchar;
ALTER TABLE app.provider_crawlers ADD COLUMN settings         jsonb;

CREATE OR REPLACE VIEW api.provider_crawlers AS
  SELECT *
  FROM app.provider_crawlers
  WHERE
    (
      status != 'deleted' AND if_user_by_ids(user_account_ids, TRUE)
    ) OR current_user = 'admin';

CREATE OR REPLACE FUNCTION triggers.api_provider_crawlers_view_instead_of_insert() RETURNS trigger AS $$
DECLARE
  _provider_id bigint;
  new_record   RECORD;
BEGIN
  IF current_user = 'user' THEN
    INSERT INTO app.providers DEFAULT VALUES RETURNING id INTO _provider_id;

    INSERT INTO app.provider_crawlers (
      provider_id,
      user_account_ids,
      sitemaps
    ) VALUES (
      _provider_id,
      ARRAY[current_setting('request.jwt.claim.sub',true)::bigint],
      '{}'
    ) RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  IF if_admin(TRUE) THEN
    IF NEW.provider_id IS NOT NULL THEN
      _provider_id = NEW.provider_id;
    ELSE
      INSERT INTO app.providers DEFAULT VALUES RETURNING id INTO _provider_id;
    END IF;

    INSERT INTO app.provider_crawlers (
      user_agent_token,
      provider_id,
      published,
      status,
      user_account_ids,
      sitemaps
    ) VALUES (
      COALESCE(NEW.user_agent_token, public.uuid_generate_v4()),
      _provider_id,
      COALESCE(NEW.published, false),
      COALESCE(NEW.status, 'unverified'),
      COALESCE(NEW.user_account_ids, '{}'),
      COALESCE(app.fill_sitemaps(NEW.sitemaps), '{}')
    ) RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_provider_crawlers_view_instead_of_insert
  INSTEAD OF INSERT
  ON api.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_provider_crawlers_view_instead_of_insert();

CREATE OR REPLACE FUNCTION triggers.api_provider_crawlers_view_instead_of_update() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
  sitemap app.sitemap;
  user_id bigint;
  user_role varchar;
BEGIN
  user_id := current_setting('request.jwt.claim.sub', true)::bigint;
  user_role := current_setting('request.jwt.claim.role', true)::varchar;

  IF NEW.sitemaps[1] IS NULL THEN
    sitemap := OLD.sitemaps[1];
  ELSE
    sitemap :=
      ( '(' || NEW.sitemaps[1].id  ||  ','
            || 'unverified'    ||  ','
            || NEW.sitemaps[1].url ||  ','
            || 'unknown'       ||  ')'
      )::app.sitemap;
  END IF;

  IF user_role = 'user' AND user_id = ANY(OLD.user_account_ids) THEN
    UPDATE app.provider_crawlers
    SET
      user_account_ids = NEW.user_account_ids,
      sitemaps         = ARRAY[sitemap]::app.sitemap[]
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    INSERT INTO public.que_jobs
      (queue, priority, run_at, job_class, args, data)
      VALUES
      (
        'default',
        100,
        NOW(),
        'Developers::SitemapVerificationJob',
        ('["' || OLD.id || '","' || sitemap.id  || '"]')::jsonb,
        '{}'::jsonb
      );

    RETURN new_record;
  END IF;

  IF user_role = 'admin' THEN
    UPDATE app.provider_crawlers
    SET
      user_agent_token = NEW.user_agent_token,
      provider_id      = NEW.provider_id,
      published        = NEW.published,
      status           = NEW.status,
      user_account_ids = NEW.user_account_ids,
      sitemaps         = NEW.sitemaps
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  RAISE insufficient_privilege;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE TRIGGER api_provider_crawlers_view_instead_of_update
  INSTEAD OF UPDATE
  ON api.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_provider_crawlers_view_instead_of_update();

CREATE OR REPLACE FUNCTION triggers.api_provider_crawlers_view_instead_of_delete() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
BEGIN
  IF if_admin(TRUE) OR if_user_by_ids(OLD.user_account_ids, TRUE) THEN
    UPDATE app.provider_crawlers
    SET status = 'deleted'
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    RETURN OLD;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_provider_crawlers_view_instead_of_delete
  INSTEAD OF DELETE
  ON api.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_provider_crawlers_view_instead_of_delete();

CREATE OR REPLACE VIEW api.crawling_events AS
  SELECT *
  FROM app.crawling_events AS event
  WHERE
    (
      current_user = 'user'
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND event.provider_crawler_id = crawler.id
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
      )
    ) OR current_user = 'admin';

CREATE OR REPLACE VIEW api.preview_courses AS
  SELECT course.*
  FROM app.preview_courses AS course
  WHERE
    (
      current_user = 'user'
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND course.provider_crawler_id = crawler.id
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
      )
    ) OR current_user = 'admin';

CREATE OR REPLACE FUNCTION triggers.api_preview_courses_view_instead_of_insert() RETURNS trigger AS $$
DECLARE
  preview_course RECORD;
  provider_id bigint;
BEGIN
  preview_course := NEW;

  preview_course.id := COALESCE(preview_course.id, public.uuid_generate_v4());
  preview_course.status := 'pending';

  SELECT app.provider_crawlers.provider_id FROM app.provider_crawlers WHERE app.provider_crawlers.id = preview_course.provider_crawler_id INTO provider_id;

  INSERT INTO app.preview_courses (id, status, url, provider_crawler_id, provider_id)
  VALUES (preview_course.id, preview_course.status, preview_course.url, preview_course.provider_crawler_id, provider_id);

  INSERT INTO public.que_jobs
    (queue, priority, run_at, job_class, args, data)
    VALUES
    (
      'default',
      100,
      NOW(),
      'Developers::PreviewCourseProcessorJob',
      ('["' || preview_course.id || '"]')::jsonb,
      '{}'::jsonb
    );

  RETURN preview_course;

  RAISE insufficient_privilege;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE TRIGGER api_preview_courses_view_instead_of_insert
  INSTEAD OF INSERT OR UPDATE
  ON api.preview_courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_preview_courses_view_instead_of_insert();

CREATE OR REPLACE VIEW api.preview_course_images AS
  SELECT app.preview_course_images.*
  FROM app.preview_course_images
  INNER JOIN api.preview_courses ON api.preview_courses.id = app.preview_course_images.preview_course_id;

  CREATE OR REPLACE VIEW api.providers AS
    SELECT *
    FROM app.providers AS provider
    WHERE
      (
        current_user = 'user'
        AND EXISTS (
          SELECT 1
          FROM app.provider_crawlers AS crawler
          WHERE
            crawler.status != 'deleted'
            AND crawler.provider_id = provider.id
            AND if_user_by_ids(crawler.user_account_ids, TRUE)
        )
      ) OR current_user = 'admin';

CREATE OR REPLACE FUNCTION triggers.api_providers_view_instead_of_update() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
BEGIN
  IF current_user = 'user' THEN
    UPDATE app.providers
    SET
      name        = NEW.name,
      description = NEW.description,
      slug        = COALESCE(OLD.slug, app.slugify(NEW.slug), app.slugify(NEW.name))
    WHERE
      id = OLD.id
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
          AND crawler.provider_id = app.providers.id
      )
    RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  IF if_admin(TRUE) THEN
    UPDATE app.providers
    SET
      name                 = NEW.name,
      description          = NEW.description,
      slug                 = NEW.slug,
      afn_url_template     = NEW.afn_url_template,
      published            = NEW.published,
      published_at         = NEW.published_at,
      encoded_deep_linking = NEW.encoded_deep_linking
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_providers_view_instead_of_update
  INSTEAD OF UPDATE
  ON api.providers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_providers_view_instead_of_update();

CREATE OR REPLACE VIEW api.crawler_domains AS
  SELECT COALESCE( if_admin(crawler_domain.id),                            if_user_by_ids(crawler.user_account_ids, crawler_domain.id) ) AS id,
         crawler_domain.provider_crawler_id AS provider_crawler_id,
         crawler_domain.authority_confirmation_status AS authority_confirmation_status,
         COALESCE( if_admin(crawler_domain.authority_confirmation_token),  if_user_by_ids(crawler.user_account_ids, crawler_domain.authority_confirmation_token) ) AS authority_confirmation_token,
         COALESCE( if_admin(crawler_domain.authority_confirmation_method), if_user_by_ids(crawler.user_account_ids, crawler_domain.authority_confirmation_method) ) AS authority_confirmation_method,
         COALESCE( if_admin(crawler_domain.created_at),                    if_user_by_ids(crawler.user_account_ids, crawler_domain.created_at) ) AS created_at,
         COALESCE( if_admin(crawler_domain.updated_at),                    if_user_by_ids(crawler.user_account_ids, crawler_domain.updated_at) ) AS updated_at,
         crawler_domain.domain AS domain,
         COALESCE( if_admin(crawler_domain.authority_confirmation_salt),   if_user_by_ids(crawler.user_account_ids, crawler_domain.authority_confirmation_salt) ) AS authority_confirmation_salt
  FROM app.crawler_domains AS crawler_domain
  LEFT OUTER JOIN app.provider_crawlers AS crawler ON crawler.id = crawler_domain.provider_crawler_id
  ORDER BY id NULLS LAST;

CREATE OR REPLACE FUNCTION triggers.api_crawler_domains_view_instead_of_insert() RETURNS trigger AS $$
DECLARE
  crawler_domain RECORD;
  crawler RECORD;
  current_user_id bigint;
BEGIN
  current_user_id := current_setting('request.jwt.claim.sub', true)::bigint;

  IF if_admin(TRUE) THEN
    INSERT INTO app.crawler_domains (
      provider_crawler_id,
      authority_confirmation_status,
      domain
    ) VALUES (
      NEW.provider_crawler_id,
      COALESCE(NEW.authority_confirmation_status, 'unconfirmed'),
      NEW.domain
    ) RETURNING * INTO crawler_domain;

    RETURN crawler_domain;
  END IF;

  SELECT app.provider_crawlers.* FROM app.crawler_domains
  INNER JOIN app.provider_crawlers ON app.provider_crawlers.id = app.crawler_domains.provider_crawler_id
  WHERE app.crawler_domains.domain = NEW.domain AND app.provider_crawlers.status != 'deleted'
  LIMIT 1 INTO crawler;

  -- check for existing domains
  IF crawler IS NOT NULL THEN
    -- if there's one already for another user
    IF current_user_id != ALL(COALESCE(crawler.user_account_ids, ARRAY[]::int[])) THEN
      RAISE insufficient_privilege
        USING DETAIL = 'error', HINT = 'already_validated';
    -- if there's one already for me
    ELSE
      SELECT app.crawler_domains.* FROM app.crawler_domains
      WHERE app.crawler_domains.domain = NEW.domain
      LIMIT 1 INTO crawler_domain;

      RETURN crawler_domain;
    END IF;
  ELSE
    INSERT INTO app.crawler_domains (
      domain
    ) VALUES (
      NEW.domain
    ) ON CONFLICT DO NOTHING
    RETURNING * INTO crawler_domain;

    INSERT INTO public.que_jobs
      (queue, priority, run_at, job_class, args, data)
      VALUES
      (
        'default',
        100,
        NOW(),
        'Developers::DomainAuthorityVerificationJob',
        ('["' || crawler_domain.id || '","' || current_user_id  || '"]')::jsonb,
        '{}'::jsonb
      );

    RETURN crawler_domain;
  END IF;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE TRIGGER api_crawler_domains_view_instead_of_insert
  INSTEAD OF INSERT
  ON api.crawler_domains
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_crawler_domains_view_instead_of_insert();

CREATE OR REPLACE FUNCTION triggers.api_crawler_domains_view_instead_of_update() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
BEGIN
  IF if_admin(TRUE) THEN
    UPDATE app.crawler_domains
    SET
      provider_crawler_id           = NEW.provider_crawler_id,
      authority_confirmation_status = NEW.authority_confirmation_status,
      authority_confirmation_token  = NEW.authority_confirmation_token,
      authority_confirmation_method = NEW.authority_confirmation_method,
      domain                        = NEW.domain
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    RETURN new_record;
  END IF;
  RAISE insufficient_privilege;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE TRIGGER api_crawler_domains_view_instead_of_update
  INSTEAD OF UPDATE
  ON api.crawler_domains
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_crawler_domains_view_instead_of_update();

CREATE OR REPLACE FUNCTION triggers.api_crawler_domains_view_instead_of_delete() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
BEGIN
  IF if_admin(TRUE) THEN
    UPDATE app.crawler_domains
    SET status = 'deleted'
    WHERE
      id = OLD.id;

    RETURN OLD;
  END IF;

  SELECT *
  FROM api.provider_crawlers AS crawler
  WHERE
    crawler.id = OLD.provider_crawler_id
  INTO new_record;

  IF NOT FOUND THEN
    RAISE insufficient_privilege;
  END IF;

  IF if_user_by_ids(new_record.user_account_ids, TRUE) THEN
    UPDATE app.crawler_domains
    SET status = 'deleted'
    WHERE
      id = OLD.id;

    RETURN OLD;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_crawler_domains_view_instead_of_delete
  INSTEAD OF DELETE
  ON api.crawler_domains
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_crawler_domains_view_instead_of_delete();

GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.provider_crawlers TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE             ON api.provider_crawlers TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.provider_crawlers TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE             ON api.provider_crawlers TO "user";

GRANT SELECT ON app.crawling_events TO "user";
GRANT SELECT ON api.crawling_events TO "user";
GRANT SELECT ON app.crawling_events TO "admin";
GRANT SELECT ON api.crawling_events TO "admin";

GRANT SELECT, INSERT,         DELETE             ON app.preview_courses TO "user";
GRANT SELECT, INSERT,         DELETE             ON api.preview_courses TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.preview_courses TO "admin";
GRANT SELECT, INSERT,         DELETE             ON api.preview_courses TO "admin";

GRANT SELECT, INSERT,         DELETE             ON app.preview_course_images TO "user";
GRANT SELECT, INSERT,         DELETE             ON api.preview_course_images TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.preview_course_images TO "admin";
GRANT SELECT, INSERT,         DELETE             ON api.preview_course_images TO "admin";

GRANT SELECT, INSERT, UPDATE,         REFERENCES ON app.providers TO "user";
GRANT SELECT,         UPDATE                     ON api.providers TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.providers TO "admin";
GRANT SELECT, INSERT, UPDATE                     ON api.providers TO "admin";

GRANT SELECT, INSERT, UPDATE,         REFERENCES ON app.crawler_domains TO "user";
GRANT SELECT, INSERT, UPDATE                     ON api.crawler_domains TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.crawler_domains TO "admin";
GRANT SELECT, INSERT, UPDATE                     ON api.crawler_domains TO "admin";

INSERT INTO public.schema_migrations (version) VALUES ('20200213183318');

COMMIT;

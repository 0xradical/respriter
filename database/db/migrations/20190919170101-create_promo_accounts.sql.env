BEGIN;

CREATE TABLE app.promo_accounts (
  id              uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  user_account_id bigint REFERENCES app.user_accounts(id) ON DELETE CASCADE CONSTRAINT cntr_promo_accounts_user_account_id UNIQUE,
  certificate_id  uuid REFERENCES app.certificates(id) ON DELETE CASCADE,
  price           numeric(6,2) NOT NULL,
  purchase_date   date  NOT NULL CONSTRAINT purchase_date__less_than CHECK (purchase_date < NOW()),
  order_id        varchar NOT NULL,
  paypal_account  varchar NOT NULL,
  state           varchar NOT NULL DEFAULT 'initial',
  created_at      timestamptz  DEFAULT NOW() NOT NULL,
  updated_at      timestamptz  DEFAULT NOW() NOT NULL,
  CONSTRAINT price__greater_than CHECK (price >= 0),
  CONSTRAINT price__less_than CHECK (price <= 5000),
  CONSTRAINT paypal_account__email CHECK (paypal_account ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'),
  CONSTRAINT state__inclusion CHECK (state IN ('initial','pending','locked','rejected','approved'))
);

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.promo_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE UNIQUE INDEX index_promo_accounts_on_user_account_id
ON app.promo_accounts
USING btree (user_account_id);

CREATE OR REPLACE VIEW api.promo_accounts AS
  SELECT
    app.promo_accounts.id AS id,
    COALESCE( if_admin(app.promo_accounts.user_account_id), if_user_by_id(app.promo_accounts.user_account_id, app.promo_accounts.user_account_id) ) AS user_account_id,
    COALESCE( if_admin(certificate_id),  if_user_by_id(app.promo_accounts.user_account_id, certificate_id)  ) AS certificate_id,
    COALESCE( if_admin(price),           if_user_by_id(app.promo_accounts.user_account_id, price)           ) AS price,
    COALESCE( if_admin(purchase_date),   if_user_by_id(app.promo_accounts.user_account_id, purchase_date)   ) AS purchase_date,
    COALESCE( if_admin(order_id),        if_user_by_id(app.promo_accounts.user_account_id, order_id)        ) AS order_id,
    COALESCE( if_admin(paypal_account),  if_user_by_id(app.promo_accounts.user_account_id, paypal_account)  ) AS paypal_account,
    COALESCE( if_admin(state),           if_user_by_id(app.promo_accounts.user_account_id, state)           ) AS state,
    COALESCE( if_admin(file),            if_user_by_id(app.promo_accounts.user_account_id, file)            ) AS file,
    app.promo_accounts.created_at,
    app.promo_accounts.updated_at
  FROM app.promo_accounts
  INNER JOIN app.certificates ON app.promo_accounts.certificate_id = app.certificates.id;

CREATE OR REPLACE FUNCTION triggers.api_promo_accounts_view_instead() RETURNS trigger AS $$
DECLARE
  cert_id uuid;
  cert_user_account_id bigint;
  cert_file varchar;
  promo_account record;
  exception_sql_state text;
  exception_column_name text;
  exception_constraint_name text;
  exception_table_name text;
  exception_message text;
  exception_detail text;
  exception_hint text;
BEGIN
  promo_account := NEW;

  SELECT COALESCE(current_setting('request.header.certificateid', true)::uuid, OLD.certificate_id, 'b9559623-d289-4025-8d1e-d64b50635b51') INTO cert_id;

  IF cert_id IS NULL THEN
    RAISE EXCEPTION 'Null certificate'
      USING DETAIL = 'error', HINT = 'promo_accounts.certificate_id.null';
  END IF;

  SELECT app.certificates.user_account_id FROM app.certificates WHERE id = cert_id INTO cert_user_account_id;

  IF if_admin(TRUE) IS NULL AND if_user_by_id(cert_user_account_id, TRUE) IS NULL THEN
    RAISE EXCEPTION 'Unauthorized Access'
      USING DETAIL = 'error', HINT = 'promo_accounts.user_account_id.mismatch';
  END IF;

  IF if_admin(TRUE) IS NULL AND if_user_by_id(NEW.user_account_id, TRUE) IS NULL THEN
    RAISE EXCEPTION 'Unauthorized Access'
      USING DETAIL = 'error', HINT = 'promo_accounts.unauthorized';
  END IF;

  SELECT app.certificates.file FROM app.certificates WHERE id = cert_id INTO cert_file;

  INSERT INTO  app.promo_accounts (id, user_account_id, certificate_id, price, purchase_date, order_id, paypal_account, state)
  VALUES (COALESCE(NEW.id, public.uuid_generate_v4()), NEW.user_account_id, cert_id, NEW.price, NEW.purchase_date, NEW.order_id, NEW.paypal_account, COALESCE(NEW.state, 'pending'))
  ON CONFLICT ON CONSTRAINT cntr_promo_accounts_user_account_id DO
    UPDATE SET certificate_id = EXCLUDED.certificate_id,
               price = COALESCE(EXCLUDED.price, OLD.price),
               purchase_date = COALESCE(EXCLUDED.purchase_date, OLD.purchase_date),
               order_id = COALESCE(EXCLUDED.order_id, OLD.order_id),
               paypal_account = COALESCE(EXCLUDED.paypal_account, OLD.paypal_account),
               state = COALESCE(EXCLUDED.state, 'pending')
    RETURNING id, user_account_id, certificate_id, price, purchase_date, order_id, paypal_account, state, cert_file, created_at, updated_at INTO promo_account;

  IF OLD.state IN ('locked', 'approved') THEN
    RAISE EXCEPTION 'Cannot update on locked promo'
      USING DETAIL = 'error', HINT = 'promo_accounts.state.locked';
  END IF;

  RETURN promo_account;
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS exception_message = MESSAGE_TEXT,
                          exception_detail = PG_EXCEPTION_DETAIL,
                          exception_hint = PG_EXCEPTION_HINT,
                          exception_sql_state = RETURNED_SQLSTATE,
                          exception_column_name = COLUMN_NAME,
                          exception_constraint_name = CONSTRAINT_NAME,
                          exception_table_name = TABLE_NAME;

  IF exception_detail = 'error' THEN
    RAISE EXCEPTION '%', exception_message
      USING DETAIL = exception_detail, HINT = exception_hint;
  ELSE
    -- constraint
    IF exception_sql_state = '23514' AND exception_constraint_name IS NOT NULL THEN
      exception_column_name := REGEXP_REPLACE(exception_constraint_name, '(.*)__(.*)', '\1');
    END IF;

    RAISE EXCEPTION '%', exception_message
      USING DETAIL = 'error', HINT = 'promo_accounts.' || exception_column_name || '.' || exception_sql_state;
  END IF;

  RETURN promo_account;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_promo_accounts_view_instead
  INSTEAD OF INSERT
  ON api.promo_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_promo_accounts_view_instead();

GRANT SELECT, INSERT, UPDATE, REFERENCES ON app.promo_accounts TO "user";
GRANT SELECT, INSERT, UPDATE             ON api.promo_accounts TO "user";

GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.promo_accounts TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.promo_accounts TO "admin";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "user";

INSERT INTO public.schema_migrations (version) VALUES ('20190919170101');

COMMIT;

BEGIN;

-- UUID PKs
ALTER TABLE app.posts ADD COLUMN uuid uuid NOT NULL DEFAULT public.uuid_generate_v4();
ALTER TABLE app.profiles ADD COLUMN uuid uuid NOT NULL DEFAULT public.uuid_generate_v4();
ALTER TABLE app.admin_profiles ADD COLUMN uuid uuid NOT NULL DEFAULT public.uuid_generate_v4();

-- Associations
ALTER TABLE app.images ADD COLUMN imageable_uuid uuid;
ALTER TABLE app.posts ADD COLUMN original_post_uuid uuid;

-- Populate associations
UPDATE app.images
SET imageable_uuid = app.posts.uuid
FROM app.posts
WHERE app.images.imageable_id = app.posts.id
  AND app.images.imageable_type = 'Post';

UPDATE app.images
SET imageable_uuid = app.profiles.uuid
FROM app.profiles
WHERE app.images.imageable_id = app.profiles.id
  AND app.images.imageable_type = 'Profile';

UPDATE app.images
SET imageable_uuid = app.admin_profiles.uuid
FROM app.admin_profiles
WHERE app.images.imageable_id = app.admin_profiles.id
  AND app.images.imageable_type = 'AdminProfile';

UPDATE app.posts
SET original_post_uuid = original_posts.uuid
FROM app.posts AS original_posts
WHERE app.posts.original_post_id = original_posts.id;

-- ID -> UUID on associations
ALTER TABLE app.images DROP COLUMN imageable_id;
ALTER TABLE app.images RENAME COLUMN imageable_uuid TO imageable_id;
ALTER TABLE app.posts DROP COLUMN original_post_id;
ALTER TABLE app.posts RENAME COLUMN original_post_uuid TO original_post_id;

-- Recreate IDX
CREATE INDEX index_images_on_imageable_type_and_imageable_id ON app.images (imageable_type, imageable_id);
CREATE INDEX index_posts_on_original_post_id ON app.posts (original_post_id);

-- Migrate PKs
ALTER TABLE app.posts DROP COLUMN id;
ALTER TABLE app.posts RENAME COLUMN uuid TO id;
ALTER TABLE app.posts ADD PRIMARY KEY (id);

DROP VIEW api.profiles;

ALTER TABLE app.profiles DROP COLUMN id;
ALTER TABLE app.profiles RENAME COLUMN uuid TO id;
ALTER TABLE app.profiles ADD PRIMARY KEY (id);

CREATE OR REPLACE VIEW api.profiles AS
  SELECT
    id,
    name,
    username,
    COALESCE(uploaded_avatar_url, oauth_avatar_url) AS avatar_url,
    COALESCE( if_admin(date_of_birth),   if_user_by_id(user_account_id, date_of_birth)   ) AS date_of_birth,
    user_account_id,
    COALESCE( if_admin(interests),       if_user_by_id(user_account_id, interests)       ) AS interests,
    COALESCE( if_admin(preferences),     if_user_by_id(user_account_id, preferences)     ) AS preferences
  FROM app.profiles;

CREATE OR REPLACE FUNCTION triggers.api_profiles_view_instead() RETURNS trigger AS $$
DECLARE
  exception_sql_state text;
  exception_column_name text;
  exception_constraint_name text;
  exception_table_name text;
  exception_message text;
  exception_detail text;
  exception_hint text;
BEGIN
  IF NEW.user_account_id != OLD.user_account_id THEN
    RAISE invalid_authorization_specification USING message = 'could not change user_account_id';
  END IF;

  IF if_admin(TRUE) IS NULL AND if_user_by_id(NEW.user_account_id, TRUE) IS NULL THEN
    RAISE insufficient_privilege;
  END IF;

  UPDATE app.profiles
  SET
    name                = NEW.name,
    date_of_birth       = NEW.date_of_birth,
    interests           = NEW.interests,
    preferences         = NEW.preferences,
    username            = NEW.username
  WHERE
    id = OLD.id;

  RETURN NEW;
EXCEPTION
  WHEN insufficient_privilege THEN
    RAISE;
  WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS exception_message = MESSAGE_TEXT,
                          exception_detail = PG_EXCEPTION_DETAIL,
                          exception_hint = PG_EXCEPTION_HINT,
                          exception_sql_state = RETURNED_SQLSTATE,
                          exception_column_name = COLUMN_NAME,
                          exception_constraint_name = CONSTRAINT_NAME,
                          exception_table_name = TABLE_NAME;

  IF exception_detail = 'error' THEN
    RAISE EXCEPTION '%', exception_message
      USING DETAIL = exception_detail, HINT = exception_hint;
  ELSE
    -- constraint
    IF exception_sql_state IN ('23514', '23505') AND exception_constraint_name IS NOT NULL THEN
      exception_column_name := REGEXP_REPLACE(exception_constraint_name, '(.*)__(.*)', '\1');
      exception_sql_state := 'constraint';
    END IF;

    RAISE EXCEPTION '%', exception_message
      USING DETAIL = 'error', HINT = 'profiles.' || COALESCE(exception_sql_state,'error') || '.' || exception_column_name;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_profiles_view_instead
  INSTEAD OF UPDATE
  ON api.profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_profiles_view_instead();

GRANT SELECT, UPDATE ON api.profiles TO "admin";
GRANT SELECT, UPDATE ON api.profiles TO "user";

ALTER TABLE app.admin_profiles DROP COLUMN id;
ALTER TABLE app.admin_profiles RENAME COLUMN uuid TO id;
ALTER TABLE app.admin_profiles ADD PRIMARY KEY (id);

-- Recreate FKs
ALTER TABLE app.posts
ADD CONSTRAINT posts_original_post_id_fkey
FOREIGN KEY (original_post_id)
REFERENCES app.posts(id);

INSERT INTO public.schema_migrations (version) VALUES ('20191212123500');

COMMIT;

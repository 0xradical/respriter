BEGIN;

CREATE OR REPLACE FUNCTION public.if_admin(value anyelement) RETURNS anyelement AS $$
BEGIN
  IF current_user = 'admin' THEN
    RETURN value;
  ELSE
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.if_user_by_id(id bigint, value anyelement) RETURNS anyelement AS $$
BEGIN
  IF current_user = 'user' AND current_setting('request.jwt.claim.sub', true)::bigint = id THEN
    RETURN value;
  ELSE
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE VIEW api.user_accounts AS
  SELECT
    id,
    email,
    NULL::varchar                                                                           AS password,
    COALESCE( if_admin(reset_password_token),   if_user_by_id(id, reset_password_token)   ) AS reset_password_token,
    COALESCE( if_admin(reset_password_sent_at), if_user_by_id(id, reset_password_sent_at) ) AS reset_password_sent_at,
    COALESCE( if_admin(remember_created_at),    if_user_by_id(id, remember_created_at)    ) AS remember_created_at,
    COALESCE( if_admin(sign_in_count),          if_user_by_id(id, sign_in_count)          ) AS sign_in_count,
    COALESCE( if_admin(current_sign_in_at),     if_user_by_id(id, current_sign_in_at)     ) AS current_sign_in_at,
    COALESCE( if_admin(last_sign_in_at),        if_user_by_id(id, last_sign_in_at)        ) AS last_sign_in_at,
    COALESCE( if_admin(current_sign_in_ip),     if_user_by_id(id, current_sign_in_ip)     ) AS current_sign_in_ip,
    COALESCE( if_admin(last_sign_in_ip),        if_user_by_id(id, last_sign_in_ip)        ) AS last_sign_in_ip,
    COALESCE( if_admin(tracking_data),          if_user_by_id(id, tracking_data)          ) AS tracking_data,
    COALESCE( if_admin(confirmation_token),     if_user_by_id(id, confirmation_token)     ) AS confirmation_token,
    COALESCE( if_admin(confirmed_at),           if_user_by_id(id, confirmed_at)           ) AS confirmed_at,
    COALESCE( if_admin(confirmation_sent_at),   if_user_by_id(id, confirmation_sent_at)   ) AS confirmation_sent_at,
    COALESCE( if_admin(unconfirmed_email),      if_user_by_id(id, unconfirmed_email)      ) AS unconfirmed_email,
    COALESCE( if_admin(failed_attempts),        if_user_by_id(id, failed_attempts)        ) AS failed_attempts,
    COALESCE( if_admin(unlock_token),           if_user_by_id(id, unlock_token)           ) AS unlock_token,
    COALESCE( if_admin(locked_at),              if_user_by_id(id, locked_at)              ) AS locked_at,
    COALESCE( if_admin(destroyed_at),           if_user_by_id(id, destroyed_at)           ) AS destroyed_at,
    created_at,
    updated_at
  FROM app.user_accounts;

CREATE OR REPLACE VIEW api.profiles AS
  SELECT
    id,
    name,
    avatar,
    COALESCE( if_admin(date_of_birth),   if_user_by_id(user_account_id, date_of_birth)   ) AS date_of_birth,
    COALESCE( if_admin(user_account_id), if_user_by_id(user_account_id, user_account_id) ) AS user_account_id,
    COALESCE( if_admin(interests),       if_user_by_id(user_account_id, interests)       ) AS interests,
    COALESCE( if_admin(preferences),     if_user_by_id(user_account_id, preferences)     ) AS preferences
  FROM app.profiles;

CREATE OR REPLACE VIEW api.admin_accounts AS
  SELECT
    id,
    email,
    NULL::varchar AS password,
    reset_password_token,
    reset_password_sent_at,
    remember_created_at,
    sign_in_count,
    current_sign_in_at,
    last_sign_in_at,
    current_sign_in_ip,
    last_sign_in_ip,
    confirmation_token,
    confirmed_at,
    confirmation_sent_at,
    unconfirmed_email,
    failed_attempts,
    unlock_token,
    locked_at,
    created_at,
    updated_at,
    preferences
  FROM app.admin_accounts;

CREATE OR REPLACE FUNCTION triggers.api_user_accounts_view_instead() RETURNS trigger AS $$
BEGIN
  UPDATE app.user_accounts
  SET
    email              = NEW.email,
    encrypted_password = crypt(NEW.password, gen_salt('bf', 11))
  WHERE
    id = OLD.id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_user_accounts_view_instead
  INSTEAD OF UPDATE
  ON api.user_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_user_accounts_view_instead();

CREATE OR REPLACE FUNCTION triggers.api_profiles_view_instead() RETURNS trigger AS $$
BEGIN
  IF NEW.user_account_id != OLD.user_account_id THEN
    RAISE invalid_authorization_specification USING message = 'could not change user_account_id';
  END IF;

  UPDATE app.profiles
  SET
    name          = NEW.name,
    date_of_birth = NEW.date_of_birth,
    avatar        = NEW.avatar,
    interests     = NEW.interests,
    preferences   = NEW.preferences
  WHERE
    id = OLD.id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_profiles_view_instead
  INSTEAD OF UPDATE
  ON api.profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_profiles_view_instead();

CREATE OR REPLACE FUNCTION triggers.api_admin_accounts_view_instead() RETURNS trigger AS $$
BEGIN
  IF (TG_OP = 'UPDATE') THEN
    UPDATE app.admin_accounts
    SET
      email              = NEW.email,
      encrypted_password = crypt(NEW.password, gen_salt('bf', 11))
    WHERE
      id = OLD.id;
  ELSIF (TG_OP = 'INSERT') THEN
    INSERT INTO app.admin_accounts (
      email,
      encrypted_password
    ) VALUES (
      NEW.email,
      crypt(NEW.password, gen_salt('bf', 11))
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_admin_accounts_view_instead
  INSTEAD OF INSERT OR UPDATE
  ON api.admin_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_admin_accounts_view_instead();

GRANT SELECT, INSERT, UPDATE, DELETE ON api.admin_accounts TO "admin";
GRANT SELECT,         UPDATE         ON api.profiles       TO "admin";
GRANT SELECT,         UPDATE, DELETE ON api.user_accounts  TO "admin";

GRANT SELECT, UPDATE             ON app.profiles      TO "user";
GRANT SELECT, UPDATE, REFERENCES ON app.user_accounts TO "user";

GRANT SELECT, UPDATE ON api.profiles      TO "user";
GRANT SELECT, UPDATE ON api.user_accounts TO "user";

INSERT INTO public.schema_migrations (version) VALUES ('20190910140600');

COMMIT;

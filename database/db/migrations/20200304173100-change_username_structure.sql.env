-- "fixing" duplicates before running this
-- WITH roberta2 AS (
--   SELECT id FROM app.profiles WHERE LOWER(username) = 'roberta' LIMIT 1
-- )
-- UPDATE app.profiles SET username = 'roberta2' from roberta2 where app.profiles.id = roberta2.id;

-- WITH janaina2 AS (
--   SELECT id FROM app.profiles WHERE LOWER(username) = 'janaina' LIMIT 1
-- )
-- UPDATE app.profiles SET username = 'janaina2' from janaina2 where app.profiles.id = janaina2.id;
BEGIN;

CREATE DOMAIN app.username AS CITEXT;

ALTER DOMAIN app.username ADD CONSTRAINT username_format CHECK (NOT(value ~* '[^0-9a-zA-Z\.\-\_]'));
ALTER DOMAIN app.username ADD CONSTRAINT username_consecutive_dash CHECK (NOT(value ~* '--'));
ALTER DOMAIN app.username ADD CONSTRAINT username_consecutive_underline CHECK (NOT(value ~* '__'));
ALTER DOMAIN app.username ADD CONSTRAINT username_boundary_dash CHECK (NOT(value ~* '^-' OR value ~* '-$'));
ALTER DOMAIN app.username ADD CONSTRAINT username_boundary_underline CHECK (NOT(value ~* '^_' OR value ~* '_$'));
ALTER DOMAIN app.username ADD CONSTRAINT username_length_upper CHECK (LENGTH(value) <= 15);
ALTER DOMAIN app.username ADD CONSTRAINT username_length_lower CHECK (LENGTH(value) >= 5);
ALTER DOMAIN app.username ADD CONSTRAINT username_lowercased CHECK (value = LOWER(value));

ALTER TABLE app.profiles RENAME COLUMN username TO _username;
ALTER TABLE app.profiles ADD COLUMN username app.username;
CREATE UNIQUE INDEX profiles_username_idx ON app.profiles (username);

ALTER TABLE app.profiles ADD COLUMN username_changed_at TIMESTAMPTZ;

ALTER TABLE app.profiles ADD COLUMN created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL;
ALTER TABLE app.profiles ADD COLUMN updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL;

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TABLE app.used_usernames (
  id uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  profile_id uuid REFERENCES app.profiles(id) ON DELETE CASCADE NOT NULL,
  username app.username NOT NULL
);

CREATE UNIQUE INDEX used_usernames_username_idx ON app.used_usernames (username);
CREATE UNIQUE INDEX used_usernames_profile_id_username_idx ON app.used_usernames (profile_id, username);

CREATE OR REPLACE FUNCTION triggers.use_username() RETURNS trigger
AS $$
BEGIN
  IF (OLD.username IS NULL AND NEW.username IS NULL) THEN
    RAISE EXCEPTION '%', 'username update failed' USING DETAIL = 'username_cannot_be_null', HINT = 'username cannot be null';
  END IF;

  IF (TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.username IS NULL)) AND
     NEW.username IS NULL THEN
    RETURN NEW;
  END IF;

  IF TG_OP = 'UPDATE' AND OLD.username IS NOT NULL AND NEW.username IS NULL THEN
    RAISE EXCEPTION '%', 'username update failed' USING DETAIL = 'username_cannot_be_erased', HINT = 'username cannot be erased';
  END IF;

  IF ((TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.username IS NULL)) AND NEW.username IS NOT NULL) OR
     (TG_OP = 'UPDATE' AND OLD.username IS NOT NULL AND NEW.username IS NOT NULL AND OLD.username <> NEW.username) THEN

    IF TG_OP = 'UPDATE' AND OLD.username_changed_at IS NOT NULL AND
      (NOW() - OLD.username_changed_at < '15 days'::interval) THEN
      RAISE EXCEPTION '%', 'username update failed' USING DETAIL = 'username_change_within_update_threshold', HINT = 'username cannot be changed within 15 days';
    ELSE
      UPDATE app.profiles SET username_changed_at = NOW() WHERE id = NEW.id;
    END IF;

    INSERT INTO app.used_usernames (profile_id, username) VALUES (NEW.id, NEW.username);

    RETURN NEW;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER use_username
  AFTER INSERT OR UPDATE
  ON app.profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.use_username();

UPDATE app.profiles SET username = LOWER(_username)  WHERE NOT(_username ~* '[^0-9a-zA-Z\.\-\_]' OR
                                                              _username ~* '--' OR
                                                              _username ~* '__' OR
                                                              _username ~* '^-' OR
                                                              _username ~* '-$' OR
                                                              _username ~* '^_' OR
                                                              _username ~* '_$' OR
                                                              LENGTH(_username) > 15 OR
                                                              LENGTH(_username) < 5) AND username_changed_at IS NULL;

DROP VIEW api.profiles;

CREATE OR REPLACE VIEW api.profiles AS
  SELECT
    id,
    name,
    username,
    COALESCE(uploaded_avatar_url, oauth_avatar_url) AS avatar_url,
    COALESCE( if_admin(date_of_birth),   if_user_by_id(user_account_id, date_of_birth)   ) AS date_of_birth,
    user_account_id,
    COALESCE( if_admin(interests),       if_user_by_id(user_account_id, interests)       ) AS interests,
    COALESCE( if_admin(preferences),     if_user_by_id(user_account_id, preferences)     ) AS preferences
  FROM app.profiles;

CREATE OR REPLACE FUNCTION triggers.api_profiles_view_instead() RETURNS trigger AS $$
DECLARE
  exception_sql_state text;
  exception_column_name text;
  exception_constraint_name text;
  exception_table_name text;
  exception_message text;
  exception_detail text;
  exception_hint text;
BEGIN
  IF NEW.user_account_id != OLD.user_account_id THEN
    RAISE invalid_authorization_specification USING message = 'could not change user_account_id';
  END IF;

  IF if_admin(TRUE) IS NULL AND if_user_by_id(NEW.user_account_id, TRUE) IS NULL THEN
    RAISE insufficient_privilege;
  END IF;

  UPDATE app.profiles
  SET
    name                = NEW.name,
    date_of_birth       = NEW.date_of_birth,
    interests           = NEW.interests,
    preferences         = NEW.preferences,
    username            = NEW.username
  WHERE
    id = OLD.id;

  RETURN NEW;
EXCEPTION
  WHEN insufficient_privilege THEN
    RAISE;
  WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS exception_message = MESSAGE_TEXT,
                          exception_detail = PG_EXCEPTION_DETAIL,
                          exception_hint = PG_EXCEPTION_HINT,
                          exception_sql_state = RETURNED_SQLSTATE,
                          exception_column_name = COLUMN_NAME,
                          exception_constraint_name = CONSTRAINT_NAME,
                          exception_table_name = TABLE_NAME;

  IF exception_detail = 'error' THEN
    RAISE EXCEPTION '%', exception_message
      USING DETAIL = exception_detail, HINT = exception_hint;
  ELSE
    -- constraint
    IF exception_sql_state IN ('23514', '23505') AND exception_constraint_name IS NOT NULL THEN
      exception_column_name := REGEXP_REPLACE(exception_constraint_name, '(.*)__(.*)', '\1');
      exception_sql_state := 'constraint';

      exception_detail := (
        CASE exception_column_name
          WHEN 'used_usernames_username_idx' THEN '010001'
          WHEN 'used_usernames_profile_id_username_idx'  THEN '010002'
          ELSE '010000'
        END
      );

    END IF;

    RAISE EXCEPTION '%', exception_message
      USING DETAIL = COALESCE(exception_detail, 'error'), HINT = exception_hint;

  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_profiles_view_instead
  INSTEAD OF UPDATE
  ON api.profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_profiles_view_instead();

DROP TRIGGER create_profile_for_user_account ON app.user_accounts;
DROP FUNCTION triggers.create_profile_for_user_account;

GRANT SELECT, UPDATE ON api.profiles TO "admin";
GRANT SELECT, UPDATE ON api.profiles TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE ON app.used_usernames TO "admin";
GRANT SELECT, INSERT                 ON app.used_usernames TO "user";
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "admin";
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "user";

INSERT INTO public.schema_migrations (version) VALUES ('20200304173100');

COMMIT;
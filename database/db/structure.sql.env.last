BEGIN;

CREATE SCHEMA IF NOT EXISTS api;
CREATE SCHEMA IF NOT EXISTS app;
CREATE SCHEMA IF NOT EXISTS jwt;
CREATE SCHEMA IF NOT EXISTS triggers;
CREATE SCHEMA IF NOT EXISTS settings;
CREATE SCHEMA IF NOT EXISTS subsets;
CREATE SCHEMA IF NOT EXISTS bi;

CREATE EXTENSION IF NOT EXISTS citext      WITH SCHEMA public;
CREATE EXTENSION IF NOT EXISTS plpgsql     WITH SCHEMA pg_catalog;
CREATE EXTENSION IF NOT EXISTS pgcrypto    WITH SCHEMA public;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;
CREATE EXTENSION IF NOT EXISTS unaccent    WITH SCHEMA public;

CREATE TYPE app.authority_confirmation_method AS ENUM (
  'dns',
  'html'
);

CREATE TYPE app.authority_confirmation_status AS ENUM (
  'unconfirmed',
  'confirming',
  'confirmed',
  'failed',
  'deleted'
);

CREATE TYPE app.category AS ENUM (
  'arts_and_design',
  'business',
  'marketing',
  'computer_science',
  'data_science',
  'language_and_communication',
  'life_sciences',
  'math_and_logic',
  'personal_development',
  'physical_science_and_engineering',
  'social_science',
  'health_and_fitness',
  'social_sciences'
);

CREATE TYPE app.contact_reason AS ENUM (
  'customer_support',
  'bug_report',
  'feature_suggestion',
  'commercial_and_partnerships',
  'manual_profile_claim',
  'other'
);

CREATE TYPE app.crawler_status AS ENUM (
  'unverified', 'pending', 'broken', 'active', 'deleted'
);

CREATE TYPE app.iso639_code AS ENUM (
  'ar-EG',
  'ar-JO',
  'ar-LB',
  'ar-SY',
  'de-DE',
  'en-AU',
  'en-BZ',
  'en-CA',
  'en-GB',
  'en-IN',
  'en-NZ',
  'en-US',
  'en-ZA',
  'es-AR',
  'es-BO',
  'es-CL',
  'es-CO',
  'es-EC',
  'es-ES',
  'es-GT',
  'es-MX',
  'es-PE',
  'es-VE',
  'fr-BE',
  'fr-CH',
  'fr-FR',
  'it-IT',
  'jp-JP',
  'nl-BE',
  'nl-NL',
  'pl-PL',
  'pt-BR',
  'pt-PT',
  'sv-SV',
  'zh-CN',
  'zh-CMN',
  'zh-HANS',
  'zh-HANT',
  'zh-TW',
  'af',
  'am',
  'ar',
  'az',
  'be',
  'bg',
  'bn',
  'bo',
  'bs',
  'ca',
  'co',
  'cs',
  'cy',
  'da',
  'de',
  'el',
  'en',
  'eo',
  'es',
  'et',
  'eu',
  'fa',
  'fi',
  'fil',
  'fr',
  'fy',
  'ga',
  'gd',
  'gl',
  'gu',
  'ha',
  'he',
  'hi',
  'hr',
  'ht',
  'hu',
  'hy',
  'id',
  'ig',
  'is',
  'it',
  'iw',
  'ja',
  'jp',
  'ka',
  'kk',
  'km',
  'kn',
  'ko',
  'ku',
  'ky',
  'lb',
  'lo',
  'lt',
  'lv',
  'mg',
  'mi',
  'mk',
  'ml',
  'mn',
  'mr',
  'ms',
  'mt',
  'my',
  'nb',
  'ne',
  'nl',
  'no',
  'pa',
  'pl',
  'ps',
  'pt',
  'ro',
  'ru',
  'rw',
  'sd',
  'si',
  'sk',
  'sl',
  'sn',
  'so',
  'sq',
  'sr',
  'st',
  'sv',
  'sw',
  'ta',
  'te',
  'tg',
  'th',
  'tl',
  'tr',
  'tt',
  'uk',
  'ur',
  'uz',
  'vi',
  'xh',
  'yi',
  'yo',
  'zh',
  'zu'
);

CREATE TYPE app.iso3166_1_alpha2_code AS ENUM (
  'AD','AE','AF','AG','AI','AL','AM','AO','AQ','AR','AS','AT','AU','AW','AX','AZ','BA','BB','BD','BE','BF','BG','BH','BI','BJ','BL','BM','BN','BO','BQ','BR','BS','BT','BV','BW','BY','BZ','CA','CC','CD','CF','CG','CH','CI','CK','CL','CM','CN','CO','CR','CU','CV','CW','CX','CY','CZ','DE','DJ','DK','DM','DO','DZ','EC','EE','EG','EH','ER','ES','ET','FI','FJ','FK','FM','FO','FR','GA','GB','GD','GE','GF','GG','GH','GI','GL','GM','GN','GP','GQ','GR','GS','GT','GU','GW','GY','HK','HM','HN','HR','HT','HU','ID','IE','IL','IM','IN','IO','IQ','IR','IS','IT','JE','JM','JO','JP','KE','KG','KH','KI','KM','KN','KP','KR','KW','KY','KZ','LA','LB','LC','LI','LK','LR','LS','LT','LU','LV','LY','MA','MC','MD','ME','MF','MG','MH','MK','ML','MM','MN','MO','MP','MQ','MR','MS','MT','MU','MV','MW','MX','MY','MZ','NA','NC','NE','NF','NG','NI','NL','NO','NP','NR','NU','NZ','OM','PA','PE','PF','PG','PH','PK','PL','PM','PN','PR','PS','PT','PW','PY','QA','RE','RO','RS','RU','RW','SA','SB','SC','SD','SE','SG','SH','SI','SJ','SK','SL','SM','SN','SO','SR','SS','ST','SV','SX','SY','SZ','TC','TD','TF','TG','TH','TJ','TK','TL','TM','TN','TO','TR','TT','TV','TW','TZ','UA','UG','UM','US','UY','UZ','VA','VC','VE','VG','VI','VN','VU','WF','WS','XK','YE','YT','ZA','ZM','ZW'
);

CREATE TYPE app.iso639_1_alpha2_code AS ENUM (
  'aa',
  'ab',
  'ae',
  'af',
  'ak',
  'am',
  'an',
  'ar',
  'as',
  'av',
  'ay',
  'az',
  'ba',
  'be',
  'bg',
  'bh',
  'bi',
  'bm',
  'bn',
  'bo',
  'br',
  'bs',
  'ca',
  'ce',
  'ch',
  'co',
  'cr',
  'cs',
  'cu',
  'cv',
  'cy',
  'da',
  'de',
  'dv',
  'dz',
  'ee',
  'el',
  'en',
  'eo',
  'es',
  'et',
  'eu',
  'fa',
  'ff',
  'fi',
  'fj',
  'fo',
  'fr',
  'fy',
  'ga',
  'gd',
  'gl',
  'gn',
  'gu',
  'gv',
  'ha',
  'he',
  'hi',
  'ho',
  'hr',
  'ht',
  'hu',
  'hy',
  'hz',
  'ia',
  'id',
  'ie',
  'ig',
  'ii',
  'ik',
  'io',
  'is',
  'it',
  'iu',
  'ja',
  'jv',
  'ka',
  'kg',
  'ki',
  'kj',
  'kk',
  'kl',
  'km',
  'kn',
  'ko',
  'kr',
  'ks',
  'ku',
  'kv',
  'kw',
  'ky',
  'la',
  'lb',
  'lg',
  'li',
  'ln',
  'lo',
  'lt',
  'lu',
  'lv',
  'mg',
  'mh',
  'mi',
  'mk',
  'ml',
  'mn',
  'mr',
  'ms',
  'mt',
  'my',
  'na',
  'nb',
  'nd',
  'ne',
  'ng',
  'nl',
  'nn',
  'no',
  'nr',
  'nv',
  'ny',
  'oc',
  'oj',
  'om',
  'or',
  'os',
  'pa',
  'pi',
  'pl',
  'ps',
  'pt',
  'qu',
  'rm',
  'rn',
  'ro',
  'ru',
  'rw',
  'sa',
  'sc',
  'sd',
  'se',
  'sg',
  'si',
  'sk',
  'sl',
  'sm',
  'sn',
  'so',
  'sq',
  'sr',
  'ss',
  'st',
  'su',
  'sv',
  'sw',
  'ta',
  'te',
  'tg',
  'th',
  'ti',
  'tk',
  'tl',
  'tn',
  'to',
  'tr',
  'ts',
  'tt',
  'tw',
  'ty',
  'ug',
  'uk',
  'ur',
  'uz',
  've',
  'vi',
  'vo',
  'wa',
  'wo',
  'xh',
  'yi',
  'yo',
  'za',
  'zh',
  'zu'
);

CREATE TYPE app.level AS ENUM (
  'beginner',
  'intermediate',
  'advanced'
);

CREATE TYPE app.locale AS (
  language  app.iso639_1_alpha2_code,
  country   app.iso3166_1_alpha2_code
);

CREATE TYPE app.locale_status AS ENUM (
  'empty_audio',
  'manually_overriden',
  'mismatch',
  'multiple_countries',
  'multiple_languages',
  'not_identifiable',
  'ok'
);

CREATE TYPE app.pace AS ENUM (
  'self_paced',
  'instructor_paced',
  'live_class'
);

CREATE TYPE app.payment_source AS ENUM (
  'impact_radius',
  'awin',
  'rakuten',
  'share_a_sale',
  'commission_junction',
  'zanox'
);

CREATE TYPE app.payment_status AS ENUM (
  'open',
  'locked',
  'paid'
);

CREATE TYPE app.post_status AS ENUM (
  'void',
  'draft',
  'published',
  'disabled'
);

CREATE TYPE app.preview_course_status AS ENUM (
  'pending', 'failed', 'succeeded'
);

CREATE TYPE app.provider_logo AS (
  id uuid,
  provider_id uuid,
  file varchar,
  user_account_id bigint,
  created_at timestamptz,
  updated_at timestamptz,
  fetch_url text,
  upload_url text,
  file_content_type varchar
);

CREATE TYPE app.sitemap AS (
  id     uuid,
  status varchar,
  url    varchar,
  type   varchar
);

CREATE TYPE app.source AS ENUM (
  'api',
  'import',
  'admin'
);

CREATE DOMAIN app.username AS CITEXT;

ALTER DOMAIN app.username ADD CONSTRAINT username__format CHECK (NOT(value ~* '[^0-9a-zA-Z\.\-\_]'));
ALTER DOMAIN app.username ADD CONSTRAINT username__consecutive_dash CHECK (NOT(value ~* '--'));
ALTER DOMAIN app.username ADD CONSTRAINT username__consecutive_underline CHECK (NOT(value ~* '__'));
ALTER DOMAIN app.username ADD CONSTRAINT username__boundary_dash CHECK (NOT(value ~* '^-' OR value ~* '-$'));
ALTER DOMAIN app.username ADD CONSTRAINT username__boundary_underline CHECK (NOT(value ~* '^_' OR value ~* '_$'));
ALTER DOMAIN app.username ADD CONSTRAINT username__length_upper CHECK (LENGTH(value) <= 15);
ALTER DOMAIN app.username ADD CONSTRAINT username__length_lower CHECK (LENGTH(value) >= 5);
ALTER DOMAIN app.username ADD CONSTRAINT username__lowercased CHECK (value = LOWER(value));

CREATE TABLE app.admin_accounts (
  id                     bigserial    PRIMARY KEY,
  email                  varchar      DEFAULT ''::varchar NOT NULL,
  encrypted_password     varchar      DEFAULT ''::varchar NOT NULL,
  reset_password_token   varchar,
  reset_password_sent_at timestamptz,
  remember_created_at    timestamptz,
  sign_in_count          integer      DEFAULT 0           NOT NULL,
  current_sign_in_at     timestamptz,
  last_sign_in_at        timestamptz,
  current_sign_in_ip     inet,
  last_sign_in_ip        inet,
  confirmation_token     varchar,
  confirmed_at           timestamptz,
  confirmation_sent_at   timestamptz,
  unconfirmed_email      varchar,
  failed_attempts        integer      DEFAULT 0           NOT NULL,
  unlock_token           varchar,
  locked_at              timestamptz,
  created_at             timestamptz  DEFAULT NOW()       NOT NULL,
  updated_at             timestamptz  DEFAULT NOW()       NOT NULL,
  preferences            jsonb        DEFAULT '{}'::jsonb
);

CREATE TABLE app.admin_profiles (
  id                uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  name              varchar,
  bio               text,
  preferences       jsonb,
  admin_account_id  bigint      REFERENCES app.admin_accounts(id) ON DELETE CASCADE,
  created_at        timestamptz DEFAULT NOW() NOT NULL,
  updated_at        timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.user_accounts (
  id                      bigserial    PRIMARY KEY,
  email                   varchar      DEFAULT ''::varchar NOT NULL,
  encrypted_password      varchar      DEFAULT ''::varchar NOT NULL,
  reset_password_token    varchar,
  reset_password_sent_at  timestamptz,
  remember_created_at     timestamptz,
  sign_in_count           integer      DEFAULT 0           NOT NULL,
  current_sign_in_at      timestamptz,
  last_sign_in_at         timestamptz,
  current_sign_in_ip      inet,
  last_sign_in_ip         inet,
  tracking_data           json         DEFAULT '{}'::json  NOT NULL,
  confirmation_token      varchar,
  confirmed_at            timestamptz,
  confirmation_sent_at    timestamptz,
  unconfirmed_email       varchar,
  failed_attempts         integer      DEFAULT 0           NOT NULL,
  unlock_token            varchar,
  locked_at               timestamptz,
  destroyed_at            timestamptz,
  autogen_email_for_oauth boolean DEFAULT false NOT NULL,
  created_at              timestamptz  DEFAULT NOW()       NOT NULL,
  updated_at              timestamptz  DEFAULT NOW()       NOT NULL
);

CREATE TABLE app.certificates (
  id              uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  user_account_id bigint      REFERENCES app.user_accounts(id),
  file            varchar     CONSTRAINT valid_file_format CHECK ( lower(file) ~ '.(gif|jpg|jpeg|png|pdf)$' ),
  created_at      timestamptz DEFAULT NOW() NOT NULL,
  updated_at      timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.contacts (
  id         bigserial   PRIMARY KEY,
  name       varchar,
  email      varchar,
  subject    varchar,
  reason     app.contact_reason,
  message    text,
  created_at timestamptz DEFAULT NOW() NOT NULL,
  updated_at timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.providers (
  id                             uuid         DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  old_id                         bigserial,
  name                           public.citext,
  name_dirty                     boolean      DEFAULT true NOT NULL,
  name_changed_at                timestamptz  CHECK ((name_dirty) OR (NOT name_dirty AND name_changed_at IS NOT NULL)),
  description                    text,
  slug                           varchar,
  url                            varchar,
  afn_url_template               varchar,
  published                      boolean      DEFAULT false,
  published_at                   timestamptz,
  created_at                     timestamptz  DEFAULT NOW() NOT NULL,
  updated_at                     timestamptz  DEFAULT NOW() NOT NULL,
  encoded_deep_linking           boolean      DEFAULT false,
  featured_on_footer             boolean      DEFAULT false,
  ignore_robots_noindex_rule_for app.locale[] DEFAULT '{}'::app.locale[],
  ignore_robots_noindex_rule     boolean      DEFAULT false
);

CREATE TABLE app.courses (
  id                                      uuid                    DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  global_sequence                         integer,
  name                                    varchar,
  description                             text,
  slug                                    varchar,
  url                                     varchar,
  url_md5                                 varchar,
  duration_in_hours                       numeric,
  price                                   numeric,
  rating                                  numeric,
  relevance                               integer                 DEFAULT 0,
  region                                  varchar,
  audio                                   text[]                  DEFAULT '{}',
  subtitles                               text[]                  DEFAULT '{}',
  published                               boolean                 DEFAULT true,
  stale                                   boolean                 DEFAULT false,
  category                                app.category,
  provider_id                             uuid                    REFERENCES app.providers(id),
  created_at                              timestamptz             DEFAULT NOW() NOT NULL,
  updated_at                              timestamptz             DEFAULT NOW() NOT NULL,
  dataset_sequence                        integer,
  resource_sequence                       integer,
  tags                                    text[]                  DEFAULT '{}',
  video                                   jsonb,
  source                                  app.source              DEFAULT 'api',
  pace                                    app.pace,
  certificate                             jsonb                   DEFAULT '{}',
  pricing_models                          jsonb                   DEFAULT '[]',
  offered_by                              jsonb                   DEFAULT '[]',
  syllabus                                text,
  effort                                  integer,
  enrollments_count                       integer                 DEFAULT 0,
  free_content                            boolean                 DEFAULT false,
  paid_content                            boolean                 DEFAULT true,
  level                                   app.level[]             DEFAULT '{}',
  __provider_name__                       varchar,
  __source_schema__                       jsonb,
  instructors                             jsonb                   DEFAULT '[]',
  curated_tags                            varchar[]               DEFAULT '{}',
  refinement_tags                         varchar[],
  up_to_date_id                           uuid                    REFERENCES app.courses(id) ON DELETE SET NULL,
  last_execution_id                       uuid,
  schema_version                          varchar,
  locale                                  app.locale,
  locale_status                           app.locale_status,
  ignore_robots_noindex_rule_for          app.locale[]            DEFAULT '{}',
  ignore_robots_noindex_rule              boolean                 DEFAULT false,
  canonical_subdomain                     varchar
);

CREATE TABLE app.tracked_searches (
  id            uuid        DEFAULT public.uuid_generate_v1() PRIMARY KEY,
  version       varchar,
  action        varchar,
  request       jsonb,
  results       jsonb,
  tracked_data  jsonb,
  created_at    timestamptz DEFAULT NOW() NOT NULL,
  updated_at    timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.enrollments (
  id                uuid        DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  user_account_id   bigint      REFERENCES app.user_accounts(id),
  course_id         uuid        REFERENCES app.courses(id),
  provider_id       uuid        REFERENCES app.providers(id),
  tracked_url       varchar,
  description       text,
  user_rating       numeric,
  tracked_search_id uuid        REFERENCES app.tracked_searches(id),
  tracking_data     jsonb       DEFAULT '{}'::jsonb,
  tracking_cookies  jsonb       DEFAULT '{}'::jsonb,
  created_at        timestamptz DEFAULT NOW() NOT NULL,
  updated_at        timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.tracked_actions (
  id               uuid                DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  enrollment_id    uuid                REFERENCES app.enrollments(id),
  status           app.payment_status,
  source           app.payment_source,
  created_at       timestamptz         DEFAULT NOW() NOT NULL,
  updated_at       timestamptz         DEFAULT NOW() NOT NULL,
  sale_amount      numeric,
  earnings_amount  numeric,
  payload          jsonb,
  compound_ext_id  varchar,
  ext_click_date   timestamptz,
  ext_id           varchar,
  ext_sku_id       varchar,
  ext_product_name varchar
);

CREATE TABLE app.course_reviews (
  id                uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  user_account_id   bigint REFERENCES app.user_accounts(id) ON DELETE CASCADE,
  tracked_action_id uuid REFERENCES app.tracked_actions(id) ON DELETE CASCADE,
  rating            numeric(1,0),
  completed         boolean,
  feedback          varchar,
  state             varchar NOT NULL DEFAULT 'pending',
  created_at        timestamptz  DEFAULT NOW() NOT NULL,
  updated_at        timestamptz  DEFAULT NOW() NOT NULL,
  CONSTRAINT rating__greater_than CHECK (rating >= 1),
  CONSTRAINT rating__less_than CHECK (rating <= 5),
  CONSTRAINT state__inclusion CHECK (state IN ('pending','accessed','submitted'))
);

CREATE TABLE app.provider_crawlers (
  id               uuid               DEFAULT    public.uuid_generate_v1() PRIMARY KEY,
  user_agent_token uuid               DEFAULT    public.uuid_generate_v4() NOT NULL,
  provider_id      uuid               REFERENCES app.providers(id)         ON DELETE CASCADE,
  published        boolean            DEFAULT    false                     NOT NULL,
  scheduled        boolean            DEFAULT    false                     NOT NULL,
  created_at       timestamptz        DEFAULT    NOW()                     NOT NULL,
  updated_at       timestamptz        DEFAULT    NOW()                     NOT NULL,
  status           app.crawler_status DEFAULT    'unverified'              NOT NULL,
  user_account_ids bigint[]           DEFAULT    '{}'                      NOT NULL,
  sitemaps         app.sitemap[]      DEFAULT    '{}'                      NOT NULL,
  version          varchar,
  settings         jsonb,
  urls             varchar[]          DEFAULT    '{}'                      NOT NULL
);

CREATE TABLE app.crawler_domains (
  id                            uuid                              DEFAULT    public.uuid_generate_v1() PRIMARY KEY,
  provider_crawler_id           uuid                              REFERENCES app.provider_crawlers(id) ON DELETE CASCADE,
  authority_confirmation_status app.authority_confirmation_status DEFAULT    'unconfirmed'                               NOT NULL,
  authority_confirmation_token  varchar,
  authority_confirmation_method app.authority_confirmation_method DEFAULT    'dns'                                       NOT NULL,
  created_at                    timestamptz                       DEFAULT    NOW()                                       NOT NULL,
  updated_at                    timestamptz                       DEFAULT    NOW()                                       NOT NULL,
  domain                        varchar                                                                                  NOT NULL,
  authority_confirmation_salt   varchar

  CONSTRAINT domain__must_be_a_domain CHECK ( domain ~ '^([a-z0-9\-\_]+\.)+[a-z]+$' )
);

CREATE TABLE app.crawling_events (
  id                  uuid        DEFAULT    public.uuid_generate_v1() PRIMARY KEY,
  provider_crawler_id uuid        REFERENCES app.provider_crawlers(id) ON DELETE CASCADE,
  execution_id        uuid                                             NOT NULL,
  created_at          timestamptz DEFAULT    NOW()                     NOT NULL,
  updated_at          timestamptz DEFAULT    NOW()                     NOT NULL,
  sequence            bigint,
  type                varchar                                          NOT NULL,
  data                jsonb
);

CREATE TABLE app.direct_uploads (
  id              uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  user_account_id bigint      REFERENCES app.user_accounts(id),
  file            varchar     CONSTRAINT valid_file_format CHECK ( LOWER(file) ~ '.(gif|jpg|jpeg|png|pdf|svg)$' ),
  created_at      timestamptz DEFAULT NOW() NOT NULL,
  updated_at      timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.favorites (
  id              bigserial   PRIMARY KEY,
  user_account_id bigint      REFERENCES app.user_accounts(id),
  course_id       uuid        REFERENCES app.courses(id),
  created_at      timestamptz DEFAULT NOW() NOT NULL,
  updated_at      timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.images (
  id             bigserial   PRIMARY KEY,
  caption        varchar,
  file           varchar,
  pos            integer     DEFAULT 0,
  imageable_type varchar,
  imageable_id   uuid,
  created_at     timestamptz DEFAULT NOW() NOT NULL,
  updated_at     timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.landing_pages (
  id            bigserial   PRIMARY KEY,
  slug          public.citext,
  template      varchar,
  meta_html     text,
  html          jsonb       DEFAULT '{}'::jsonb,
  body_html     text,
  created_at    timestamptz DEFAULT NOW() NOT NULL,
  updated_at    timestamptz DEFAULT NOW() NOT NULL,
  data          jsonb       DEFAULT '{}'::jsonb,
  erb_template  text,
  layout        varchar
);

CREATE TABLE app.oauth_accounts (
  id              bigserial   PRIMARY KEY,
  provider        varchar,
  uid             varchar,
  raw_data        jsonb       DEFAULT '{}'::jsonb NOT NULL,
  user_account_id bigint      REFERENCES app.user_accounts(id) ON DELETE CASCADE,
  created_at      timestamptz DEFAULT NOW() NOT NULL,
  updated_at      timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.orphaned_profiles (
  id                                    uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  user_account_id                       bigint REFERENCES app.user_accounts(id) ON DELETE CASCADE,
  name                                  varchar(75) NOT NULL,
  country                               varchar(3),
  short_bio                             varchar(200),
  long_bio                              text,
  email                                 varchar(320),
  website                               varchar,
  avatar_url                            varchar,
  public_profiles                       jsonb DEFAULT '{}'::jsonb,
  languages                             varchar[] DEFAULT '{}',
  course_ids                            uuid[] DEFAULT '{}',
  state                                 varchar(20) DEFAULT 'disabled',
  slug                                  varchar,
  claimable_emails                      varchar[] DEFAULT '{}',
  claimable_public_profiles             jsonb DEFAULT '{}'::jsonb,
  claim_code                            varchar(64),
  claim_code_expires_at                 timestamptz,
  claimed_at                            timestamptz,
  claimed_by                            varchar,
  teaching_subjects                     varchar[] DEFAULT '{}',
  teaching_at                           varchar[] DEFAULT '{}',
  created_at                            timestamptz DEFAULT NOW() NOT NULL,
  updated_at                            timestamptz DEFAULT NOW() NOT NULL,
  marked_as_destroyed_at                timestamptz,
  ignore_robots_noindex_rule_for        app.locale[] DEFAULT '{}'::app.locale[],
  ignore_robots_noindex_rule            boolean DEFAULT false
  CONSTRAINT state__inclusion CHECK (state IN ('disabled','enabled'))
);

CREATE TABLE app.posts (
  id                  uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  slug                varchar,
  title               varchar,
  body                text,
  tags                varchar[]       DEFAULT '{}'::varchar[],
  meta                jsonb           DEFAULT '"{\"title\": \"\", \"description\": \"\"}"'::jsonb,
  locale              app.iso639_code DEFAULT 'en'::app.iso639_code,
  status              app.post_status DEFAULT 'draft'::app.post_status,
  content_fingerprint varchar,
  published_at        timestamptz,
  content_changed_at  timestamptz,
  admin_account_id    bigint          REFERENCES app.admin_accounts(id),
  created_at          timestamptz     DEFAULT NOW() NOT NULL,
  updated_at          timestamptz     DEFAULT NOW() NOT NULL,
  original_post_id    uuid            REFERENCES app.posts(id),
  use_cover_image     boolean         DEFAULT false
);

CREATE TABLE app.post_relations (
  id            uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  relation_type varchar NOT NULL,
  relation_id   uuid NOT NULL,
  post_id       uuid REFERENCES app.posts(id)
);

CREATE TABLE app.preview_courses (
  id                  uuid                      DEFAULT    public.uuid_generate_v1() PRIMARY KEY,
  status              app.preview_course_status DEFAULT    'pending',
  name                varchar,
  description         text,
  slug                varchar,
  url                 varchar       NOT NULL,
  url_md5             varchar,
  duration_in_hours   numeric,
  price               numeric,
  rating              numeric,
  relevance           integer       DEFAULT 0,
  region              varchar,
  audio               text[]        DEFAULT '{}'::text[],
  subtitles           text[]        DEFAULT '{}'::text[],
  published           boolean       DEFAULT true,
  stale               boolean       DEFAULT false,
  category            app.category,
  tags                text[]        DEFAULT '{}'::text[],
  video               jsonb,
  source              app.source    DEFAULT 'api'::app.source,
  pace                app.pace,
  certificate         jsonb         DEFAULT '{}'::jsonb,
  pricing_models      jsonb         DEFAULT '[]'::jsonb,
  offered_by          jsonb         DEFAULT '[]'::jsonb,
  syllabus            text,
  effort              integer,
  enrollments_count   integer       DEFAULT 0,
  free_content        boolean       DEFAULT false,
  paid_content        boolean       DEFAULT true,
  level               app.level[]   DEFAULT '{}'::app.level[],
  __provider_name__   varchar,
  __source_schema__   jsonb,
  __indexed_json__    jsonb,
  instructors         jsonb         DEFAULT '[]'::jsonb,
  curated_tags        varchar[]     DEFAULT '{}'::varchar[],
  refinement_tags     varchar[],
  provider_id         uuid          REFERENCES app.providers(id),
  provider_crawler_id uuid          REFERENCES app.provider_crawlers(id)     ON DELETE CASCADE,
  created_at          timestamptz   DEFAULT    NOW()                         NOT NULL,
  updated_at          timestamptz   DEFAULT    NOW()                         NOT NULL,
  expired_at          timestamptz   DEFAULT    NOW() + INTERVAL '20 MINUTES' NOT NULL
);

CREATE TABLE app.preview_course_images (
  id             uuid   DEFAULT    public.uuid_generate_v1() PRIMARY KEY,
  kind           varchar,
  file           varchar,
  preview_course_id uuid REFERENCES app.preview_courses(id),
  created_at     timestamptz DEFAULT NOW() NOT NULL,
  updated_at     timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.profiles (
  id                  uuid          DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  name                varchar,
  _name               varchar,
  username            app.username,
  _username           varchar       CONSTRAINT username__format CHECK (_username ~* '^\w{5,15}$'),
  username_changed_at timestamptz,
  date_of_birth       date,
  oauth_avatar_url    varchar,
  uploaded_avatar_url varchar,
  instructor          boolean     DEFAULT false,
  long_bio            varchar,
  public              boolean     DEFAULT true,
  website             varchar,
  country             app.iso3166_1_alpha2_code,
  course_ids          uuid[]      DEFAULT '{}'::uuid[],
  short_bio           varchar     CONSTRAINT short_bio__length CHECK (LENGTH(short_bio) <= 60),
  public_profiles     jsonb       DEFAULT '{}'::jsonb,
  social_profiles     jsonb       DEFAULT '{}'::jsonb,
  elearning_profiles  jsonb       DEFAULT '{}'::jsonb,
  teaching_subjects   varchar[]   DEFAULT '{}',
  user_account_id     bigint      REFERENCES app.user_accounts(id) ON DELETE CASCADE,
  interests           text[]      DEFAULT '{}'::text[],
  preferences         jsonb       DEFAULT '{}'::jsonb,
  created_at          timestamptz DEFAULT NOW() NOT NULL,
  updated_at          timestamptz DEFAULT NOW() NOT NULL
);

CREATE TABLE app.used_usernames (
  id uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  profile_id uuid REFERENCES app.profiles(id) ON DELETE CASCADE NOT NULL,
  username app.username NOT NULL
);

CREATE TABLE app.promo_accounts (
  id                uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  user_account_id   bigint REFERENCES app.user_accounts(id) ON DELETE CASCADE CONSTRAINT cntr_promo_accounts_user_account_id UNIQUE,
  certificate_id    uuid REFERENCES app.certificates(id) ON DELETE CASCADE,
  price             numeric(6,2) NOT NULL,
  purchase_date     date  NOT NULL CONSTRAINT purchase_date__less_than CHECK (purchase_date < NOW()),
  order_id          varchar NOT NULL,
  paypal_account    varchar NOT NULL,
  state             varchar NOT NULL DEFAULT 'initial',
  state_info        varchar,
  old_self          json NOT NULL default '{}'::json,
  created_at        timestamptz  DEFAULT NOW() NOT NULL,
  updated_at        timestamptz  DEFAULT NOW() NOT NULL,
  CONSTRAINT price__greater_than CHECK (price >= 0),
  CONSTRAINT price__less_than CHECK (price <= 5000),
  CONSTRAINT paypal_account__email CHECK (paypal_account ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'),
  CONSTRAINT state__inclusion CHECK (state IN ('initial','pending','locked','rejected','approved'))
);

CREATE TABLE app.promo_account_logs (
  id uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  promo_account_id uuid REFERENCES app.promo_accounts(id) ON DELETE CASCADE,
  old jsonb DEFAULT '{}'::jsonb,
  new jsonb DEFAULT '{}'::jsonb,
  role varchar NOT NULL
);

CREATE TABLE app.provider_logos (
  id               uuid DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  direct_upload_id uuid REFERENCES app.direct_uploads(id) NOT NULL,
  provider_id      uuid REFERENCES app.providers(id) NOT NULL
);

CREATE TABLE app.slug_histories (
  id         uuid        DEFAULT public.uuid_generate_v4() PRIMARY KEY,
  course_id  uuid        REFERENCES app.courses(id) ON DELETE CASCADE,
  created_at timestamptz DEFAULT NOW() NOT NULL,
  updated_at timestamptz DEFAULT NOW() NOT NULL,
  slug       varchar                   NOT NULL
);

CREATE TABLE app.subscriptions (
  id              uuid        DEFAULT public.uuid_generate_v4() UNIQUE NOT NULL PRIMARY KEY,
  digest          boolean     DEFAULT true NOT NULL,
  newsletter      boolean     DEFAULT true NOT NULL,
  promotions      boolean     DEFAULT true NOT NULL,
  recommendations boolean     DEFAULT true NOT NULL,
  reports         boolean     DEFAULT true NOT NULL,
  unsubscribe_reasons jsonb   DEFAULT '{}'::jsonb,
  unsubscribed_at timestamptz,
  profile_id      uuid        REFERENCES app.profiles(id),
  created_at      timestamptz  DEFAULT NOW() NOT NULL
);

CREATE TABLE IF NOT EXISTS public.ar_internal_metadata (
  key        varchar     PRIMARY KEY,
  value      varchar,
  created_at timestamptz DEFAULT NOW() NOT NULL,
  updated_at timestamptz DEFAULT NOW() NOT NULL
);

CREATE FUNCTION public.que_validate_tags(tags_array jsonb) RETURNS boolean
    LANGUAGE sql
    AS $$
  SELECT bool_and(
    jsonb_typeof(value) = 'string'
    AND
    char_length(value::text) <= 100
  )
  FROM jsonb_array_elements(tags_array)
$$;

CREATE TABLE public.que_jobs (
  id                   BIGSERIAL    PRIMARY KEY,

  priority             smallint     DEFAULT 100 NOT NULL,
  run_at               timestamptz  DEFAULT NOW() NOT NULL,
  job_class            text         NOT NULL,
  error_count          integer      DEFAULT 0 NOT NULL,
  last_error_message   text,
  queue                text         DEFAULT 'default'::text NOT NULL,
  last_error_backtrace text,
  finished_at          timestamptz,
  expired_at           timestamptz,
  args                 jsonb        DEFAULT '[]'::jsonb NOT NULL,
  data                 jsonb        DEFAULT '{}'::jsonb NOT NULL,

  CONSTRAINT error_length
  CHECK (((char_length(last_error_message) <= 500) AND (char_length(last_error_backtrace) <= 10000))),

  CONSTRAINT job_class_length
  CHECK ((char_length(
CASE job_class
  WHEN 'ActiveJob::QueueAdapters::QueAdapter::JobWrapper'::text THEN ((args -> 0) ->> 'job_class'::text)
  ELSE job_class
END) <= 200)),

  CONSTRAINT queue_length
  CHECK ((char_length(queue) <= 100)),

  CONSTRAINT valid_args
  CHECK ((jsonb_typeof(args) = 'array'::text)),

  CONSTRAINT valid_data
  CHECK (((jsonb_typeof(data) = 'object'::text) AND ((NOT (data ? 'tags'::text)) OR ((jsonb_typeof((data -> 'tags'::text)) = 'array'::text) AND (jsonb_array_length((data -> 'tags'::text)) <= 5) AND public.que_validate_tags((data -> 'tags'::text))))))
)
WITH (fillfactor='90');

-- Required for migration? Maybe....
COMMENT ON TABLE public.que_jobs IS '4';

CREATE UNLOGGED TABLE public.que_lockers (
  pid               int     PRIMARY KEY,
  worker_count      int     NOT NULL,
  worker_priorities int[]   NOT NULL,
  ruby_pid          int     NOT NULL,
  ruby_hostname     text    NOT NULL,
  queues            text[]  NOT NULL,
  listening         boolean NOT NULL,

  CONSTRAINT valid_queues
  CHECK (((array_ndims(queues) = 1) AND (array_length(queues, 1) IS NOT NULL))),

  CONSTRAINT valid_worker_priorities
  CHECK (((array_ndims(worker_priorities) = 1) AND (array_length(worker_priorities, 1) IS NOT NULL)))
);

CREATE TABLE public.que_values (
  key   text  PRIMARY KEY,
  value jsonb DEFAULT '{}'::jsonb NOT NULL,

  CONSTRAINT valid_value
  CHECK ((jsonb_typeof(value) = 'object'::text))
)
WITH (fillfactor='90');

CREATE TABLE IF NOT EXISTS public.schema_migrations (
  version varchar PRIMARY KEY
);

CREATE TABLE settings.secrets (
  key   varchar PRIMARY KEY,
  value varchar
);

CREATE OR REPLACE FUNCTION api.admin_login(
  email    varchar,
  password varchar
) RETURNS text
AS $$
DECLARE
  admin_id bigint;
  result   text;
BEGIN
  SELECT
    id
  FROM app.admin_accounts
  WHERE
    app.admin_accounts.email              = admin_login.email AND
    app.admin_accounts.encrypted_password = public.crypt(admin_login.password, app.admin_accounts.encrypted_password)
  INTO admin_id;

  IF admin_id IS NULL THEN
    RAISE invalid_password USING message = 'invalid email or password';
  END IF;

  SELECT
    jwt.sign(
      row_to_json(r), settings.get('app.jwt_secret')
    ) AS token
  FROM (
    SELECT
      'admin'                                AS role,
      admin_id::varchar                      AS sub,
      extract(EPOCH FROM now())::int + 60*60 AS exp
  ) r
  INTO result;

  RETURN result;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION api.user_login(
  email    varchar,
  password varchar
) RETURNS text
AS $$
DECLARE
  user_id bigint;
  result  text;
BEGIN
  SELECT
    id
  FROM app.user_accounts
  WHERE
    app.user_accounts.email              = user_login.email AND
    app.user_accounts.encrypted_password = public.crypt(user_login.password, app.user_accounts.encrypted_password)
  INTO user_id;

  IF user_id IS NULL THEN
    RAISE invalid_password USING message = 'invalid user or password';
  END IF;

  SELECT
    jwt.sign(
      row_to_json(r), settings.get('app.jwt_secret')
    ) AS token
  FROM (
    SELECT
      'user'                                 AS role,
      user_id::varchar                       AS sub,
      extract(EPOCH FROM now())::int + 60*60 AS exp
  ) r
  INTO result;

  RETURN result;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.content_type_by_extension(
  filename varchar
) RETURNS varchar AS $$
BEGIN
  CASE
  WHEN lower(filename) ~ '.(jpg|jpeg)$' THEN
    RETURN 'image/jpeg';
  WHEN lower(filename) ~ '.gif$' THEN
    RETURN 'image/gif';
  WHEN lower(filename) ~ '.png$' THEN
    RETURN 'image/png';
  WHEN lower(filename) ~ '.svg$' THEN
    RETURN 'image/svg+xml';
  WHEN lower(filename) ~ '.pdf$' THEN
    RETURN 'application/pdf';
  ELSE
    RETURN 'application/octet-stream';
  END CASE;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.currency_index(currency varchar)
RETURNS BIGINT AS $$
BEGIN
  CASE
  WHEN currency = 'USD' THEN
    RETURN 0;
  WHEN currency = 'EUR' THEN
    RETURN 1;
  WHEN currency = 'GPB' THEN
    RETURN 2;
  WHEN currency = 'BRL' THEN
    RETURN 3;
  ELSE
    RETURN 4;
  END CASE;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;

CREATE OR REPLACE FUNCTION app.fill_sitemaps(
  _sitemaps app.sitemap[]
) RETURNS app.sitemap[] AS $$
  SELECT
    ARRAY_AGG(
      (
        COALESCE(sitemap.id,     public.uuid_generate_v4()),
        COALESCE(sitemap.status, 'unconfirmed'),
        sitemap.url,
        sitemap.type
      )::app.sitemap
    )
  FROM unnest(_sitemaps) AS sitemap
  WHERE
    sitemap.url IS NOT NULL
    AND char_length(sitemap.url) > 0
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION app.merge_sitemaps(
  _old_sitemaps app.sitemap[],
  _new_sitemaps app.sitemap[]
) RETURNS app.sitemap[] AS $$
  SELECT
    ARRAY_AGG(
      COALESCE(old_sitemap, new_sitemap)
    )
  FROM      unnest(_new_sitemaps) AS new_sitemap
  LEFT JOIN unnest(_old_sitemaps) AS old_sitemap ON
    new_sitemap.id = old_sitemap.id
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION app.new_sitemaps(
  _sitemaps app.sitemap[]
) RETURNS app.sitemap[] AS $$
  SELECT
    ARRAY_AGG(
      (
        COALESCE(sitemap.id, public.uuid_generate_v4()),
        'unconfirmed',
        sitemap.url,
        sitemap.type
      )::app.sitemap
    )
  FROM unnest(_sitemaps) AS sitemap
  WHERE
    sitemap.url IS NOT NULL
    AND char_length(sitemap.url) > 0
$$ LANGUAGE sql;

CREATE FUNCTION app.normalize_languages(languages text[]) RETURNS text[] AS $$
DECLARE
  upcased_languages text[];
BEGIN
  WITH

  subtitles AS (
    SELECT DISTINCT unnest(languages) AS subtitle
  ),

  subtitle_arrays AS (
    SELECT regexp_split_to_array(subtitle, '-') AS subtitle_array
    FROM subtitles
  )

  SELECT DISTINCT
    ARRAY_AGG(
      CASE WHEN array_length(subtitle_array, 1) = 2
      THEN subtitle_array[1] || '-' || upper(subtitle_array[2])
      ELSE subtitle_array[1]
      END
    )
  FROM subtitle_arrays
  INTO upcased_languages;

  RETURN upcased_languages;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.price_in_decimal(price text)
  RETURNS DECIMAL AS
$$
BEGIN
   IF $1 = '' THEN  -- special case for empty string like requested
      RETURN 0::DECIMAL(12,2);
   ELSE
      RETURN $1::DECIMAL(12,2);
   END IF;

EXCEPTION WHEN OTHERS THEN
   RETURN NULL;  -- NULL for other invalid input

END
$$ LANGUAGE plpgsql IMMUTABLE;

CREATE OR REPLACE FUNCTION app.sign_certificate_s3_fetch(
  id         uuid,
  filename   varchar,
  expires_in int
) RETURNS text AS $$
BEGIN
  RETURN app.sign_s3_fetch(
    '$CERTIFICATE_AWS_REGION',
    '$CERTIFICATE_AWS_HOST',
    '$CERTIFICATE_AWS_BUCKET',
    '$CERTIFICATE_AWS_FOLDER',
    id::varchar || '-' || filename,
    '$CERTIFICATE_AWS_ACCESS_KEY_ID',
    '$CERTIFICATE_AWS_SECRET_ACCESS_KEY',
    expires_in,
    '$CERTIFICATE_AWS_IS_HTTPS'::boolean
  );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_certificate_s3_upload(
  id         uuid,
  filename   varchar,
  expires_in int
) RETURNS text AS $$
BEGIN
  RETURN app.sign_s3_upload(
    '$CERTIFICATE_AWS_REGION',
    '$CERTIFICATE_AWS_HOST',
    '$CERTIFICATE_AWS_BUCKET',
    '$CERTIFICATE_AWS_FOLDER',
    id::varchar || '-' || filename,
    '$CERTIFICATE_AWS_ACCESS_KEY_ID',
    '$CERTIFICATE_AWS_SECRET_ACCESS_KEY',
    expires_in,
    '$CERTIFICATE_AWS_IS_PUBLIC'::boolean,
    '$CERTIFICATE_AWS_IS_HTTPS'::boolean
  );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_direct_s3_fetch(
  id         uuid,
  filename   varchar,
  folder     varchar,
  expires_in int
) RETURNS text AS $$
BEGIN
  RETURN app.sign_s3_fetch(
    '$DIRECT_UPLOAD_AWS_REGION',
    '$DIRECT_UPLOAD_AWS_HOST',
    '$DIRECT_UPLOAD_AWS_BUCKET',
    '$DIRECT_UPLOAD_AWS_ROOT_FOLDER' || '/' || folder,
    id::varchar || '-' || filename,
    '$DIRECT_UPLOAD_AWS_ACCESS_KEY_ID',
    '$DIRECT_UPLOAD_AWS_SECRET_ACCESS_KEY',
    expires_in,
    '$DIRECT_UPLOAD_AWS_IS_HTTPS'::boolean
  );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_direct_s3_upload(
  id         uuid,
  filename   varchar,
  folder     varchar,
  expires_in int
) RETURNS text AS $$
BEGIN
  RETURN app.sign_s3_upload(
    '$DIRECT_UPLOAD_AWS_REGION',
    '$DIRECT_UPLOAD_AWS_HOST',
    '$DIRECT_UPLOAD_AWS_BUCKET',
    '$DIRECT_UPLOAD_AWS_ROOT_FOLDER' || '/' || folder,
    id::varchar || '-' || filename,
    '$DIRECT_UPLOAD_AWS_ACCESS_KEY_ID',
    '$DIRECT_UPLOAD_AWS_SECRET_ACCESS_KEY',
    expires_in,
    '$DIRECT_UPLOAD_AWS_IS_PUBLIC'::boolean,
    '$DIRECT_UPLOAD_AWS_IS_HTTPS'::boolean
  );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_s3_fetch(
  region            varchar,
  host              varchar,
  bucket            varchar,
  folder            varchar,
  filename          varchar,
  access_key_id     varchar,
  secret_access_key varchar,
  expires_in        int,
  is_https          boolean
) RETURNS text AS $$
DECLARE
  canonical_request_digest text;
  string_to_sign           text;
  content_type             varchar;
  time_string              varchar;
  date_string              varchar;
  key                      bytea;
  query_string             varchar;
  signature                varchar;
  fullpath                 varchar;
  time_now                 timestamptz;
BEGIN
  time_now    = timezone('utc', NOW());
  time_string = to_char(time_now, 'YYYYMMDD"T"HH24MISSZ');
  date_string = to_char(time_now, 'YYYYMMDD');

  query_string = 'X-Amz-Algorithm=AWS4-HMAC-SHA256'
              || '&X-Amz-Credential=' || access_key_id || '%2F' || date_string || '%2F' || region || '%2Fs3%2Faws4_request'
              || '&X-Amz-Date='    || time_string
              || '&X-Amz-Expires=' || expires_in::varchar
              || '&X-Amz-SignedHeaders=host';

  canonical_request_digest = E'GET\n/'
                          || bucket || folder || '/' || filename || E'\n'
                          || query_string
                          || E'\nhost:' || host
                          || E'\n\nhost\n'
                          || 'UNSIGNED-PAYLOAD';

  string_to_sign = E'AWS4-HMAC-SHA256\n'
                || time_string || E'\n'
                || date_string || '/' || region || E'/s3/aws4_request\n'
                || encode(digest(canonical_request_digest, 'sha256'), 'hex');

  key = hmac(date_string,           'AWS4' || secret_access_key, 'sha256');
  key = hmac(region::bytea,         key,                         'sha256');
  key = hmac('s3'::bytea,           key,                         'sha256');
  key = hmac('aws4_request'::bytea, key,                         'sha256');

  signature = encode(hmac(string_to_sign::bytea, key, 'sha256'), 'hex');
  fullpath  = host || '/' || bucket || folder || '/' || filename || '?' || query_string || '&X-Amz-Signature=' || signature;

  IF is_https THEN
    RETURN 'https://' || fullpath;
  ELSE
    RETURN 'http://' || fullpath;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.sign_s3_upload(
  region            varchar,
  host              varchar,
  bucket            varchar,
  folder            varchar,
  filename          varchar,
  access_key_id     varchar,
  secret_access_key varchar,
  expires_in        int,
  is_public         boolean,
  is_https          boolean
) RETURNS text AS $$
DECLARE
  canonical_request_digest text;
  string_to_sign           text;
  acl                      varchar;
  content_type             varchar;
  time_string              varchar;
  date_string              varchar;
  key                      bytea;
  query_string             varchar;
  signature                varchar;
  fullpath                 varchar;
  time_now                 timestamptz;
BEGIN
  time_now    = timezone('utc', NOW());
  time_string = to_char(time_now, 'YYYYMMDD"T"HH24MISSZ');
  date_string = to_char(time_now, 'YYYYMMDD');

  query_string = 'X-Amz-Algorithm=AWS4-HMAC-SHA256'
              || '&X-Amz-Credential=' || access_key_id || '%2F' || date_string || '%2F' || region || '%2Fs3%2Faws4_request'
              || '&X-Amz-Date='    || time_string
              || '&X-Amz-Expires=' || expires_in::varchar
              || '&X-Amz-SignedHeaders=content-type%3Bhost%3Bx-amz-acl';

  content_type = app.content_type_by_extension(filename);

  IF is_public THEN
    acl = 'public-read';
  ELSE
    acl = 'private';
  END IF;

  canonical_request_digest = E'PUT\n/'
                          || bucket || folder || '/' || filename || E'\n'
                          || query_string
                          || E'\ncontent-type:' || content_type
                          || E'\nhost:' || host
                          || E'\nx-amz-acl:' || acl
                          || E'\n\ncontent-type;host;x-amz-acl\n'
                          || 'UNSIGNED-PAYLOAD';

  string_to_sign = E'AWS4-HMAC-SHA256\n'
                || time_string || E'\n'
                || date_string || '/' || region || E'/s3/aws4_request\n'
                || encode(digest(canonical_request_digest, 'sha256'), 'hex');

  key = hmac(date_string,           'AWS4' || secret_access_key, 'sha256');
  key = hmac(region::bytea,         key,                         'sha256');
  key = hmac('s3'::bytea,           key,                         'sha256');
  key = hmac('aws4_request'::bytea, key,                         'sha256');

  signature = encode(hmac(string_to_sign::bytea, key, 'sha256'), 'hex');
  fullpath  = host || '/' || bucket || folder || '/' || filename || '?' || query_string || '&X-Amz-Signature=' || signature;

  IF is_https THEN
    RETURN 'https://' || fullpath;
  ELSE
    RETURN 'http://' || fullpath;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION app.slugify(value varchar)
RETURNS TEXT AS $$
  WITH unaccented AS (
    SELECT unaccent(value) AS value
  ),

  lowercase AS (
    SELECT lower(value) AS value
    FROM unaccented
  ),

  hyphenated AS (
    SELECT regexp_replace(value, '[^a-z0-9\\-_]+', '-', 'gi') AS value
    FROM lowercase
  ),

  trimmed AS (
    SELECT regexp_replace(regexp_replace(value, '\\-+$', ''), '^\\-', '') AS value
    FROM hyphenated
  )

  SELECT value FROM trimmed;
$$ LANGUAGE SQL STRICT IMMUTABLE;

CREATE FUNCTION jwt.url_encode(data bytea) RETURNS text
AS $$
  SELECT translate(encode(data, 'base64'), E'+/=\n', '-_');
$$ LANGUAGE sql;

CREATE FUNCTION jwt.algorithm_sign(
  signables text,
  secret    text,
  algorithm text
) RETURNS text
AS $$
  WITH
    alg AS ( SELECT
      CASE
      WHEN algorithm = 'HS256' THEN 'sha256'
      WHEN algorithm = 'HS384' THEN 'sha384'
      WHEN algorithm = 'HS512' THEN 'sha512'
      ELSE ''
      END
    )  -- hmac throws error
  SELECT jwt.url_encode(public.hmac(signables, secret, (select * FROM alg)));
$$ LANGUAGE sql;

CREATE FUNCTION jwt.sign(
  payload json,
  secret text,
  algorithm text DEFAULT 'HS256'
) RETURNS text
AS $$
  WITH
    header AS (
      SELECT jwt.url_encode(convert_to('{"alg":"' || algorithm || '","typ":"JWT"}', 'utf8'))
    ),
    payload AS (
      SELECT jwt.url_encode(convert_to(payload::text, 'utf8'))
    ),
    signables AS (
      SELECT (SELECT * FROM header) || '.' || (SELECT * FROM payload)
    )

  SELECT
    (SELECT * FROM signables) ||
    '.' ||
    jwt.algorithm_sign(
      (SELECT * FROM signables),
      secret,
      algorithm
    );
$$ LANGUAGE sql;

CREATE FUNCTION jwt.url_decode(data text) RETURNS bytea
AS $$
WITH
  t   AS ( SELECT translate(data, '-_', '+/') ),
  rem AS ( SELECT length((SELECT * FROM t)) % 4) -- compute padding size
  SELECT decode(
    (SELECT * FROM t) ||
    CASE WHEN (SELECT * FROM rem) > 0
      THEN repeat('=', (4 - (SELECT * FROM rem)))
      ELSE ''
    END,
    'base64'
  );
$$ LANGUAGE sql;

CREATE FUNCTION jwt.verify(
  token     text,
  secret    text,
  algorithm text DEFAULT 'HS256'
) RETURNS table(header json, payload json, valid boolean)
AS $$
  SELECT
    convert_from(jwt.url_decode(r[1]), 'utf8')::json AS header,
    convert_from(jwt.url_decode(r[2]), 'utf8')::json AS payload,
    r[3] = jwt.algorithm_sign(r[1] || '.' || r[2], secret, algorithm) AS valid
  FROM regexp_split_to_array(token, '\.') r;
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION public.if_admin(value anyelement) RETURNS anyelement AS $$
BEGIN
  IF current_user = 'admin' THEN
    RETURN value;
  ELSE
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION public.if_user_by_id(id bigint, value anyelement) RETURNS anyelement AS $$
BEGIN
  IF current_user = 'user' AND current_setting('request.jwt.claim.sub', true)::bigint = id THEN
    RETURN value;
  ELSE
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION public.if_user_by_ids(ids bigint[], value anyelement) RETURNS anyelement AS $$
BEGIN
  IF current_user = 'user' AND current_setting('request.jwt.claim.sub', true)::bigint = ANY(ids) THEN
    RETURN value;
  ELSE
    RETURN NULL;
  END IF;
END;
$$ LANGUAGE plpgsql STABLE;

CREATE FUNCTION public.que_determine_job_state(job public.que_jobs) RETURNS text
    LANGUAGE sql
    AS $$
  SELECT
    CASE
    WHEN job.expired_at  IS NOT NULL    THEN 'expired'
    WHEN job.finished_at IS NOT NULL    THEN 'finished'
    WHEN job.error_count > 0            THEN 'errored'
    WHEN job.run_at > CURRENT_TIMESTAMP THEN 'scheduled'
    ELSE                                     'ready'
    END
$$;

CREATE FUNCTION public.que_job_notify() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  DECLARE
    locker_pid integer;
    sort_key json;
  BEGIN
    -- Don't do anything if the job is scheduled for a future time.
    IF NEW.run_at IS NOT NULL AND NEW.run_at > NOW() THEN
      RETURN null;
    END IF;

    -- Pick a locker to notify of the job's insertion, weighted by their number
    -- of workers. Should bounce pseudorandomly between lockers on each
    -- invocation, hence the md5-ordering, but still touch each one equally,
    -- hence the modulo using the job_id.
    SELECT pid
    INTO locker_pid
    FROM (
      SELECT *, last_value(row_number) OVER () + 1 AS count
      FROM (
        SELECT *, row_number() OVER () - 1 AS row_number
        FROM (
          SELECT *
          FROM public.que_lockers ql, generate_series(1, ql.worker_count) AS id
          WHERE listening AND queues @> ARRAY[NEW.queue]
          ORDER BY md5(pid::text || id::text)
        ) t1
      ) t2
    ) t3
    WHERE NEW.id % count = row_number;

    IF locker_pid IS NOT NULL THEN
      -- There's a size limit to what can be broadcast via LISTEN/NOTIFY, so
      -- rather than throw errors when someone enqueues a big job, just
      -- broadcast the most pertinent information, and let the locker query for
      -- the record after it's taken the lock. The worker will have to hit the
      -- DB in order to make sure the job is still visible anyway.
      SELECT row_to_json(t)
      INTO sort_key
      FROM (
        SELECT
          'job_available' AS message_type,
          NEW.queue       AS queue,
          NEW.priority    AS priority,
          NEW.id          AS id,
          -- Make sure we output timestamps as UTC ISO 8601
          to_char(NEW.run_at AT TIME ZONE 'UTC', 'YYYY-MM-DD"T"HH24:MI:SS.US"Z"') AS run_at
      ) t;

      PERFORM pg_notify('que_listener_' || locker_pid::text, sort_key::text);
    END IF;

    RETURN null;
  END
$$;

CREATE FUNCTION public.que_state_notify() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  DECLARE
    row record;
    message json;
    previous_state text;
    current_state text;
  BEGIN
    IF TG_OP = 'INSERT' THEN
      previous_state := 'nonexistent';
      current_state  := public.que_determine_job_state(NEW);
      row            := NEW;
    ELSIF TG_OP = 'DELETE' THEN
      previous_state := public.que_determine_job_state(OLD);
      current_state  := 'nonexistent';
      row            := OLD;
    ELSIF TG_OP = 'UPDATE' THEN
      previous_state := public.que_determine_job_state(OLD);
      current_state  := public.que_determine_job_state(NEW);

      -- If the state didn't change, short-circuit.
      IF previous_state = current_state THEN
        RETURN null;
      END IF;

      row := NEW;
    ELSE
      RAISE EXCEPTION 'Unrecognized TG_OP: %', TG_OP;
    END IF;

    SELECT row_to_json(t)
    INTO message
    FROM (
      SELECT
        'job_change' AS message_type,
        row.id       AS id,
        row.queue    AS queue,

        coalesce(row.data->'tags', '[]'::jsonb) AS tags,

        to_char(row.run_at AT TIME ZONE 'UTC', 'YYYY-MM-DD"T"HH24:MI:SS.US"Z"') AS run_at,
        to_char(NOW()      AT TIME ZONE 'UTC', 'YYYY-MM-DD"T"HH24:MI:SS.US"Z"') AS time,

        CASE row.job_class
        WHEN 'ActiveJob::QueueAdapters::QueAdapter::JobWrapper' THEN
          coalesce(
            row.args->0->>'job_class',
            'ActiveJob::QueueAdapters::QueAdapter::JobWrapper'
          )
        ELSE
          row.job_class
        END AS job_class,

        previous_state AS previous_state,
        current_state  AS current_state
    ) t;

    PERFORM pg_notify('que_state', message::text);

    RETURN null;
  END
$$;

CREATE FUNCTION settings.get(varchar)
RETURNS varchar
AS $$
  SELECT value
  FROM settings.secrets
  WHERE key = $1
$$ SECURITY DEFINER STABLE LANGUAGE sql;

CREATE FUNCTION settings.set(varchar, varchar)
RETURNS VOID
AS $$
  INSERT INTO settings.secrets (key, value)
  VALUES ($1, $2)
  ON CONFLICT (key) DO UPDATE
  SET value = $2;
$$ SECURITY DEFINER LANGUAGE sql;

CREATE FUNCTION triggers.check_course_provider_relationship() RETURNS trigger AS $$
BEGIN
  IF (NEW.course_id IS NOT NULL) THEN
    IF (NEW.provider_id IS NOT NULL) THEN
      IF (SELECT provider_id FROM app.courses WHERE id = NEW.course_id) <> NEW.provider_id THEN
        RAISE EXCEPTION 'update failed' USING DETAIL = 'course_provider__do_not_match', HINT = json_build_object('course_id', NEW.course_id, 'provider_id', NEW.provider_id);
      END IF;
    ELSE
      NEW.provider_id := (SELECT provider_id FROM app.courses WHERE id = NEW.course_id);
    END IF;
  END IF;

  RETURN NEW;
END
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE FUNCTION triggers.course_keep_slug() RETURNS trigger AS $$
BEGIN
  IF (NEW.published = false) THEN
    RETURN NEW;
  END IF;

  INSERT INTO app.slug_histories (
    course_id, slug
  ) VALUES (
    NEW.id, NEW.slug
  ) ON CONFLICT DO NOTHING;

  RETURN NEW;
END
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE FUNCTION triggers.course_normalize_languages() RETURNS trigger AS $$
BEGIN
  NEW.audio     = app.normalize_languages(NEW.audio);
  NEW.subtitles = app.normalize_languages(NEW.subtitles);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION triggers.create_subscription() RETURNS trigger AS $$
BEGIN
  INSERT INTO app.subscriptions (profile_id) VALUES (NEW.id); 
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.encrypt_password() RETURNS trigger
AS $$
BEGIN
  IF NEW.encrypted_password ~* '^\$\d\w\$\d{2}\$[^$]{53}$' THEN
    RETURN NEW;
  END IF;

  IF tg_op = 'INSERT' OR NEW.encrypted_password <> OLD.encrypted_password THEN
    NEW.encrypted_password = crypt(NEW.encrypted_password, gen_salt('bf', 11));
  END IF;

  RETURN NEW;
end
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.gen_compound_ext_id() RETURNS trigger AS $$
BEGIN
  NEW.compound_ext_id = concat(NEW.source,'_',NEW.ext_id);
  return NEW;
END
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.insert_or_add_to_provider() RETURNS trigger AS $$
DECLARE
  _provider        app.providers%ROWTYPE;
  _new_provider_id uuid;
BEGIN
  SELECT * FROM app.providers INTO _provider where providers.name = NEW.__provider_name__;
  IF (NOT FOUND) THEN
    INSERT INTO app.providers (name, published, created_at, updated_at) VALUES (NEW.__provider_name__, false, NOW(), NOW()) RETURNING id INTO _new_provider_id;
    NEW.published = false;
    NEW.provider_id = _new_provider_id;
  ELSE
    NEW.provider_id = _provider.id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- CREATE FUNCTION triggers.md5_url() RETURNS trigger AS $$
-- BEGIN
--   NEW.url_md5=md5(NEW.url);
--   return NEW;
-- END
-- $$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.sort_prices() RETURNS trigger AS $$
DECLARE
  price                 jsonb;
  prices                jsonb[];
  results               jsonb[];
  single_course_prices  jsonb[];
  subscription_prices   jsonb[];
BEGIN
  FOR price IN SELECT * FROM jsonb_array_elements((NEW.__source_schema__ -> 'content' ->> 'prices')::jsonb)
  LOOP
    IF (price ->> 'type' = 'single_course') THEN
      single_course_prices := array_append(single_course_prices,price);
    ELSIF (price ->> 'type' = 'subscription') THEN
      IF (price -> 'subscription_period' ->> 'unit' = 'months') THEN
        subscription_prices := array_prepend(price,subscription_prices);
      ELSIF (price -> 'subscription_period' ->> 'unit' = 'years') THEN
        subscription_prices := array_append(subscription_prices,price);
      END IF;
    END IF;
  END LOOP;
  results := (single_course_prices || subscription_prices);
  IF array_length(results,1) > 0 THEN
    NEW.pricing_models = to_jsonb(results);
  END IF;
  NEW.__source_schema__ = NULL;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION triggers.track_updated_at() RETURNS trigger
AS $$
BEGIN
  IF NEW.updated_at IS NULL THEN
    NEW.updated_at := OLD.updated_at;
  ELSE
    IF NEW.updated_at = OLD.updated_at THEN
      NEW.updated_at := NOW();
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION triggers.use_username() RETURNS trigger
AS $$
BEGIN
  IF (TG_OP = 'INSERT' AND NEW.username IS NULL) THEN
    RAISE EXCEPTION 'username update failed' USING DETAIL = 'username__cannot_be_null';
  END IF;

  IF (TG_OP = 'UPDATE' AND OLD.username IS NULL AND NEW.username IS NULL) THEN
    RETURN NEW;
  END IF;

  IF TG_OP = 'UPDATE' AND OLD.username IS NOT NULL AND NEW.username IS NULL THEN
    RAISE EXCEPTION 'username update failed' USING DETAIL = 'username__cannot_be_erased';
  END IF;

  IF ((TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.username IS NULL)) AND NEW.username IS NOT NULL) OR
     (TG_OP = 'UPDATE' AND OLD.username IS NOT NULL AND NEW.username IS NOT NULL AND OLD.username <> NEW.username) THEN

    IF TG_OP = 'UPDATE' AND OLD.username_changed_at IS NOT NULL AND
      (NOW() - OLD.username_changed_at < '15 days'::interval) THEN
      RAISE EXCEPTION 'username update failed' USING DETAIL = 'username__change_within_update_threshold', HINT = json_build_object('threshold', '15');
    ELSE
      UPDATE app.profiles SET username_changed_at = NOW() WHERE id = NEW.id;
    END IF;

    INSERT INTO app.used_usernames (profile_id, username) VALUES (NEW.id, NEW.username);

    RETURN NEW;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION triggers.validate_profiles() RETURNS trigger AS $$
DECLARE
  _platform     text;
  _url          text;
  _host         text;
  _url_path     text;
  _id           text;
  _path_pattern text;
BEGIN
  -- social profiles
  IF (
      NEW.social_profiles IS NOT NULL AND
      NEW.social_profiles <> '{}'
    ) THEN

    FOR _platform, _url IN
       SELECT * FROM jsonb_each_text(NEW.social_profiles)
    LOOP
      WITH parsed AS (
        SELECT alias, token FROM ts_debug(_url)
      )
      SELECT (SELECT token FROM parsed WHERE alias = 'host') AS host,
              (SELECT token FROM parsed WHERE alias = 'url_path') AS url_path
        INTO _host, _url_path;

      IF (_host IS NULL) OR (_url_path IS NULL) THEN
        RAISE EXCEPTION 'social_profiles update failed' USING DETAIL = 'public_profile__invalid_uri', HINT = json_build_object('value', _url);
      END IF;

      CASE _platform
      WHEN 'behance' THEN
        -- /thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, 1);
        _id := SUBSTR(_url_path, 2);

        IF (_host <> 'behance.net') OR
           (_path_pattern <> '/') OR
           (_id !~ '^(?!.*(?:\/))(?:[A-z\d\-_]){3,20}$') THEN
          RAISE EXCEPTION 'social_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'dribbble' THEN
        -- /thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, 1);
        _id := SUBSTR(_url_path, 2);

        IF (_host <> 'dribbble.com') OR
           (_path_pattern <> '/') OR
           (_id !~ '^(?!.*(?:\/))(?:[A-z\d\-_]){2,20}$') THEN
          RAISE EXCEPTION 'social_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'facebook' THEN
        -- /thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, 1);
        _id := SUBSTR(_url_path, 2);

        IF  (_host <> 'facebook.com') OR
            (_path_pattern <> '/') OR
            (_id !~ '^(?!.*(?:\/))(?:(?:(?:[A-z\d])(?:[A-z\d]|[.-](?=[A-z\d])){4,50})|(?:\d{15}))$') THEN
          RAISE EXCEPTION 'social_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'github' THEN
        -- /thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, 1);
        _id := SUBSTR(_url_path, 2);

        IF  (_host <> 'github.com') OR
            (_path_pattern <> '/') OR
            (_id !~ '^(?!.*(?:\/))[A-z\d](?:[A-z\d]|-(?=[A-z\d])){0,38}$') THEN
          RAISE EXCEPTION 'social_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'instagram' THEN
        -- /thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, 1);
        _id := SUBSTR(_url_path, 2);

        IF  (_host <> 'instagram.com') OR
            (_path_pattern <> '/') OR
            (_id !~ '^(?!.*(?:\/))([A-z\d._](?:(?:[A-z\d._]|(?:\.(?!\.))){2,28}(?:[A-z\d._]))?)$') THEN
          RAISE EXCEPTION 'social_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'linkedin' THEN
        -- /in/thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, LENGTH('/in/'));
        _id := SUBSTR(_url_path, LENGTH('/in/') + 1);

        IF  (_host <> 'linkedin.com') OR
            (_path_pattern <> '/in/') OR
            (_id !~ '^(?!.*(?:\/))[A-zÀ-ÿ\d](?:[A-zÀ-ÿ\d]|-(?=[A-zÀ-ÿ\d])){2,99}$') THEN
          RAISE EXCEPTION 'social_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'pinterest' THEN
        -- /thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, 1);
        _id := SUBSTR(_url_path, 2);

        IF  (_host <> 'pinterest.com') OR
            (_path_pattern <> '/') OR
            (_id !~ '^(?!.*(?:\/))[A-z\d](?:[A-z\d]|_){2,29}$') THEN
          RAISE EXCEPTION 'social_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'reddit' THEN
        -- /user/thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, LENGTH('/user/'));
        _id := SUBSTR(_url_path, LENGTH('/user/') + 1);

        IF  (_host <> 'reddit.com') OR
            (_path_pattern <> '/user/') OR
            (_id !~ '^(?!.*(?:\/))(?:[A-z\d\-_]){3,20}$') THEN
          RAISE EXCEPTION 'social_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'soundcloud' THEN
        -- /thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, 1);
        _id := SUBSTR(_url_path, 2);

        IF  (_host <> 'soundcloud.com') OR
            (_path_pattern <> '/') OR
            (_id !~ '^(?!.*(?:\/))(?:[a-z\d](?:[a-z\d]|[-_](?=[a-z\d])){2,24})$') THEN
          RAISE EXCEPTION 'social_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'twitter' THEN
        -- /thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, 1);
        _id := SUBSTR(_url_path, 2);

        IF  (_host <> 'twitter.com') OR
            (_path_pattern <> '/') OR
            (_id !~ '^(?!.*(?:\/))[A-z\d_]{4,15}$') THEN
          RAISE EXCEPTION 'social_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'youtube' THEN
        -- /channel/UCasdjfsafkjasdkflj
        _path_pattern := SUBSTR(_url_path, 1, LENGTH('/channel/'));
        _id := SUBSTR(_url_path, LENGTH('/channel/') + 1);

        IF  (_host <> 'youtube.com') OR
            (_path_pattern <> '/channel/') OR
            (_id !~ '^(?!.*(?:\/))UC(?:[A-z\d_-]){22}$') THEN
          RAISE EXCEPTION 'social_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      ELSE
        NULL;
      END CASE;
    END LOOP;
  END IF;

  -- elearning profiles
  IF (
      NEW.elearning_profiles IS NOT NULL AND
      NEW.elearning_profiles <> '{}'
    ) THEN

    FOR _platform, _url IN
       SELECT * FROM jsonb_each_text(NEW.elearning_profiles)
    LOOP
      WITH parsed AS (
        SELECT alias, token FROM ts_debug(_url)
      )
      SELECT (SELECT token FROM parsed WHERE alias = 'host') AS host,
              (SELECT token FROM parsed WHERE alias = 'url_path') AS url_path
        INTO _host, _url_path;

      IF (_host IS NULL) OR (_url_path IS NULL) THEN
        RAISE EXCEPTION 'elearning_profiles update failed' USING DETAIL = 'public_profile__invalid_uri', HINT = json_build_object('value', _url);
      END IF;

      CASE _platform
      WHEN 'linkedin_learning' THEN
        -- /learning/instructors/thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, LENGTH('/learning/instructors/'));
        _id := SUBSTR(_url_path, LENGTH('/learning/instructors/') + 1);

        IF  (_host <> 'linkedin.com') OR
            (_path_pattern <> '/learning/instructors/') OR
            (_id !~ '^(?!.*(?:\/))[a-z\d](?:[a-z\d]|-(?=[a-z\d])){2,}$') THEN
          RAISE EXCEPTION 'elearning_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'masterclass' THEN
        -- /classes/thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, LENGTH('/classes/'));
        _id := SUBSTR(_url_path, LENGTH('/classes/') + 1);

        IF  (_host <> 'masterclass.com') OR
            (_path_pattern <> '/classes/') OR
            (_id !~ '^(?!.*(?:\/))(?:[a-z\d](?:[a-z\d]|-(?=[a-z\d])){9,})$') THEN
          RAISE EXCEPTION 'elearning_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'pluralsight' THEN
        -- /authors/thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, LENGTH('/authors/'));
        _id := SUBSTR(_url_path, LENGTH('/authors/') + 1);

        IF  (_host <> 'pluralsight.com') OR
            (_path_pattern <> '/authors/') OR
            (_id !~ '^(?!.*(?:\/))[a-z\d](?:[a-z\d]|-(?=[a-z\d])){4,}$') THEN
          RAISE EXCEPTION 'elearning_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'skillshare' THEN
        -- /user/thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, LENGTH('/user/'));
        _id := SUBSTR(_url_path, LENGTH('/user/') + 1);

        IF  (_host <> 'skillshare.com') OR
            (_path_pattern <> '/user/') OR
            (_id !~ '^(?!.*(?:\/))(?:[a-z\d\-_]{3,30})$') THEN
          RAISE EXCEPTION 'elearning_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'treehouse' THEN
        -- /thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, 1);
        _id := SUBSTR(_url_path, 2);

        IF  (_host <> 'teamtreehouse.com') OR
            (_path_pattern <> '/') OR
            (_id !~ '^(?!.*(?:\/))(?:[a-z]{3,30})$') THEN
          RAISE EXCEPTION 'elearning_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      WHEN 'udemy' THEN
        -- /user/thiagobrandam
        _path_pattern := SUBSTR(_url_path, 1, LENGTH('/user/'));
        _id := SUBSTR(_url_path, LENGTH('/user/') + 1);

        IF  (_host <> 'udemy.com') OR
            (_path_pattern <> '/user/') OR
            (_id !~ '^(?!.*(?:\/))[a-z\d\-_]{3,60}$') THEN
          RAISE EXCEPTION 'elearning_profiles update failed' USING DETAIL = 'public_profile__invalid_format', HINT = json_build_object('platform', _platform);
        END IF;
      ELSE
        NULL;
      END CASE;
    END LOOP;
  END IF;

  RETURN NEW;
END;
$$ SECURITY DEFINER STABLE LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION triggers.validate_provider_crawler_urls() RETURNS trigger AS $$
DECLARE
  result boolean;
BEGIN
  IF NEW.urls = OLD.urls THEN
    RETURN NEW;
  END IF;

  IF array_length(NEW.urls, 1) > 50 THEN
    RAISE EXCEPTION 'Invalid URLs' USING HINT = 'urls must have at most 20 elements';
  END IF;

  result = NOT EXISTS (
    SELECT 1 FROM unnest(NEW.urls) AS url
    WHERE NOT EXISTS (
      SELECT 1 FROM app.crawler_domains
      WHERE
        provider_crawler_id = NEW.id
        AND authority_confirmation_status = 'confirmed'
        AND url ~ ('^https?://([a-z0-9\-\_]+\.)*' || regexp_replace(domain, '^www.', '') || '(:\d+)?/')
    )
  );

  IF result = false THEN
    RAISE EXCEPTION 'Invalid URLs' USING HINT = 'All URLs must have verified domains';
  END IF;

  RETURN NEW;
END;
$$ SECURITY DEFINER STABLE LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION triggers.validate_sitemaps() RETURNS trigger AS $$
DECLARE
  result boolean;
BEGIN
  IF NEW.sitemaps = OLD.sitemaps THEN
    RETURN NEW;
  END IF;

  result = NOT EXISTS (
    SELECT 1 FROM unnest(NEW.sitemaps) AS sitemap
    WHERE NOT EXISTS (
      SELECT 1 FROM app.crawler_domains
      WHERE
        provider_crawler_id = NEW.id
        AND authority_confirmation_status = 'confirmed'
        AND sitemap.url ~ ('^https?://([a-z0-9\-\_]+\.)*' || regexp_replace(domain, '^www.', '') || '(:\d+)?/')
    )
  );

  IF result = false THEN
    RAISE EXCEPTION 'Invalid sitemaps' USING HINT = 'All sitemaps must have verified domains';
  END IF;

  RETURN NEW;
END;
$$ SECURITY DEFINER STABLE LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION triggers.validate_url() RETURNS trigger AS $$
DECLARE
  _protocol text;
  _host     text;
BEGIN
  IF ( NEW.url IS NOT NULL ) THEN
    WITH parsed AS (
      SELECT alias, token FROM ts_debug(NEW.url)
    )
    SELECT (SELECT token FROM parsed WHERE alias = 'protocol') AS host,
            (SELECT token FROM parsed WHERE alias = 'host') AS url_path
      INTO _protocol, _host;

    IF (_protocol IS NULL) OR (_host IS NULL) THEN
      RAISE EXCEPTION 'url update failed' USING DETAIL = 'url__invalid_uri', HINT = json_build_object('value', NEW.website);
    END IF;
  END IF;

  RETURN NEW;
END;
$$ SECURITY DEFINER STABLE LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION triggers.validate_user_account_ids() RETURNS trigger AS $$
DECLARE
  result boolean;
BEGIN
  IF NEW.user_account_ids = OLD.user_account_ids THEN
    RETURN NEW;
  END IF;

  result = NOT EXISTS (
    SELECT 1 FROM unnest(NEW.user_account_ids) AS provider_user_account_id
    WHERE NOT EXISTS (
      SELECT 1 FROM app.user_accounts
      WHERE
        provider_user_account_id = app.user_accounts.id
    )
  );

  IF result = false THEN
    RAISE EXCEPTION 'Invalid user_account_ids' USING HINT = 'All user account ids must exists';
  END IF;

  RETURN NEW;
END;
$$ SECURITY DEFINER STABLE LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION triggers.validate_website() RETURNS trigger AS $$
DECLARE
  _protocol text;
  _host     text;
BEGIN
  IF ( NEW.website IS NOT NULL ) THEN
    WITH parsed AS (
      SELECT alias, token FROM ts_debug(NEW.website)
    )
    SELECT (SELECT token FROM parsed WHERE alias = 'protocol') AS host,
            (SELECT token FROM parsed WHERE alias = 'host') AS url_path
      INTO _protocol, _host;

    IF (_protocol IS NULL) OR (_host IS NULL) THEN
      RAISE EXCEPTION 'website update failed' USING DETAIL = 'website__invalid_uri', HINT = json_build_object('value', NEW.website);
    END IF;
  END IF;

  RETURN NEW;
END;
$$ SECURITY DEFINER STABLE LANGUAGE plpgsql;

CREATE TRIGGER encrypt_password
  BEFORE INSERT OR UPDATE
  ON app.admin_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.encrypt_password();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.admin_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.admin_profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.certificates
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.contacts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.course_reviews
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER course_normalize_languages
  BEFORE INSERT OR UPDATE
  ON app.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.course_normalize_languages();

CREATE TRIGGER sort_prices
  BEFORE INSERT OR UPDATE
  ON app.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.sort_prices();

CREATE TRIGGER course_keep_slug
  AFTER INSERT OR UPDATE
  ON app.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.course_keep_slug();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.crawler_domains
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.crawling_events
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.direct_uploads
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.enrollments
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER check_course_provider_relationship
  BEFORE INSERT OR UPDATE
  ON app.enrollments
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.check_course_provider_relationship();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.favorites
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.images
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.landing_pages
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.oauth_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.orphaned_profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.posts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.preview_course_images
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.preview_courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER course_normalize_languages
  BEFORE INSERT OR UPDATE
  ON app.preview_courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.course_normalize_languages();

CREATE TRIGGER sort_prices
  BEFORE INSERT OR UPDATE
  ON app.preview_courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.sort_prices();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER use_username
  AFTER INSERT OR UPDATE
  ON app.profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.use_username();

CREATE TRIGGER validate_profiles
  BEFORE INSERT OR UPDATE
  ON app.profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.validate_profiles();

CREATE TRIGGER validate_website
  BEFORE INSERT OR UPDATE
  ON app.profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.validate_website();

CREATE TRIGGER create_profiles_subscription
  AFTER INSERT
  ON app.profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.create_subscription();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.promo_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE CONSTRAINT TRIGGER validate_user_account_ids
  AFTER INSERT OR UPDATE
  ON app.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.validate_user_account_ids();

CREATE CONSTRAINT TRIGGER validate_sitemaps
  AFTER INSERT OR UPDATE
  ON app.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.validate_sitemaps();

CREATE CONSTRAINT TRIGGER validate_provider_crawler_urls
  AFTER INSERT OR UPDATE
  ON app.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.validate_provider_crawler_urls();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.providers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER validate_url
  BEFORE INSERT OR UPDATE
  ON app.providers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.validate_url();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.slug_histories
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER set_compound_ext_id
  BEFORE INSERT
  ON app.tracked_actions
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.gen_compound_ext_id();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.tracked_actions
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.tracked_searches
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER encrypt_password
  BEFORE INSERT OR UPDATE
  ON app.user_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.encrypt_password();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON app.user_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER track_updated_at
  BEFORE UPDATE
  ON public.ar_internal_metadata
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.track_updated_at();

CREATE TRIGGER que_job_notify
  AFTER INSERT
  ON public.que_jobs
  FOR EACH ROW
    EXECUTE PROCEDURE public.que_job_notify();

CREATE TRIGGER que_state_notify
  AFTER INSERT OR DELETE OR UPDATE
  ON public.que_jobs
  FOR EACH ROW
    EXECUTE PROCEDURE public.que_state_notify();

CREATE UNIQUE INDEX index_admin_accounts_on_confirmation_token
ON app.admin_accounts
USING btree (confirmation_token);

CREATE UNIQUE INDEX index_admin_accounts_on_email
ON app.admin_accounts
USING btree (email);

CREATE UNIQUE INDEX index_admin_accounts_on_reset_password_token
ON app.admin_accounts
USING btree (reset_password_token);

CREATE UNIQUE INDEX index_admin_accounts_on_unlock_token
ON app.admin_accounts
USING btree (unlock_token);

CREATE INDEX index_admin_profiles_on_admin_account_id
ON app.admin_profiles
USING btree (admin_account_id);

CREATE UNIQUE INDEX index_course_reviews_on_user_account_id_and_tracked_action_id
ON app.course_reviews
USING btree (user_account_id, tracked_action_id);

CREATE INDEX index_courses_on_curated_tags
ON app.courses
USING gin (curated_tags);

CREATE INDEX index_courses_on_dataset_sequence
ON app.courses
USING btree (dataset_sequence);

CREATE UNIQUE INDEX index_courses_on_global_sequence
ON app.courses
USING btree (global_sequence);

CREATE INDEX index_courses_on_provider_id
ON app.courses
USING btree (provider_id);

CREATE INDEX index_courses_on_tags
ON app.courses
USING gin (tags);

CREATE UNIQUE INDEX index_courses_on_slug
ON app.courses
USING btree (slug)
WHERE published = true;

CREATE UNIQUE INDEX index_courses_on_url
ON app.courses
USING btree (url)
WHERE published = true;

CREATE INDEX index_courses_on_up_to_date_id
ON app.courses
USING btree (up_to_date_id);

CREATE UNIQUE INDEX app_crawler_domains_unique_domain_idx ON app.crawler_domains ( domain );

CREATE INDEX index_enrollments_on_course_id
ON app.enrollments
USING btree (course_id);

CREATE INDEX index_enrollments_on_provider_id
ON app.enrollments
USING btree (provider_id);

CREATE INDEX index_enrollments_on_tracked_search_id
ON app.enrollments
USING btree (tracked_search_id);

CREATE INDEX index_enrollments_on_tracking_data
ON app.enrollments
USING gin (tracking_data);

CREATE INDEX index_enrollments_on_user_account_id
ON app.enrollments
USING btree (user_account_id);

CREATE INDEX index_favorites_on_course_id
ON app.favorites
USING btree (course_id);

CREATE INDEX index_favorites_on_user_account_id
ON app.favorites
USING btree (user_account_id);

CREATE INDEX index_images_on_imageable_type_and_imageable_id
ON app.images
USING btree (imageable_type, imageable_id);

CREATE UNIQUE INDEX index_landing_pages_on_slug
ON app.landing_pages
USING btree (slug);

CREATE INDEX index_oauth_accounts_on_user_account_id
ON app.oauth_accounts
USING btree (user_account_id);

CREATE UNIQUE INDEX index_orphaned_profiles_on_user_account_id
ON app.orphaned_profiles
USING btree (user_account_id);

CREATE INDEX index_orphaned_profiles_on_name
ON app.orphaned_profiles
USING btree (name);

CREATE INDEX index_post_relations_on_post_id
ON app.post_relations
USING btree (post_id);

CREATE INDEX index_post_relations_on_relation_fields
ON app.post_relations
USING btree (relation_id, relation_type);

CREATE UNIQUE INDEX index_post_relations_unique
ON app.post_relations
USING btree (relation_id, relation_type, post_id);

CREATE INDEX index_posts_on_admin_account_id
ON app.posts
USING btree (admin_account_id);

CREATE INDEX index_posts_on_original_post_id
ON app.posts
USING btree (original_post_id);

CREATE UNIQUE INDEX index_posts_on_slug
ON app.posts
USING btree (slug);

CREATE INDEX index_posts_on_tags
ON app.posts
USING gin (tags);

CREATE INDEX index_profiles_on_user_account_id
ON app.profiles
USING btree (user_account_id);

CREATE UNIQUE INDEX index_profiles_on_username
ON app.profiles
USING btree (_username);

CREATE UNIQUE INDEX profiles_username_idx
ON app.profiles (username);

CREATE UNIQUE INDEX index_promo_accounts_on_user_account_id
ON app.promo_accounts
USING btree (user_account_id);

CREATE UNIQUE INDEX index_provider_logos_on_direct_upload_id
ON app.provider_logos
USING btree (direct_upload_id);

CREATE UNIQUE INDEX index_provider_logos_on_provider_id
ON app.provider_logos
USING btree (provider_id);

CREATE UNIQUE INDEX index_providers_on_name
ON app.providers
USING btree (name);

CREATE UNIQUE INDEX index_providers_on_slug
ON app.providers
USING btree (slug);

CREATE INDEX index_providers_on_old_id
ON app.providers
USING btree (old_id)
WHERE old_id IS NOT NULL;

CREATE UNIQUE INDEX index_slug_histories_on_course_id_and_slug
ON app.slug_histories
USING btree (course_id, slug);

CREATE INDEX index_subscriptions_on_profiles_id
ON app.subscriptions
USING btree (profile_id);

CREATE UNIQUE INDEX index_tracked_actions_on_compound_ext_id
ON app.tracked_actions
USING btree (compound_ext_id);

CREATE INDEX index_tracked_actions_on_enrollment_id
ON app.tracked_actions
USING btree (enrollment_id);

CREATE INDEX index_tracked_actions_on_payload
ON app.tracked_actions
USING gin (payload);

CREATE INDEX index_tracked_actions_on_status
ON app.tracked_actions
USING btree (status);

CREATE INDEX index_tracked_searches_on_action
ON app.tracked_searches
USING btree (action);

CREATE UNIQUE INDEX used_usernames_username_idx
ON app.used_usernames (username);

CREATE UNIQUE INDEX used_usernames_profile_id_username_idx
ON app.used_usernames (profile_id, username);

CREATE UNIQUE INDEX index_user_accounts_on_confirmation_token
ON app.user_accounts
USING btree (confirmation_token);

CREATE UNIQUE INDEX index_user_accounts_on_email
ON app.user_accounts
USING btree (email);

CREATE UNIQUE INDEX index_user_accounts_on_reset_password_token
ON app.user_accounts
USING btree (reset_password_token);

CREATE UNIQUE INDEX index_user_accounts_on_unlock_token
ON app.user_accounts
USING btree (unlock_token);

CREATE INDEX que_jobs_args_gin_idx
ON public.que_jobs
USING gin (args jsonb_path_ops);

CREATE INDEX que_jobs_data_gin_idx
ON public.que_jobs
USING gin (data jsonb_path_ops);

CREATE INDEX que_poll_idx
ON public.que_jobs
USING btree (queue, priority, run_at, id)
WHERE ((finished_at IS NULL) AND (expired_at IS NULL));

CREATE OR REPLACE VIEW api.admin_accounts AS
  SELECT
    id,
    email,
    NULL::varchar AS password,
    reset_password_token,
    reset_password_sent_at,
    remember_created_at,
    sign_in_count,
    current_sign_in_at,
    last_sign_in_at,
    current_sign_in_ip,
    last_sign_in_ip,
    confirmation_token,
    confirmed_at,
    confirmation_sent_at,
    unconfirmed_email,
    failed_attempts,
    unlock_token,
    locked_at,
    created_at,
    updated_at,
    preferences
  FROM app.admin_accounts;

CREATE OR REPLACE FUNCTION triggers.api_admin_accounts_view_instead() RETURNS trigger AS $$
BEGIN
  IF (TG_OP = 'UPDATE') THEN
    UPDATE app.admin_accounts
    SET
      email              = NEW.email,
      encrypted_password = crypt(NEW.password, gen_salt('bf', 11))
    WHERE
      id = OLD.id;
  ELSIF (TG_OP = 'INSERT') THEN
    INSERT INTO app.admin_accounts (
      email,
      encrypted_password
    ) VALUES (
      NEW.email,
      crypt(NEW.password, gen_salt('bf', 11))
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_admin_accounts_view_instead
  INSTEAD OF INSERT OR UPDATE
  ON api.admin_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_admin_accounts_view_instead();

CREATE OR REPLACE VIEW api.certificates AS
  SELECT
    id,
    user_account_id,
    file,
    created_at,
    updated_at,
    app.sign_certificate_s3_fetch(id, file, 3600)  AS fetch_url,
    app.sign_certificate_s3_upload(id, file, 3600) AS upload_url,
    app.content_type_by_extension(file)            AS file_content_type
  FROM app.certificates
  WHERE
    current_user = 'admin' OR (
      current_user = 'user' AND
      current_setting('request.jwt.claim.sub', true)::bigint = user_account_id
    );

CREATE OR REPLACE FUNCTION triggers.api_certificates_view_instead() RETURNS trigger AS $$
DECLARE
  certificate record;
BEGIN
  IF (TG_OP = 'INSERT') THEN
    IF if_admin(TRUE) OR if_user_by_id(NEW.user_account_id, TRUE) THEN
      INSERT INTO app.certificates (
        id,
        user_account_id,
        file
      ) VALUES (
        NEW.id,
        NEW.user_account_id,
        NEW.file
      ) ON CONFLICT (id) DO
        UPDATE set file = NEW.file
        RETURNING * INTO certificate;
    ELSE
      RAISE EXCEPTION 'Unauthorized Request';
    END IF;
  ELSIF (TG_OP = 'UPDATE') THEN
    IF if_admin(TRUE) OR ( if_user_by_id(OLD.user_account_id, TRUE) AND if_user_by_id(NEW.user_account_id, TRUE) ) THEN
      UPDATE app.certificates
      SET
        user_account_id = NEW.user_account_id,
        file            = NEW.file
      WHERE
        id = OLD.id
      RETURNING * INTO certificate;
    ELSE
      RAISE EXCEPTION 'Unauthorized Request';
    END IF;
  END IF;

  NEW.id                = certificate.id;
  NEW.created_at        = certificate.created_at;
  NEW.updated_at        = certificate.updated_at;
  NEW.fetch_url         = app.sign_certificate_s3_fetch(NEW.id, NEW.file, 3600);
  NEW.upload_url        = app.sign_certificate_s3_upload(NEW.id, NEW.file, 3600);
  NEW.file_content_type = app.content_type_by_extension(NEW.file);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_certificates_view_instead
  INSTEAD OF INSERT OR UPDATE
  ON api.certificates
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_certificates_view_instead();

CREATE OR REPLACE VIEW api.crawler_domains AS
  SELECT COALESCE( if_admin(crawler_domain.id),                            if_user_by_ids(crawler.user_account_ids, crawler_domain.id) ) AS id,
         crawler_domain.provider_crawler_id AS provider_crawler_id,
         crawler_domain.authority_confirmation_status AS authority_confirmation_status,
         COALESCE( if_admin(crawler_domain.authority_confirmation_token),  if_user_by_ids(crawler.user_account_ids, crawler_domain.authority_confirmation_token) ) AS authority_confirmation_token,
         COALESCE( if_admin(crawler_domain.authority_confirmation_method), if_user_by_ids(crawler.user_account_ids, crawler_domain.authority_confirmation_method) ) AS authority_confirmation_method,
         COALESCE( if_admin(crawler_domain.created_at),                    if_user_by_ids(crawler.user_account_ids, crawler_domain.created_at) ) AS created_at,
         COALESCE( if_admin(crawler_domain.updated_at),                    if_user_by_ids(crawler.user_account_ids, crawler_domain.updated_at) ) AS updated_at,
         crawler_domain.domain AS domain,
         COALESCE( if_admin(crawler_domain.authority_confirmation_salt),   if_user_by_ids(crawler.user_account_ids, crawler_domain.authority_confirmation_salt) ) AS authority_confirmation_salt
  FROM app.crawler_domains AS crawler_domain
  LEFT OUTER JOIN app.provider_crawlers AS crawler ON crawler.id = crawler_domain.provider_crawler_id
  ORDER BY id NULLS LAST;

CREATE OR REPLACE FUNCTION triggers.api_crawler_domains_view_instead_of_insert() RETURNS trigger AS $$
DECLARE
  crawler_domain RECORD;
  crawler RECORD;
  current_user_id bigint;
  log_session_id text;
BEGIN
  current_user_id := current_setting('request.jwt.claim.sub', true)::bigint;
  log_session_id := current_setting('request.header.sessionid', true)::text;

  IF if_admin(TRUE) THEN
    INSERT INTO app.crawler_domains (
      provider_crawler_id,
      authority_confirmation_status,
      domain
    ) VALUES (
      NEW.provider_crawler_id,
      COALESCE(NEW.authority_confirmation_status, 'unconfirmed'),
      NEW.domain
    ) RETURNING * INTO crawler_domain;

    RETURN crawler_domain;
  END IF;

  SELECT app.provider_crawlers.* FROM app.crawler_domains
  INNER JOIN app.provider_crawlers ON app.provider_crawlers.id = app.crawler_domains.provider_crawler_id
  WHERE app.crawler_domains.domain = NEW.domain AND app.provider_crawlers.status != 'deleted'
  LIMIT 1 INTO crawler;

  -- check for existing domains
  IF crawler IS NOT NULL THEN
    -- if there's one already for another user
    IF current_user_id != ALL(COALESCE(crawler.user_account_ids, ARRAY[]::int[])) THEN
      RAISE insufficient_privilege
        USING DETAIL = 'error', HINT = 'already_validated';
    -- if there's one already for me
    ELSE
      SELECT app.crawler_domains.* FROM app.crawler_domains
      WHERE app.crawler_domains.domain = NEW.domain
      LIMIT 1 INTO crawler_domain;

      RETURN crawler_domain;
    END IF;
  ELSE
    INSERT INTO app.crawler_domains (
      domain
    ) VALUES (
      NEW.domain
    ) ON CONFLICT ( domain ) DO UPDATE SET authority_confirmation_status = 'unconfirmed'
    RETURNING * INTO crawler_domain;

    IF crawler_domain.id IS NULL THEN
      SELECT * FROM app.crawler_domains
      WHERE app.crawler_domains.domain = NEW.domain
      LIMIT 1 INTO crawler_domain;
    END IF;

    INSERT INTO public.que_jobs
      (queue, priority, run_at, job_class, args, data)
      VALUES
      (
        'default',
        100,
        NOW(),
        'Developers::DomainAuthorityVerificationJob',
        ('["' || crawler_domain.id || '","' || current_user_id  ||  '","' || log_session_id || '"]')::jsonb,
        '{}'::jsonb
      );

    RETURN crawler_domain;
  END IF;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE TRIGGER api_crawler_domains_view_instead_of_insert
  INSTEAD OF INSERT
  ON api.crawler_domains
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_crawler_domains_view_instead_of_insert();

CREATE OR REPLACE FUNCTION triggers.api_crawler_domains_view_instead_of_update() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
BEGIN
  IF if_admin(TRUE) THEN
    UPDATE app.crawler_domains
    SET
      provider_crawler_id           = NEW.provider_crawler_id,
      authority_confirmation_status = NEW.authority_confirmation_status,
      authority_confirmation_token  = NEW.authority_confirmation_token,
      authority_confirmation_method = NEW.authority_confirmation_method,
      domain                        = NEW.domain
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    RETURN new_record;
  END IF;
  RAISE insufficient_privilege;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE TRIGGER api_crawler_domains_view_instead_of_update
  INSTEAD OF UPDATE
  ON api.crawler_domains
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_crawler_domains_view_instead_of_update();

CREATE OR REPLACE FUNCTION triggers.api_crawler_domains_view_instead_of_delete() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
BEGIN
  IF if_admin(TRUE) THEN
    UPDATE app.crawler_domains
    SET authority_confirmation_status = 'deleted'
    WHERE
      id = OLD.id;

    RETURN OLD;
  END IF;

  SELECT *
  FROM api.provider_crawlers AS crawler
  WHERE
    crawler.id = OLD.provider_crawler_id
  INTO new_record;

  IF NOT FOUND THEN
    RAISE insufficient_privilege;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_crawler_domains_view_instead_of_delete
  INSTEAD OF DELETE
  ON api.crawler_domains
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_crawler_domains_view_instead_of_delete();

CREATE OR REPLACE VIEW api.crawling_events AS
  SELECT *
  FROM app.crawling_events AS event
  WHERE
    (
      current_user = 'user'
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND event.provider_crawler_id = crawler.id
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
      )
    ) OR current_user = 'admin';

CREATE VIEW api.earnings AS
  SELECT
    tracked_actions.id,
    tracked_actions.sale_amount,
    tracked_actions.earnings_amount,
    tracked_actions.ext_click_date,
    tracked_actions.ext_sku_id,
    tracked_actions.ext_product_name,
    tracked_actions.ext_id,
    tracked_actions.source                             AS affiliate_network,
    providers.name                                     AS provider_name,
    courses.name                                       AS course_name,
    courses.url                                        AS course_url,
    (enrollments.tracking_data->>'country')::text      AS country,
    (enrollments.tracking_data->>'query_string')::text AS qs,
    (enrollments.tracking_data->>'referer')::text      AS referer,
    (enrollments.tracking_data->>'utm_source')::text   AS utm_source,
    (enrollments.tracking_data->>'utm_campaign')::text AS utm_campaign,
    (enrollments.tracking_data->>'utm_medium')::text   AS utm_medium,
    (enrollments.tracking_data->>'utm_term')::text     AS utm_term,
    tracked_actions.created_at
  FROM app.tracked_actions
    LEFT JOIN app.enrollments ON enrollments.id = tracked_actions.enrollment_id
    LEFT JOIN app.courses     ON courses.id     = enrollments.course_id
    LEFT JOIN app.providers   ON providers.id   = courses.provider_id;

CREATE OR REPLACE VIEW api.preview_courses AS
  SELECT course.*
  FROM app.preview_courses AS course
  WHERE
    (
      current_user = 'user'
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND course.provider_crawler_id = crawler.id
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
      )
    ) OR current_user = 'admin';

CREATE OR REPLACE FUNCTION triggers.api_preview_courses_view_instead_of_insert() RETURNS trigger AS $$
DECLARE
  preview_course RECORD;
  provider_crawler_id uuid;
  provider_id uuid;
  current_user_id bigint;
BEGIN
  current_user_id := current_setting('request.jwt.claim.sub', true)::bigint;
  preview_course := NEW;

  preview_course.id := COALESCE(preview_course.id, public.uuid_generate_v4());
  preview_course.status := 'pending';

  SELECT app.provider_crawlers.id,
         app.provider_crawlers.provider_id
    INTO provider_crawler_id, provider_id
    FROM app.provider_crawlers
    WHERE app.provider_crawlers.id = preview_course.provider_crawler_id
      AND current_user_id = ANY(app.provider_crawlers.user_account_ids)
    LIMIT 1;

  IF provider_crawler_id IS NOT NULL AND provider_id IS NOT NULL THEN
    INSERT INTO app.preview_courses (id, status, url, provider_crawler_id, provider_id)
          VALUES (preview_course.id, preview_course.status, preview_course.url, preview_course.provider_crawler_id, provider_id);

    INSERT INTO public.que_jobs
      (queue, priority, run_at, job_class, args, data)
      VALUES
      (
        'default',
        100,
        NOW(),
        'Developers::PreviewCourseProcessorJob',
        ('["' || provider_crawler_id || '","' || preview_course.id   || '"]')::jsonb,
        '{}'::jsonb
      );

    RETURN preview_course;
  ELSE
    RETURN NULL;
  END IF;

  RAISE insufficient_privilege;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE TRIGGER api_preview_courses_view_instead_of_insert
  INSTEAD OF INSERT OR UPDATE
  ON api.preview_courses
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_preview_courses_view_instead_of_insert();

CREATE OR REPLACE VIEW api.preview_course_images AS
  SELECT app.preview_course_images.*
  FROM app.preview_course_images
  INNER JOIN api.preview_courses ON api.preview_courses.id = app.preview_course_images.preview_course_id;

CREATE OR REPLACE VIEW api.profiles AS
  SELECT
    id,
    name,
    username,
    COALESCE( if_admin(short_bio), if_user_by_id(user_account_id, short_bio) ) AS short_bio,
    COALESCE( if_admin(long_bio), if_user_by_id(user_account_id, long_bio) ) AS long_bio,
    COALESCE( if_admin(instructor), if_user_by_id(user_account_id, instructor) ) AS instructor,
    COALESCE( if_admin(public), if_user_by_id(user_account_id, public) ) AS public,
    COALESCE( if_admin(country), if_user_by_id(user_account_id, country) ) AS country,
    COALESCE( if_admin(website), if_user_by_id(user_account_id, website) ) AS website,
    COALESCE(uploaded_avatar_url, oauth_avatar_url) AS avatar_url,
    COALESCE( if_admin(date_of_birth),   if_user_by_id(user_account_id, date_of_birth)   ) AS date_of_birth,
    user_account_id,
    COALESCE( if_admin(interests),       if_user_by_id(user_account_id, interests)       ) AS interests,
    COALESCE( if_admin(preferences),     if_user_by_id(user_account_id, preferences)     ) AS preferences,
    COALESCE( if_admin(social_profiles), if_user_by_id(user_account_id, social_profiles) ) AS social_profiles,
    COALESCE( if_admin(elearning_profiles), if_user_by_id(user_account_id, elearning_profiles) ) AS elearning_profiles,
    COALESCE( if_admin(course_ids), if_user_by_id(user_account_id, course_ids) ) AS course_ids
  FROM app.profiles;

CREATE OR REPLACE FUNCTION triggers.api_profiles_view_instead() RETURNS trigger AS $$
DECLARE
  exception_sql_state text;
  exception_column_name text;
  exception_constraint_name text;
  exception_table_name text;
  exception_message text;
  exception_detail text;
  exception_hint text;
BEGIN
  IF NEW.user_account_id != OLD.user_account_id THEN
    RAISE invalid_authorization_specification USING message = 'could not change user_account_id';
  END IF;

  IF if_admin(TRUE) IS NULL AND if_user_by_id(NEW.user_account_id, TRUE) IS NULL THEN
    RAISE insufficient_privilege;
  END IF;

  UPDATE app.profiles
  SET
    name                = NEW.name,
    date_of_birth       = NEW.date_of_birth,
    interests           = NEW.interests,
    preferences         = NEW.preferences,
    username            = NEW.username,
    short_bio           = NEW.short_bio,
    long_bio            = NEW.long_bio,
    instructor          = NEW.instructor,
    public              = NEW.public,
    website             = NEW.website,
    country             = NEW.country,
    course_ids          = NEW.course_ids,
    social_profiles     = NEW.social_profiles,
    elearning_profiles  = NEW.elearning_profiles
  WHERE
    id = OLD.id;

  RETURN NEW;
EXCEPTION
  WHEN insufficient_privilege THEN
    RAISE;
  WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS exception_message = MESSAGE_TEXT,
                          exception_detail = PG_EXCEPTION_DETAIL,
                          exception_hint = PG_EXCEPTION_HINT,
                          exception_sql_state = RETURNED_SQLSTATE,
                          exception_column_name = COLUMN_NAME,
                          exception_constraint_name = CONSTRAINT_NAME,
                          exception_table_name = TABLE_NAME;

  IF exception_detail = 'error' THEN
    RAISE EXCEPTION '%', exception_message
      USING DETAIL = exception_detail, HINT = exception_hint;
  ELSE
    -- constraint
    IF exception_sql_state IN ('23514', '23505') AND exception_constraint_name IS NOT NULL THEN
      exception_column_name := REGEXP_REPLACE(exception_constraint_name, '(.*)__(.*)', '\1');
      exception_sql_state := 'constraint';

      exception_detail := (
        CASE exception_column_name
          WHEN 'used_usernames_username_idx' THEN '010001'
          WHEN 'used_usernames_profile_id_username_idx'  THEN '010002'
          ELSE '010000'
        END
      );

    END IF;

    RAISE EXCEPTION '%', exception_message
      USING DETAIL = COALESCE(exception_detail, 'error'), HINT = exception_hint;

  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_profiles_view_instead
  INSTEAD OF UPDATE
  ON api.profiles
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_profiles_view_instead();

CREATE OR REPLACE VIEW api.promo_accounts AS
  SELECT
    app.promo_accounts.id AS id,
    COALESCE( if_admin(app.promo_accounts.user_account_id), if_user_by_id(app.promo_accounts.user_account_id, app.promo_accounts.user_account_id) ) AS user_account_id,
    COALESCE( if_admin(certificate_id),  if_user_by_id(app.promo_accounts.user_account_id, certificate_id)  ) AS certificate_id,
    COALESCE( if_admin(price),           if_user_by_id(app.promo_accounts.user_account_id, price)           ) AS price,
    COALESCE( if_admin(purchase_date),   if_user_by_id(app.promo_accounts.user_account_id, purchase_date)   ) AS purchase_date,
    COALESCE( if_admin(order_id),        if_user_by_id(app.promo_accounts.user_account_id, order_id)        ) AS order_id,
    COALESCE( if_admin(paypal_account),  if_user_by_id(app.promo_accounts.user_account_id, paypal_account)  ) AS paypal_account,
    COALESCE( if_admin(state),           if_user_by_id(app.promo_accounts.user_account_id, state)           ) AS state,
    COALESCE( if_admin(state_info),      if_user_by_id(app.promo_accounts.user_account_id, state_info)      ) AS state_info,
    COALESCE( if_admin(file),            if_user_by_id(app.promo_accounts.user_account_id, file)            ) AS file,
    app.promo_accounts.created_at,
    app.promo_accounts.updated_at
  FROM app.promo_accounts
  INNER JOIN app.certificates ON app.promo_accounts.certificate_id = app.certificates.id;

CREATE OR REPLACE FUNCTION triggers.api_promo_accounts_view_instead() RETURNS trigger AS $$
DECLARE
  cert_id uuid;
  cert_user_account_id bigint;
  cert_file varchar;
  promo_account record;
  exception_sql_state text;
  exception_column_name text;
  exception_constraint_name text;
  exception_table_name text;
  exception_message text;
  exception_detail text;
  exception_hint text;
BEGIN
  promo_account := NEW;

  IF TG_OP = 'INSERT' THEN
    SELECT current_setting('request.header.certificateid', true)::uuid INTO cert_id;
  ELSIF (TG_OP = 'UPDATE' AND if_admin(TRUE) IS NOT NULL) THEN
    cert_id := OLD.certificate_id;
  END IF;

  IF cert_id IS NULL THEN
    RAISE EXCEPTION 'Null certificate'
      USING DETAIL = 'error', HINT = 'promo_accounts.certificate_id.null';
  END IF;

  SELECT app.certificates.user_account_id FROM app.certificates WHERE id = cert_id INTO cert_user_account_id;

  IF if_admin(TRUE) IS NULL AND if_user_by_id(cert_user_account_id, TRUE) IS NULL THEN
    RAISE insufficient_privilege
      USING DETAIL = 'error', HINT = 'promo_accounts.user_account_id.mismatch';
  END IF;

  IF if_admin(TRUE) IS NULL AND if_user_by_id(promo_account.user_account_id, TRUE) IS NULL THEN
    RAISE insufficient_privilege
      USING DETAIL = 'error', HINT = 'promo_accounts.unauthorized';
  END IF;

  SELECT app.certificates.file FROM app.certificates WHERE id = cert_id INTO cert_file;

  IF (TG_OP = 'INSERT') THEN
    INSERT INTO app.promo_accounts (id, user_account_id, certificate_id, price, purchase_date, order_id, paypal_account, state)
    VALUES (COALESCE(promo_account.id, public.uuid_generate_v4()), promo_account.user_account_id, cert_id, promo_account.price, promo_account.purchase_date, promo_account.order_id, promo_account.paypal_account, 'pending')
    ON CONFLICT ON CONSTRAINT cntr_promo_accounts_user_account_id DO
      UPDATE SET certificate_id = EXCLUDED.certificate_id,
                 price = COALESCE(EXCLUDED.price, app.promo_accounts.price),
                 purchase_date = COALESCE(EXCLUDED.purchase_date, app.promo_accounts.purchase_date),
                 order_id = COALESCE(EXCLUDED.order_id, app.promo_accounts.order_id),
                 paypal_account = COALESCE(EXCLUDED.paypal_account, app.promo_accounts.paypal_account),
                 old_self = (SELECT json_agg(json_build_object('price', apc.price, 'purchase_date', apc.purchase_date, 'order_id', apc.order_id, 'paypal_account', apc.paypal_account, 'state', apc.state, 'state_info', apc.state_info))->>0 FROM app.promo_accounts AS apc where apc.id = id)::jsonb
      RETURNING * INTO promo_account;
  ELSIF (TG_OP = 'UPDATE' AND if_admin(TRUE) IS NOT NULL) THEN
    UPDATE app.promo_accounts
       SET state = COALESCE(NEW.state, OLD.state),
           state_info = CASE NEW.state = OLD.state AND NEW.state = 'rejected'
                        WHEN TRUE THEN
                          COALESCE(NEW.state_info, OLD.state_info)
                        ELSE
                          NEW.state_info
                        END,
           old_self = (SELECT json_agg(json_build_object('price', apc.price, 'purchase_date', apc.purchase_date, 'order_id', apc.order_id, 'paypal_account', apc.paypal_account, 'state', apc.state, 'state_info', apc.state_info))->>0 FROM app.promo_accounts AS apc where apc.id = id)::jsonb
        RETURNING * INTO promo_account;
  END IF;

  IF if_admin(TRUE) IS NULL AND promo_account.state IN ('locked', 'approved') THEN
    RAISE EXCEPTION 'Cannot update on locked promo'
      USING DETAIL = 'error', HINT = 'promo_accounts.state.locked';
  END IF;

  IF promo_account.state = 'rejected' AND promo_account.state_info IS NULL THEN
    RAISE EXCEPTION 'Rejected promo cannot have empty state_info'
      USING DETAIL = 'error', HINT = 'promo_accounts.state_info.blank';
  END IF;

  INSERT INTO app.promo_account_logs (promo_account_id, old, new, role)
    VALUES (promo_account.id, promo_account.old_self, json_build_object('price', promo_account.price, 'purchase_date', promo_account.purchase_date, 'order_id', promo_account.order_id, 'paypal_account', promo_account.paypal_account, 'state', promo_account.state, 'state_info', promo_account.state_info), current_user);

  RETURN (
    promo_account.id,
    promo_account.user_account_id,
    promo_account.certificate_id,
    promo_account.price,
    promo_account.purchase_date,
    promo_account.order_id,
    promo_account.paypal_account,
    promo_account.state,
    promo_account.state_info,
    cert_file,
    promo_account.created_at,
    promo_account.updated_at
  );
EXCEPTION
  WHEN insufficient_privilege THEN
    RAISE;
  WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS exception_message = MESSAGE_TEXT,
                          exception_detail = PG_EXCEPTION_DETAIL,
                          exception_hint = PG_EXCEPTION_HINT,
                          exception_sql_state = RETURNED_SQLSTATE,
                          exception_column_name = COLUMN_NAME,
                          exception_constraint_name = CONSTRAINT_NAME,
                          exception_table_name = TABLE_NAME;

  IF exception_detail = 'error' THEN
    RAISE EXCEPTION '%', exception_message
      USING DETAIL = exception_detail, HINT = exception_hint;
  ELSE
    -- constraint
    IF exception_sql_state IN ('23514', '23505') AND exception_constraint_name IS NOT NULL THEN
      exception_column_name := REGEXP_REPLACE(exception_constraint_name, '(.*)__(.*)', '\1');
      exception_sql_state := 'constraint';
    END IF;

    RAISE EXCEPTION '%', exception_message
      USING DETAIL = 'error', HINT = 'promo_accounts.' || COALESCE(exception_sql_state,'error') || '.' || exception_column_name;
  END IF;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER api_promo_accounts_view_instead
  INSTEAD OF INSERT OR UPDATE
  ON api.promo_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_promo_accounts_view_instead();

CREATE OR REPLACE VIEW api.provider_crawlers AS
  SELECT *
  FROM app.provider_crawlers
  WHERE
    (
      status != 'deleted' AND if_user_by_ids(user_account_ids, TRUE)
    ) OR current_user = 'admin';

CREATE OR REPLACE FUNCTION triggers.api_provider_crawlers_view_instead_of_insert() RETURNS trigger AS $$
DECLARE
  _provider_id uuid;
  new_record   RECORD;
BEGIN
  IF current_user = 'user' THEN
    INSERT INTO app.providers DEFAULT VALUES RETURNING id INTO _provider_id;

    INSERT INTO app.provider_crawlers (
      provider_id,
      user_account_ids,
      sitemaps
    ) VALUES (
      _provider_id,
      ARRAY[current_setting('request.jwt.claim.sub',true)::bigint],
      '{}'
    ) RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  IF if_admin(TRUE) THEN
    IF NEW.provider_id IS NOT NULL THEN
      _provider_id = NEW.provider_id;
    ELSE
      INSERT INTO app.providers DEFAULT VALUES RETURNING id INTO _provider_id;
    END IF;

    INSERT INTO app.provider_crawlers (
      user_agent_token,
      provider_id,
      published,
      status,
      user_account_ids,
      sitemaps
    ) VALUES (
      COALESCE(NEW.user_agent_token, public.uuid_generate_v4()),
      _provider_id,
      COALESCE(NEW.published, false),
      COALESCE(NEW.status, 'unverified'),
      COALESCE(NEW.user_account_ids, '{}'),
      COALESCE(app.fill_sitemaps(NEW.sitemaps), '{}')
    ) RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_provider_crawlers_view_instead_of_insert
  INSTEAD OF INSERT
  ON api.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_provider_crawlers_view_instead_of_insert();

CREATE OR REPLACE FUNCTION triggers.api_provider_crawlers_view_instead_of_update() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
  sitemap app.sitemap;
  user_id bigint;
  user_role varchar;
BEGIN
  user_id := current_setting('request.jwt.claim.sub', true)::bigint;
  user_role := current_setting('request.jwt.claim.role', true)::varchar;

  IF ARRAY_LENGTH(NEW.sitemaps, 1) > 0 AND NEW.sitemaps[1].id IS NOT NULL AND (
    OLD.sitemaps[1].id IS NULL OR
    OLD.sitemaps[1].id <> NEW.sitemaps[1].id
  ) THEN
    sitemap :=
      ( '(' || NEW.sitemaps[1].id  ||  ','
            || 'unverified'    ||  ','
            || NEW.sitemaps[1].url ||  ','
            || 'unknown'       ||  ')'
      )::app.sitemap;
  END IF;

  IF user_role = 'user' AND user_id = ANY(OLD.user_account_ids) THEN
    IF sitemap.id IS NOT NULL THEN
      UPDATE app.provider_crawlers
      SET
        user_account_ids = NEW.user_account_ids,
        sitemaps         = ARRAY[sitemap]::app.sitemap[]
      WHERE
        id = OLD.id
      RETURNING * INTO new_record;

      INSERT INTO public.que_jobs
        (queue, priority, run_at, job_class, args, data)
        VALUES
        (
          'default',
          100,
          NOW(),
          'Developers::SitemapVerificationJob',
          ('["' || OLD.id || '","' || sitemap.id  || '"]')::jsonb,
          '{}'::jsonb
        );
    ELSE
      UPDATE app.provider_crawlers
      SET
        user_account_ids = NEW.user_account_ids,
        urls             = NEW.urls
      WHERE
        id = OLD.id
      RETURNING * INTO new_record;

      INSERT INTO public.que_jobs
        (queue, priority, run_at, job_class, args, data)
        VALUES
        (
          'default',
          100,
          NOW(),
          'Developers::ProviderCrawlerSetupJob',
          ('["' || OLD.id || '"]')::jsonb,
          '{}'::jsonb
        );
    END IF;

    RETURN new_record;
  END IF;

  IF user_role = 'admin' THEN
    UPDATE app.provider_crawlers
    SET
      user_agent_token = NEW.user_agent_token,
      provider_id      = NEW.provider_id,
      published        = NEW.published,
      status           = NEW.status,
      user_account_ids = NEW.user_account_ids,
      sitemaps         = NEW.sitemaps,
      urls             = NEW.urls
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  RAISE insufficient_privilege;
END;
$$ SECURITY DEFINER LANGUAGE plpgsql;

CREATE TRIGGER api_provider_crawlers_view_instead_of_update
  INSTEAD OF UPDATE
  ON api.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_provider_crawlers_view_instead_of_update();

CREATE OR REPLACE FUNCTION triggers.api_provider_crawlers_view_instead_of_delete() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
BEGIN
  IF if_admin(TRUE) OR if_user_by_ids(OLD.user_account_ids, TRUE) THEN
    UPDATE app.provider_crawlers
    SET status = 'deleted'
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    RETURN OLD;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_provider_crawlers_view_instead_of_delete
  INSTEAD OF DELETE
  ON api.provider_crawlers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_provider_crawlers_view_instead_of_delete();

CREATE OR REPLACE VIEW api.provider_logos AS
  SELECT
    app.provider_logos.id as id,
    app.provider_logos.provider_id as provider_id,
    app.direct_uploads.file as file,
    app.direct_uploads.user_account_id as user_account_id,
    app.direct_uploads.created_at as created_at,
    app.direct_uploads.updated_at as updated_at,
    app.sign_direct_s3_fetch(app.direct_uploads.id, app.direct_uploads.file, 'provider_logos/' || app.provider_logos.provider_id::varchar, 3600)  AS fetch_url,
    app.sign_direct_s3_upload(app.direct_uploads.id, app.direct_uploads.file, 'provider_logos/' || app.provider_logos.provider_id::varchar, 3600) AS upload_url,
    app.content_type_by_extension(app.direct_uploads.file)                              AS file_content_type
  FROM app.provider_logos
  INNER JOIN app.direct_uploads ON app.direct_uploads.id = app.provider_logos.direct_upload_id
  WHERE
    current_user = 'admin' OR (
      current_user = 'user' AND
      current_setting('request.jwt.claim.sub', true)::bigint = app.direct_uploads.user_account_id
    );

CREATE OR REPLACE FUNCTION triggers.api_provider_logos_view_instead() RETURNS trigger AS $$
DECLARE
  current_user_id bigint;
  direct_upload app.direct_uploads;
  provider_logo app.provider_logo;
  filename varchar;
  file_content_type varchar;
  fetch_url text;
  upload_url text;
BEGIN
  current_user_id   := current_setting('request.jwt.claim.sub', true)::bigint;
  filename          := NEW.file;

  IF (TG_OP = 'INSERT') THEN
    INSERT INTO app.direct_uploads (
      id,
      user_account_id,
      file
    ) VALUES (
      NEW.id,
      current_user_id,
      filename
    ) ON CONFLICT (id) DO
      UPDATE set file = filename
      RETURNING * INTO direct_upload;
  ELSIF (TG_OP = 'UPDATE') THEN
    UPDATE app.direct_uploads
    SET
      user_account_id   = current_user_id,
      file              = filename
    WHERE
      id = OLD.id
    RETURNING * INTO direct_upload;
  END IF;

  file_content_type := app.content_type_by_extension(filename);
  fetch_url         := app.sign_direct_s3_fetch(direct_upload.id, filename, 'provider_logos/' || NEW.provider_id::varchar, 3600);
  upload_url        := app.sign_direct_s3_upload(direct_upload.id, filename, 'provider_logos/' || NEW.provider_id::varchar, 3600);

  INSERT INTO app.provider_logos (
    direct_upload_id,
    provider_id
  ) VALUES (
    direct_upload.id,
    NEW.provider_id
  ) ON CONFLICT (provider_id) DO
    UPDATE set direct_upload_id = direct_upload.id;

  SELECT app.provider_logos.id INTO provider_logo FROM app.provider_logos WHERE app.provider_logos.provider_id = NEW.provider_id;
  provider_logo.provider_id := NEW.provider_id;
  provider_logo.file := filename;
  provider_logo.user_account_id := current_user_id;
  provider_logo.created_at := direct_upload.created_at;
  provider_logo.updated_at := direct_upload.updated_at;
  provider_logo.fetch_url := fetch_url;
  provider_logo.upload_url := upload_url;
  provider_logo.file_content_type := file_content_type;

  RETURN provider_logo;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_provider_logos_view_instead
  INSTEAD OF INSERT OR UPDATE
  ON api.provider_logos
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_provider_logos_view_instead();

CREATE OR REPLACE VIEW api.providers AS
  SELECT *
  FROM app.providers AS provider
  WHERE
    (
      current_user = 'user'
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND crawler.provider_id = provider.id
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
      )
    ) OR current_user = 'admin';

CREATE OR REPLACE FUNCTION triggers.api_providers_view_instead_of_update() RETURNS trigger AS $$
DECLARE
  new_record RECORD;
  new_name CITEXT;
  new_name_changed_at TIMESTAMPTZ;
  new_name_dirty BOOLEAN;
BEGIN
  IF NEW.name IS NOT NULL THEN
    IF NEW.name ~ E'[\\s!\"\'#$%&()*+,\-./:;<=>?\[\\\\\\]^_`~]+' THEN
    RAISE EXCEPTION '%', 'error'
        USING DETAIL = 'name is invalid', HINT = 'forbidden characters present';
    END IF;

    IF LENGTH(NEW.name) > 50 THEN
      RAISE EXCEPTION '%', 'error'
        USING DETAIL = 'name is invalid', HINT = 'length is greater than 50';
    END IF;
  END IF;

  IF current_user = 'user' THEN
    IF NEW.name IS NOT NULL AND (OLD.name_changed_at IS NULL OR AGE(OLD.name_changed_at) > '5 days') THEN
      new_name := NEW.name;
      new_name_changed_at := NOW();
      new_name_dirty := false;
    ELSE
      new_name := OLD.name;
      new_name_changed_at := OLD.name_changed_at;
      new_name_dirty := OLD.name_dirty;
    END IF;

    UPDATE app.providers
    SET
      name            = new_name,
      name_dirty      = new_name_dirty,
      name_changed_at = new_name_changed_at,
      description     = NEW.description,
      slug            = COALESCE(OLD.slug, app.slugify(NEW.slug), app.slugify(new_name))
    WHERE
      id = OLD.id
      AND EXISTS (
        SELECT 1
        FROM app.provider_crawlers AS crawler
        WHERE
          crawler.status != 'deleted'
          AND if_user_by_ids(crawler.user_account_ids, TRUE)
          AND crawler.provider_id = app.providers.id
      )
    RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  IF if_admin(TRUE) THEN
    IF NEW.name IS NOT NULL THEN
      new_name := NEW.name;
      new_name_changed_at := NOW();
      new_name_dirty := false;
    ELSE
      new_name := OLD.name;
      new_name_changed_at := OLD.name_changed_at;
      new_name_dirty := OLD.name_dirty;
    END IF;

    UPDATE app.providers
    SET
      name                 = new_name,
      name_dirty           = new_name_dirty,
      name_changed_at      = new_name_changed_at,
      description          = NEW.description,
      slug                 = NEW.slug,
      afn_url_template     = NEW.afn_url_template,
      published            = NEW.published,
      published_at         = NEW.published_at,
      encoded_deep_linking = NEW.encoded_deep_linking
    WHERE
      id = OLD.id
    RETURNING * INTO new_record;

    RETURN new_record;
  END IF;

  RAISE insufficient_privilege;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_providers_view_instead_of_update
  INSTEAD OF UPDATE
  ON api.providers
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_providers_view_instead_of_update();

CREATE OR REPLACE VIEW api.user_accounts AS
  SELECT
    id,
    email,
    NULL::varchar                                                                           AS password,
    COALESCE( if_admin(reset_password_token),   if_user_by_id(id, reset_password_token)   ) AS reset_password_token,
    COALESCE( if_admin(reset_password_sent_at), if_user_by_id(id, reset_password_sent_at) ) AS reset_password_sent_at,
    COALESCE( if_admin(remember_created_at),    if_user_by_id(id, remember_created_at)    ) AS remember_created_at,
    COALESCE( if_admin(sign_in_count),          if_user_by_id(id, sign_in_count)          ) AS sign_in_count,
    COALESCE( if_admin(current_sign_in_at),     if_user_by_id(id, current_sign_in_at)     ) AS current_sign_in_at,
    COALESCE( if_admin(last_sign_in_at),        if_user_by_id(id, last_sign_in_at)        ) AS last_sign_in_at,
    COALESCE( if_admin(current_sign_in_ip),     if_user_by_id(id, current_sign_in_ip)     ) AS current_sign_in_ip,
    COALESCE( if_admin(last_sign_in_ip),        if_user_by_id(id, last_sign_in_ip)        ) AS last_sign_in_ip,
    COALESCE( if_admin(tracking_data),          if_user_by_id(id, tracking_data)          ) AS tracking_data,
    COALESCE( if_admin(confirmation_token),     if_user_by_id(id, confirmation_token)     ) AS confirmation_token,
    COALESCE( if_admin(confirmed_at),           if_user_by_id(id, confirmed_at)           ) AS confirmed_at,
    COALESCE( if_admin(confirmation_sent_at),   if_user_by_id(id, confirmation_sent_at)   ) AS confirmation_sent_at,
    COALESCE( if_admin(unconfirmed_email),      if_user_by_id(id, unconfirmed_email)      ) AS unconfirmed_email,
    COALESCE( if_admin(failed_attempts),        if_user_by_id(id, failed_attempts)        ) AS failed_attempts,
    COALESCE( if_admin(unlock_token),           if_user_by_id(id, unlock_token)           ) AS unlock_token,
    COALESCE( if_admin(locked_at),              if_user_by_id(id, locked_at)              ) AS locked_at,
    COALESCE( if_admin(destroyed_at),           if_user_by_id(id, destroyed_at)           ) AS destroyed_at,
    COALESCE( if_admin(autogen_email_for_oauth),if_user_by_id(id, autogen_email_for_oauth)) AS autogen_email_for_oauth,
    created_at,
    updated_at
  FROM app.user_accounts;

CREATE OR REPLACE FUNCTION triggers.api_user_accounts_view_instead() RETURNS trigger AS $$
BEGIN
  IF if_admin(TRUE) IS NULL AND if_user_by_id(NEW.id, TRUE) IS NULL THEN
    RAISE insufficient_privilege;
  END IF;

  UPDATE app.user_accounts
  SET
    email              = NEW.email,
    encrypted_password = crypt(NEW.password, gen_salt('bf', 11))
  WHERE
    id = OLD.id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER api_user_accounts_view_instead
  INSTEAD OF UPDATE
  ON api.user_accounts
  FOR EACH ROW
    EXECUTE PROCEDURE triggers.api_user_accounts_view_instead();

CREATE MATERIALIZED VIEW app.provider_price_ranges AS (
  SELECT provider_id,
         MIN(app.price_in_decimal(price)),
         MAX(app.price_in_decimal(price))
    FROM (
      SELECT DISTINCT ON (id)
             provider_id,
             MIN(CASE WHEN TYPE = 'single_course' THEN price ELSE total_price END) AS price
        FROM (
          SELECT id,
                provider_id,
                jsonb_array_elements(pricing_models)->>'type' AS type,
                jsonb_array_elements(pricing_models)->>'price' AS price,
                jsonb_array_elements(pricing_models)->>'total_price' AS total_price,
                app.currency_index(jsonb_array_elements(pricing_models)->>'currency'::VARCHAR) AS currency
            FROM app.courses
            WHERE published = 't'
        ) sq
        GROUP BY id, provider_id, currency
    ) sq2 GROUP BY provider_id
);

CREATE MATERIALIZED VIEW bi.sales AS (
  SELECT
    DATE_TRUNC('day', tracked_actions.ext_click_date)::date as date,
    enrollments.tracking_data->>'utm_source' AS utm_source,
    enrollments.tracking_data->>'utm_medium' AS utm_medium,
    enrollments.tracking_data->>'utm_campaign' AS utm_campaign,
    tracked_actions.source AS payment_source,
    providers.name AS provider,
    enrollments.tracking_data->>'country' AS country,
    (courses.locale).language AS course_language,
    courses.category AS course_category,
    SUM(tracked_actions.earnings_amount) FILTER (WHERE tracked_actions.earnings_amount > 0) AS gross_revenue,
    SUM(tracked_actions.earnings_amount) FILTER (WHERE tracked_actions.earnings_amount < 0) AS refunded_amount,
    SUM(tracked_actions.earnings_amount) AS net_income,
    COUNT(tracked_actions.id) FILTER (WHERE tracked_actions.earnings_amount > 0) AS num_sales,
    COUNT(tracked_actions.id) FILTER (WHERE tracked_actions.earnings_amount < 0) AS num_refunds
  FROM
    app.tracked_actions
  INNER JOIN
    app.enrollments ON tracked_actions.enrollment_id = enrollments.id
  LEFT JOIN
    app.courses ON enrollments.course_id = courses.id
  INNER JOIN
    app.providers ON enrollments.provider_id = providers.id
  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9
  ORDER BY 1
);

CREATE MATERIALIZED VIEW bi.exit_clicks AS (

  SELECT
    DATE_TRUNC('day', enrollments.created_at)::date as date,
    enrollments.tracking_data->>'utm_source' AS utm_source,
    enrollments.tracking_data->>'utm_medium' AS utm_medium,
    enrollments.tracking_data->>'utm_campaign' AS utm_campaign,
    providers.name AS provider,
    enrollments.tracking_data->>'country' AS country,
    (courses.locale).language AS course_language,
    courses.category AS course_category,
    COUNT(DISTINCT enrollments.tracking_cookies->>'id') AS unique_clicks
  FROM
    app.enrollments
  LEFT JOIN
    app.courses ON enrollments.course_id = courses.id
  INNER JOIN
    app.providers ON enrollments.provider_id = providers.id
  GROUP BY 1, 2, 3, 4, 5, 6, 7, 8
  ORDER BY 1

);

CREATE INDEX index_sales_on_date
ON bi.sales
USING btree (date);

CREATE INDEX index_exit_clicks_on_date
ON bi.exit_clicks
USING btree (date);

CREATE MATERIALIZED VIEW subsets.course_summaries AS (
  SELECT
    courses.id,
    courses.provider_id,
    courses.category,
    courses.published,
    courses.up_to_date_id,
    courses.updated_at,
    COUNT( DISTINCT enrollments.id )                                                          AS enrollment_count,
    COUNT( DISTINCT enrollments.id ) FILTER ( WHERE enrollments.user_account_id IS NOT NULL ) AS user_accounts_count,
    COUNT( DISTINCT tracked_actions.enrollment_id )                                           AS tracked_actions_count
  FROM app.courses
  LEFT JOIN app.enrollments ON
    enrollments.course_id = courses.id
  LEFT JOIN app.tracked_actions ON
    tracked_actions.enrollment_id = enrollments.id
  GROUP BY 1, 2, 3, 4, 5, 6
);

CREATE OR REPLACE VIEW subsets.course_filters AS (
  SELECT
    id,
    provider_id,
    category,
    published,
    up_to_date_id,
    updated_at,
    CASE WHEN up_to_date_id IS NOT NULL THEN TRUE ELSE FALSE END AS has_up_to_date_id,
    CASE WHEN enrollment_count      > 0 THEN TRUE ELSE FALSE END AS has_enrollment,
    CASE WHEN user_accounts_count   > 0 THEN TRUE ELSE FALSE END AS has_user_account,
    CASE WHEN tracked_actions_count > 0 THEN TRUE ELSE FALSE END AS has_tracked_actiont
  FROM subsets.course_summaries
);

CREATE OR REPLACE VIEW subsets.courses AS (
  WITH RECURSIVE selected_courses AS (
    (
      SELECT
        filters.*,
        ROW_NUMBER() OVER (PARTITION BY provider_id, category, published, has_up_to_date_id, has_enrollment, has_user_account, has_tracked_actiont ORDER BY updated_at DESC) AS row
      FROM subsets.course_filters AS filters
     ) UNION (
      SELECT
        filters.*,
        ROW_NUMBER() OVER (PARTITION BY provider_id, category, published, has_up_to_date_id, has_enrollment, has_user_account, has_tracked_actiont ORDER BY updated_at ASC) AS row
      FROM subsets.course_filters AS filters
    ) UNION (
      SELECT
        filters.*,
        selected.row
      FROM subsets.course_filters AS filters
      INNER JOIN selected_courses AS selected ON
        selected.up_to_date_id = filters.id
    )
  )

  SELECT courses.*
  FROM (
    SELECT
      id,
      provider_id,
      category,
      published,
      up_to_date_id,
      updated_at,
      has_up_to_date_id,
      has_enrollment,
      has_user_account,
      has_tracked_actiont,
      MIN(row) AS row
    FROM selected_courses
    GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
  ) AS c
  INNER JOIN app.courses ON
    courses.id = c.id
  WHERE row <= 10
);

CREATE OR REPLACE VIEW subsets.enrollments AS (
  WITH selected_enrollments AS (
    SELECT
      enrollments.*,
      ROW_NUMBER() OVER (PARTITION BY enrollments.course_id, course_filters.has_tracked_actiont ORDER BY enrollments.updated_at DESC) AS row
    FROM app.enrollments
    INNER JOIN subsets.courses ON
      enrollments.course_id = courses.id
    INNER JOIN subsets.course_filters ON
      course_filters.id = courses.id
  )

  SELECT
    id,
    user_account_id,
    course_id,
    tracked_url,
    description,
    user_rating,
    tracked_search_id,
    tracking_data,
    tracking_cookies,
    created_at,
    updated_at
  FROM selected_enrollments
  WHERE row < 8
);

CREATE OR REPLACE VIEW subsets.tracked_actions AS (
  SELECT tracked_actions.*
  FROM app.tracked_actions
  INNER JOIN subsets.enrollments ON
    tracked_actions.enrollment_id = enrollments.id
);

CREATE ROLE "anonymous";

GRANT USAGE ON SCHEMA api      TO "anonymous";
GRANT USAGE ON SCHEMA jwt      TO "anonymous";
GRANT USAGE ON SCHEMA settings TO "anonymous";

CREATE USER marketing WITH PASSWORD '$MARKETING_PASSWORD';

GRANT CONNECT ON DATABASE $POSTGRES_DB    TO "marketing";
GRANT USAGE   ON SCHEMA app               TO "marketing";
GRANT USAGE   ON SCHEMA bi                TO "marketing";
GRANT SELECT  ON ALL TABLES IN SCHEMA app TO "marketing";
GRANT SELECT  ON ALL TABLES IN SCHEMA bi  TO "marketing";

CREATE ROLE "user";

GRANT USAGE ON SCHEMA api      TO "user";
GRANT USAGE ON SCHEMA app      TO "user";
GRANT USAGE ON SCHEMA jwt      TO "user";
GRANT USAGE ON SCHEMA settings TO "user";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "user";

GRANT SELECT, INSERT, UPDATE, DELETE             ON app.certificates          TO "user";
GRANT SELECT, INSERT, UPDATE,         REFERENCES ON app.course_reviews        TO "user";
GRANT SELECT, INSERT, UPDATE,         REFERENCES ON app.crawler_domains       TO "user";
GRANT SELECT                                     ON app.crawling_events       TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE             ON app.direct_uploads        TO "user";
GRANT SELECT, REFERENCES                         ON app.orphaned_profiles     TO "user";
GRANT SELECT, INSERT,         DELETE             ON app.preview_courses       TO "user";
GRANT SELECT, INSERT,         DELETE             ON app.preview_course_images TO "user";
GRANT SELECT,         UPDATE                     ON app.profiles              TO "user";
GRANT SELECT, INSERT, UPDATE,         REFERENCES ON app.promo_accounts        TO "user";
GRANT SELECT, INSERT, UPDATE,         REFERENCES ON app.promo_account_logs    TO "user";
GRANT SELECT, INSERT, UPDATE,         REFERENCES ON app.providers             TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.provider_crawlers     TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE             ON app.provider_logos        TO "user";
GRANT SELECT,         UPDATE,         REFERENCES ON app.user_accounts         TO "user";
GRANT SELECT, INSERT                             ON app.used_usernames        TO "user";


GRANT SELECT, INSERT, UPDATE, DELETE ON api.certificates          TO "user";
GRANT SELECT, INSERT, UPDATE         ON api.crawler_domains       TO "user";
GRANT SELECT                         ON api.crawling_events       TO "user";
GRANT SELECT, INSERT,         DELETE ON api.preview_courses       TO "user";
GRANT SELECT, INSERT,         DELETE ON api.preview_course_images TO "user";
GRANT SELECT,         UPDATE         ON api.profiles              TO "user";
GRANT SELECT, INSERT, UPDATE         ON api.promo_accounts        TO "user";
GRANT SELECT,         UPDATE         ON api.providers             TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.provider_crawlers     TO "user";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.provider_logos        TO "user";
GRANT SELECT,         UPDATE         ON api.user_accounts         TO "user";

CREATE ROLE "admin";

GRANT USAGE ON SCHEMA api      TO "admin";
GRANT USAGE ON SCHEMA app      TO "admin";
GRANT USAGE ON SCHEMA jwt      TO "admin";
GRANT USAGE ON SCHEMA settings TO "admin";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "admin";

GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.admin_accounts        TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.admin_profiles        TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE             ON app.certificates          TO "admin";
GRANT SELECT, INSERT, UPDATE,         REFERENCES ON app.courses               TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.course_reviews        TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.crawler_domains       TO "admin";
GRANT SELECT                                     ON app.crawling_events       TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE             ON app.direct_uploads        TO "admin";
GRANT SELECT, INSERT,         DELETE, REFERENCES ON app.enrollments           TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.favorites             TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.images                TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.landing_pages         TO "admin";
GRANT SELECT,         UPDATE, DELETE, REFERENCES ON app.oauth_accounts        TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.orphaned_profiles     TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.posts                 TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.post_relations        TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.preview_courses       TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.preview_course_images TO "admin";
GRANT SELECT, INSERT, UPDATE,         REFERENCES ON app.profiles              TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.promo_accounts        TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.promo_account_logs    TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.providers             TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.provider_crawlers     TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE             ON app.provider_logos        TO "admin";
GRANT SELECT                                     ON app.tracked_actions       TO "admin";
GRANT SELECT                                     ON app.tracked_searches      TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE             ON app.used_usernames        TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON app.user_accounts         TO "admin";


GRANT SELECT, INSERT, UPDATE, DELETE ON api.admin_accounts        TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.certificates          TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.crawler_domains       TO "admin";
GRANT SELECT                         ON api.crawling_events       TO "admin";
GRANT SELECT                         ON api.earnings              TO "admin";
GRANT SELECT, INSERT,         DELETE ON api.preview_courses       TO "admin";
GRANT SELECT, INSERT,         DELETE ON api.preview_course_images TO "admin";
GRANT SELECT,         UPDATE         ON api.profiles              TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.promo_accounts        TO "admin";
GRANT SELECT, INSERT, UPDATE         ON api.providers             TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.provider_crawlers     TO "admin";
GRANT SELECT, INSERT, UPDATE, DELETE ON api.provider_logos        TO "admin";
GRANT SELECT,         UPDATE, DELETE ON api.user_accounts         TO "admin";

CREATE ROLE "authenticator" NOINHERIT login password '$AUTHENTICATOR_PASSWORD';

GRANT "user"      TO "authenticator";
GRANT "admin"     TO "authenticator";
GRANT "anonymous" TO "authenticator";

GRANT USAGE ON SCHEMA api      TO "authenticator";
GRANT USAGE ON SCHEMA jwt      TO "authenticator";
GRANT USAGE ON SCHEMA settings TO "authenticator";

GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA app TO "authenticator";

GRANT SELECT ON app.user_accounts, app.admin_accounts TO "authenticator";

CREATE USER stitch WITH PASSWORD '$STITCHDATA_PASSWORD';

GRANT CONNECT ON DATABASE $POSTGRES_DB    TO "stitch";
GRANT CREATE  ON DATABASE $POSTGRES_DB    TO "stitch";
GRANT CREATE  ON SCHEMA bi                TO "stitch";
GRANT USAGE   ON SCHEMA bi                TO "stitch";

INSERT INTO public.schema_migrations(version) VALUES
  ('20190819000000'),
  ('20190819214900'),
  ('20190826172519'),
  ('20190830142600'),
  ('20190830143200'),
  ('20190830150100'),
  ('20190830151600'),
  ('20190910140600'),
  ('20190919074600'),
  ('20190919165000'),
  ('20190919170100'),
  ('20190919170101'),
  ('20190923175923'),
  ('20191009074600'),
  ('20191017152900'),
  ('20191107132512'),
  ('20191107173251'),
  ('20191108115021'),
  ('20191111180132'),
  ('20191209180900'),
  ('20191212123500'),
  ('20191226144400'),
  ('20200107070000'),
  ('20200128095304'),
  ('20200203120812'),
  ('20200203165316'),
  ('20200203183213'),
  ('20200211192257'),
  ('20200213183318'),
  ('20200217174600'),
  ('20200218175146'),
  ('20200221092300'),
  ('20200221182700'),
  ('20200304173100'),
  ('20200307102619'),
  ('20200310145105'),
  ('20200311142800'),
  ('20200316074600'),
  ('20200319071300'),
  ('20200322074600'),
  ('20200327164000'),
  ('20200401180601'),
  ('20200417184601'),
  ('20200511124730'),
  ('20200513185742'),
  ('20200514221948'),
  ('20200521195121'),
  ('20200522194450'),
  ('20200525145059'),
  ('20200526201913'),
  ('20200528231134'),
  ('20200530022039'),
  ('20200602150635'),
  ('20200610204428'),
  ('20200611152646'),
  ('20200611173112'),
  ('20200616020721'),
  ('20200619152842'),
  ('20200623184524'),
  ('20200626162146'),
  ('20200628233835'),
  ('20200629194941'),
  ('20200701142918'),
  ('20200701200531'),
  ('20200703150025'),
  ('20200707144858'),
  ('20200707202743'),
  ('20200708161246'),
  ('20200708161247'),
  ('20200709184800'),
  ('20200715010430');

INSERT INTO settings.secrets (key, value) VALUES ('app.jwt_secret', '$JWT_SECRET');

COMMIT;
